// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `signalservice.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Envelope {
    // message fields
    field_type: ::std::option::Option<Envelope_Type>,
    sourceE164: ::protobuf::SingularField<::std::string::String>,
    sourceUuid: ::protobuf::SingularField<::std::string::String>,
    sourceDevice: ::std::option::Option<u32>,
    relay: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    legacyMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    serverGuid: ::protobuf::SingularField<::std::string::String>,
    serverTimestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Envelope {
    fn default() -> &'a Envelope {
        <Envelope as ::protobuf::Message>::default_instance()
    }
}

impl Envelope {
    pub fn new() -> Envelope {
        ::std::default::Default::default()
    }

    // optional .signalservice.Envelope.Type type = 1;


    pub fn get_field_type(&self) -> Envelope_Type {
        self.field_type.unwrap_or(Envelope_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Envelope_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string sourceE164 = 2;


    pub fn get_sourceE164(&self) -> &str {
        match self.sourceE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sourceE164(&mut self) {
        self.sourceE164.clear();
    }

    pub fn has_sourceE164(&self) -> bool {
        self.sourceE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceE164(&mut self, v: ::std::string::String) {
        self.sourceE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceE164(&mut self) -> &mut ::std::string::String {
        if self.sourceE164.is_none() {
            self.sourceE164.set_default();
        }
        self.sourceE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceE164(&mut self) -> ::std::string::String {
        self.sourceE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sourceUuid = 11;


    pub fn get_sourceUuid(&self) -> &str {
        match self.sourceUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sourceUuid(&mut self) {
        self.sourceUuid.clear();
    }

    pub fn has_sourceUuid(&self) -> bool {
        self.sourceUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceUuid(&mut self, v: ::std::string::String) {
        self.sourceUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceUuid(&mut self) -> &mut ::std::string::String {
        if self.sourceUuid.is_none() {
            self.sourceUuid.set_default();
        }
        self.sourceUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceUuid(&mut self) -> ::std::string::String {
        self.sourceUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 sourceDevice = 7;


    pub fn get_sourceDevice(&self) -> u32 {
        self.sourceDevice.unwrap_or(0)
    }
    pub fn clear_sourceDevice(&mut self) {
        self.sourceDevice = ::std::option::Option::None;
    }

    pub fn has_sourceDevice(&self) -> bool {
        self.sourceDevice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceDevice(&mut self, v: u32) {
        self.sourceDevice = ::std::option::Option::Some(v);
    }

    // optional string relay = 3;


    pub fn get_relay(&self) -> &str {
        match self.relay.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_relay(&mut self) {
        self.relay.clear();
    }

    pub fn has_relay(&self) -> bool {
        self.relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay(&mut self, v: ::std::string::String) {
        self.relay = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay(&mut self) -> &mut ::std::string::String {
        if self.relay.is_none() {
            self.relay.set_default();
        }
        self.relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay(&mut self) -> ::std::string::String {
        self.relay.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 5;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bytes legacyMessage = 6;


    pub fn get_legacyMessage(&self) -> &[u8] {
        match self.legacyMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_legacyMessage(&mut self) {
        self.legacyMessage.clear();
    }

    pub fn has_legacyMessage(&self) -> bool {
        self.legacyMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacyMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacyMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacyMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacyMessage.is_none() {
            self.legacyMessage.set_default();
        }
        self.legacyMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacyMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.legacyMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes content = 8;


    pub fn get_content(&self) -> &[u8] {
        match self.content.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        self.content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string serverGuid = 9;


    pub fn get_serverGuid(&self) -> &str {
        match self.serverGuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverGuid(&mut self) {
        self.serverGuid.clear();
    }

    pub fn has_serverGuid(&self) -> bool {
        self.serverGuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverGuid(&mut self, v: ::std::string::String) {
        self.serverGuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverGuid(&mut self) -> &mut ::std::string::String {
        if self.serverGuid.is_none() {
            self.serverGuid.set_default();
        }
        self.serverGuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverGuid(&mut self) -> ::std::string::String {
        self.serverGuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 serverTimestamp = 10;


    pub fn get_serverTimestamp(&self) -> u64 {
        self.serverTimestamp.unwrap_or(0)
    }
    pub fn clear_serverTimestamp(&mut self) {
        self.serverTimestamp = ::std::option::Option::None;
    }

    pub fn has_serverTimestamp(&self) -> bool {
        self.serverTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverTimestamp(&mut self, v: u64) {
        self.serverTimestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Envelope {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceE164)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceUuid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sourceDevice = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relay)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.legacyMessage)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.content)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverGuid)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverTimestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.sourceE164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sourceUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.sourceDevice {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.relay.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.legacyMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.serverGuid.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.serverTimestamp {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.sourceE164.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sourceUuid.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.sourceDevice {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.relay.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.legacyMessage.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.serverGuid.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.serverTimestamp {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Envelope {
        Envelope::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Envelope_Type>>(
                "type",
                |m: &Envelope| { &m.field_type },
                |m: &mut Envelope| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceE164",
                |m: &Envelope| { &m.sourceE164 },
                |m: &mut Envelope| { &mut m.sourceE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceUuid",
                |m: &Envelope| { &m.sourceUuid },
                |m: &mut Envelope| { &mut m.sourceUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sourceDevice",
                |m: &Envelope| { &m.sourceDevice },
                |m: &mut Envelope| { &mut m.sourceDevice },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relay",
                |m: &Envelope| { &m.relay },
                |m: &mut Envelope| { &mut m.relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Envelope| { &m.timestamp },
                |m: &mut Envelope| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "legacyMessage",
                |m: &Envelope| { &m.legacyMessage },
                |m: &mut Envelope| { &mut m.legacyMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &Envelope| { &m.content },
                |m: &mut Envelope| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverGuid",
                |m: &Envelope| { &m.serverGuid },
                |m: &mut Envelope| { &mut m.serverGuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "serverTimestamp",
                |m: &Envelope| { &m.serverTimestamp },
                |m: &mut Envelope| { &mut m.serverTimestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Envelope>(
                "Envelope",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Envelope {
        static instance: ::protobuf::rt::LazyV2<Envelope> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Envelope::new)
    }
}

impl ::protobuf::Clear for Envelope {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.sourceE164.clear();
        self.sourceUuid.clear();
        self.sourceDevice = ::std::option::Option::None;
        self.relay.clear();
        self.timestamp = ::std::option::Option::None;
        self.legacyMessage.clear();
        self.content.clear();
        self.serverGuid.clear();
        self.serverTimestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Envelope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Envelope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Envelope_Type {
    UNKNOWN = 0,
    CIPHERTEXT = 1,
    KEY_EXCHANGE = 2,
    PREKEY_BUNDLE = 3,
    RECEIPT = 5,
    UNIDENTIFIED_SENDER = 6,
}

impl ::protobuf::ProtobufEnum for Envelope_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Envelope_Type> {
        match value {
            0 => ::std::option::Option::Some(Envelope_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Envelope_Type::CIPHERTEXT),
            2 => ::std::option::Option::Some(Envelope_Type::KEY_EXCHANGE),
            3 => ::std::option::Option::Some(Envelope_Type::PREKEY_BUNDLE),
            5 => ::std::option::Option::Some(Envelope_Type::RECEIPT),
            6 => ::std::option::Option::Some(Envelope_Type::UNIDENTIFIED_SENDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Envelope_Type] = &[
            Envelope_Type::UNKNOWN,
            Envelope_Type::CIPHERTEXT,
            Envelope_Type::KEY_EXCHANGE,
            Envelope_Type::PREKEY_BUNDLE,
            Envelope_Type::RECEIPT,
            Envelope_Type::UNIDENTIFIED_SENDER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Envelope_Type>("Envelope.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Envelope_Type {
}

impl ::std::default::Default for Envelope_Type {
    fn default() -> Self {
        Envelope_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Envelope_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Content {
    // message fields
    pub dataMessage: ::protobuf::SingularPtrField<DataMessage>,
    pub syncMessage: ::protobuf::SingularPtrField<SyncMessage>,
    pub callMessage: ::protobuf::SingularPtrField<CallMessage>,
    pub nullMessage: ::protobuf::SingularPtrField<NullMessage>,
    pub receiptMessage: ::protobuf::SingularPtrField<ReceiptMessage>,
    pub typingMessage: ::protobuf::SingularPtrField<TypingMessage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Content {
    fn default() -> &'a Content {
        <Content as ::protobuf::Message>::default_instance()
    }
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage dataMessage = 1;


    pub fn get_dataMessage(&self) -> &DataMessage {
        self.dataMessage.as_ref().unwrap_or_else(|| <DataMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataMessage(&mut self) {
        self.dataMessage.clear();
    }

    pub fn has_dataMessage(&self) -> bool {
        self.dataMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataMessage(&mut self, v: DataMessage) {
        self.dataMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataMessage(&mut self) -> &mut DataMessage {
        if self.dataMessage.is_none() {
            self.dataMessage.set_default();
        }
        self.dataMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataMessage(&mut self) -> DataMessage {
        self.dataMessage.take().unwrap_or_else(|| DataMessage::new())
    }

    // optional .signalservice.SyncMessage syncMessage = 2;


    pub fn get_syncMessage(&self) -> &SyncMessage {
        self.syncMessage.as_ref().unwrap_or_else(|| <SyncMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncMessage(&mut self) {
        self.syncMessage.clear();
    }

    pub fn has_syncMessage(&self) -> bool {
        self.syncMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncMessage(&mut self, v: SyncMessage) {
        self.syncMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncMessage(&mut self) -> &mut SyncMessage {
        if self.syncMessage.is_none() {
            self.syncMessage.set_default();
        }
        self.syncMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncMessage(&mut self) -> SyncMessage {
        self.syncMessage.take().unwrap_or_else(|| SyncMessage::new())
    }

    // optional .signalservice.CallMessage callMessage = 3;


    pub fn get_callMessage(&self) -> &CallMessage {
        self.callMessage.as_ref().unwrap_or_else(|| <CallMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_callMessage(&mut self) {
        self.callMessage.clear();
    }

    pub fn has_callMessage(&self) -> bool {
        self.callMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callMessage(&mut self, v: CallMessage) {
        self.callMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callMessage(&mut self) -> &mut CallMessage {
        if self.callMessage.is_none() {
            self.callMessage.set_default();
        }
        self.callMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_callMessage(&mut self) -> CallMessage {
        self.callMessage.take().unwrap_or_else(|| CallMessage::new())
    }

    // optional .signalservice.NullMessage nullMessage = 4;


    pub fn get_nullMessage(&self) -> &NullMessage {
        self.nullMessage.as_ref().unwrap_or_else(|| <NullMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nullMessage(&mut self) {
        self.nullMessage.clear();
    }

    pub fn has_nullMessage(&self) -> bool {
        self.nullMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nullMessage(&mut self, v: NullMessage) {
        self.nullMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nullMessage(&mut self) -> &mut NullMessage {
        if self.nullMessage.is_none() {
            self.nullMessage.set_default();
        }
        self.nullMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_nullMessage(&mut self) -> NullMessage {
        self.nullMessage.take().unwrap_or_else(|| NullMessage::new())
    }

    // optional .signalservice.ReceiptMessage receiptMessage = 5;


    pub fn get_receiptMessage(&self) -> &ReceiptMessage {
        self.receiptMessage.as_ref().unwrap_or_else(|| <ReceiptMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_receiptMessage(&mut self) {
        self.receiptMessage.clear();
    }

    pub fn has_receiptMessage(&self) -> bool {
        self.receiptMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiptMessage(&mut self, v: ReceiptMessage) {
        self.receiptMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptMessage(&mut self) -> &mut ReceiptMessage {
        if self.receiptMessage.is_none() {
            self.receiptMessage.set_default();
        }
        self.receiptMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiptMessage(&mut self) -> ReceiptMessage {
        self.receiptMessage.take().unwrap_or_else(|| ReceiptMessage::new())
    }

    // optional .signalservice.TypingMessage typingMessage = 6;


    pub fn get_typingMessage(&self) -> &TypingMessage {
        self.typingMessage.as_ref().unwrap_or_else(|| <TypingMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typingMessage(&mut self) {
        self.typingMessage.clear();
    }

    pub fn has_typingMessage(&self) -> bool {
        self.typingMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typingMessage(&mut self, v: TypingMessage) {
        self.typingMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typingMessage(&mut self) -> &mut TypingMessage {
        if self.typingMessage.is_none() {
            self.typingMessage.set_default();
        }
        self.typingMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_typingMessage(&mut self) -> TypingMessage {
        self.typingMessage.take().unwrap_or_else(|| TypingMessage::new())
    }
}

impl ::protobuf::Message for Content {
    fn is_initialized(&self) -> bool {
        for v in &self.dataMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.callMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nullMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receiptMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.typingMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataMessage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncMessage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.callMessage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nullMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.receiptMessage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typingMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.callMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.receiptMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.typingMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataMessage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncMessage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.callMessage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.receiptMessage.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.typingMessage.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Content {
        Content::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage>>(
                "dataMessage",
                |m: &Content| { &m.dataMessage },
                |m: &mut Content| { &mut m.dataMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage>>(
                "syncMessage",
                |m: &Content| { &m.syncMessage },
                |m: &mut Content| { &mut m.syncMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage>>(
                "callMessage",
                |m: &Content| { &m.callMessage },
                |m: &mut Content| { &mut m.callMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NullMessage>>(
                "nullMessage",
                |m: &Content| { &m.nullMessage },
                |m: &mut Content| { &mut m.nullMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiptMessage>>(
                "receiptMessage",
                |m: &Content| { &m.receiptMessage },
                |m: &mut Content| { &mut m.receiptMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypingMessage>>(
                "typingMessage",
                |m: &Content| { &m.typingMessage },
                |m: &mut Content| { &mut m.typingMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Content>(
                "Content",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Content {
        static instance: ::protobuf::rt::LazyV2<Content> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Content::new)
    }
}

impl ::protobuf::Clear for Content {
    fn clear(&mut self) {
        self.dataMessage.clear();
        self.syncMessage.clear();
        self.callMessage.clear();
        self.nullMessage.clear();
        self.receiptMessage.clear();
        self.typingMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage {
    // message fields
    pub offer: ::protobuf::SingularPtrField<CallMessage_Offer>,
    pub answer: ::protobuf::SingularPtrField<CallMessage_Answer>,
    pub iceUpdate: ::protobuf::RepeatedField<CallMessage_IceUpdate>,
    pub hangup: ::protobuf::SingularPtrField<CallMessage_Hangup>,
    pub busy: ::protobuf::SingularPtrField<CallMessage_Busy>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage {
    fn default() -> &'a CallMessage {
        <CallMessage as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage {
    pub fn new() -> CallMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.CallMessage.Offer offer = 1;


    pub fn get_offer(&self) -> &CallMessage_Offer {
        self.offer.as_ref().unwrap_or_else(|| <CallMessage_Offer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_offer(&mut self) {
        self.offer.clear();
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: CallMessage_Offer) {
        self.offer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut CallMessage_Offer {
        if self.offer.is_none() {
            self.offer.set_default();
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> CallMessage_Offer {
        self.offer.take().unwrap_or_else(|| CallMessage_Offer::new())
    }

    // optional .signalservice.CallMessage.Answer answer = 2;


    pub fn get_answer(&self) -> &CallMessage_Answer {
        self.answer.as_ref().unwrap_or_else(|| <CallMessage_Answer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: CallMessage_Answer) {
        self.answer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut CallMessage_Answer {
        if self.answer.is_none() {
            self.answer.set_default();
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> CallMessage_Answer {
        self.answer.take().unwrap_or_else(|| CallMessage_Answer::new())
    }

    // repeated .signalservice.CallMessage.IceUpdate iceUpdate = 3;


    pub fn get_iceUpdate(&self) -> &[CallMessage_IceUpdate] {
        &self.iceUpdate
    }
    pub fn clear_iceUpdate(&mut self) {
        self.iceUpdate.clear();
    }

    // Param is passed by value, moved
    pub fn set_iceUpdate(&mut self, v: ::protobuf::RepeatedField<CallMessage_IceUpdate>) {
        self.iceUpdate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_iceUpdate(&mut self) -> &mut ::protobuf::RepeatedField<CallMessage_IceUpdate> {
        &mut self.iceUpdate
    }

    // Take field
    pub fn take_iceUpdate(&mut self) -> ::protobuf::RepeatedField<CallMessage_IceUpdate> {
        ::std::mem::replace(&mut self.iceUpdate, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.CallMessage.Hangup hangup = 4;


    pub fn get_hangup(&self) -> &CallMessage_Hangup {
        self.hangup.as_ref().unwrap_or_else(|| <CallMessage_Hangup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hangup(&mut self) {
        self.hangup.clear();
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: CallMessage_Hangup) {
        self.hangup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hangup(&mut self) -> &mut CallMessage_Hangup {
        if self.hangup.is_none() {
            self.hangup.set_default();
        }
        self.hangup.as_mut().unwrap()
    }

    // Take field
    pub fn take_hangup(&mut self) -> CallMessage_Hangup {
        self.hangup.take().unwrap_or_else(|| CallMessage_Hangup::new())
    }

    // optional .signalservice.CallMessage.Busy busy = 5;


    pub fn get_busy(&self) -> &CallMessage_Busy {
        self.busy.as_ref().unwrap_or_else(|| <CallMessage_Busy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_busy(&mut self) {
        self.busy.clear();
    }

    pub fn has_busy(&self) -> bool {
        self.busy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy(&mut self, v: CallMessage_Busy) {
        self.busy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_busy(&mut self) -> &mut CallMessage_Busy {
        if self.busy.is_none() {
            self.busy.set_default();
        }
        self.busy.as_mut().unwrap()
    }

    // Take field
    pub fn take_busy(&mut self) -> CallMessage_Busy {
        self.busy.take().unwrap_or_else(|| CallMessage_Busy::new())
    }
}

impl ::protobuf::Message for CallMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.answer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iceUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hangup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.busy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.answer)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.iceUpdate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hangup)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.busy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.answer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.iceUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.hangup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.busy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.answer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.iceUpdate {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.hangup.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.busy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage {
        CallMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Offer>>(
                "offer",
                |m: &CallMessage| { &m.offer },
                |m: &mut CallMessage| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Answer>>(
                "answer",
                |m: &CallMessage| { &m.answer },
                |m: &mut CallMessage| { &mut m.answer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_IceUpdate>>(
                "iceUpdate",
                |m: &CallMessage| { &m.iceUpdate },
                |m: &mut CallMessage| { &mut m.iceUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Hangup>>(
                "hangup",
                |m: &CallMessage| { &m.hangup },
                |m: &mut CallMessage| { &mut m.hangup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Busy>>(
                "busy",
                |m: &CallMessage| { &m.busy },
                |m: &mut CallMessage| { &mut m.busy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage>(
                "CallMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage {
        static instance: ::protobuf::rt::LazyV2<CallMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage::new)
    }
}

impl ::protobuf::Clear for CallMessage {
    fn clear(&mut self) {
        self.offer.clear();
        self.answer.clear();
        self.iceUpdate.clear();
        self.hangup.clear();
        self.busy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Offer {
    // message fields
    id: ::std::option::Option<u64>,
    description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Offer {
    fn default() -> &'a CallMessage_Offer {
        <CallMessage_Offer as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Offer {
    pub fn new() -> CallMessage_Offer {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string description = 2;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CallMessage_Offer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Offer {
        CallMessage_Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Offer| { &m.id },
                |m: &mut CallMessage_Offer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CallMessage_Offer| { &m.description },
                |m: &mut CallMessage_Offer| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Offer>(
                "CallMessage.Offer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Offer {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Offer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Offer::new)
    }
}

impl ::protobuf::Clear for CallMessage_Offer {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Answer {
    // message fields
    id: ::std::option::Option<u64>,
    description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Answer {
    fn default() -> &'a CallMessage_Answer {
        <CallMessage_Answer as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Answer {
    pub fn new() -> CallMessage_Answer {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string description = 2;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CallMessage_Answer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Answer {
        CallMessage_Answer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Answer| { &m.id },
                |m: &mut CallMessage_Answer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CallMessage_Answer| { &m.description },
                |m: &mut CallMessage_Answer| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Answer>(
                "CallMessage.Answer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Answer {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Answer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Answer::new)
    }
}

impl ::protobuf::Clear for CallMessage_Answer {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Answer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Answer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_IceUpdate {
    // message fields
    id: ::std::option::Option<u64>,
    sdpMid: ::protobuf::SingularField<::std::string::String>,
    sdpMLineIndex: ::std::option::Option<u32>,
    sdp: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_IceUpdate {
    fn default() -> &'a CallMessage_IceUpdate {
        <CallMessage_IceUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_IceUpdate {
    pub fn new() -> CallMessage_IceUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string sdpMid = 2;


    pub fn get_sdpMid(&self) -> &str {
        match self.sdpMid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdpMid(&mut self) {
        self.sdpMid.clear();
    }

    pub fn has_sdpMid(&self) -> bool {
        self.sdpMid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdpMid(&mut self, v: ::std::string::String) {
        self.sdpMid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdpMid(&mut self) -> &mut ::std::string::String {
        if self.sdpMid.is_none() {
            self.sdpMid.set_default();
        }
        self.sdpMid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdpMid(&mut self) -> ::std::string::String {
        self.sdpMid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 sdpMLineIndex = 3;


    pub fn get_sdpMLineIndex(&self) -> u32 {
        self.sdpMLineIndex.unwrap_or(0)
    }
    pub fn clear_sdpMLineIndex(&mut self) {
        self.sdpMLineIndex = ::std::option::Option::None;
    }

    pub fn has_sdpMLineIndex(&self) -> bool {
        self.sdpMLineIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdpMLineIndex(&mut self, v: u32) {
        self.sdpMLineIndex = ::std::option::Option::Some(v);
    }

    // optional string sdp = 4;


    pub fn get_sdp(&self) -> &str {
        match self.sdp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    pub fn has_sdp(&self) -> bool {
        self.sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        if self.sdp.is_none() {
            self.sdp.set_default();
        }
        self.sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        self.sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CallMessage_IceUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdpMid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sdpMLineIndex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sdpMid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdpMLineIndex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.sdpMid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.sdpMLineIndex {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sdp.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_IceUpdate {
        CallMessage_IceUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_IceUpdate| { &m.id },
                |m: &mut CallMessage_IceUpdate| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdpMid",
                |m: &CallMessage_IceUpdate| { &m.sdpMid },
                |m: &mut CallMessage_IceUpdate| { &mut m.sdpMid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sdpMLineIndex",
                |m: &CallMessage_IceUpdate| { &m.sdpMLineIndex },
                |m: &mut CallMessage_IceUpdate| { &mut m.sdpMLineIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &CallMessage_IceUpdate| { &m.sdp },
                |m: &mut CallMessage_IceUpdate| { &mut m.sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_IceUpdate>(
                "CallMessage.IceUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_IceUpdate {
        static instance: ::protobuf::rt::LazyV2<CallMessage_IceUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_IceUpdate::new)
    }
}

impl ::protobuf::Clear for CallMessage_IceUpdate {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.sdpMid.clear();
        self.sdpMLineIndex = ::std::option::Option::None;
        self.sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_IceUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_IceUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Busy {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Busy {
    fn default() -> &'a CallMessage_Busy {
        <CallMessage_Busy as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Busy {
    pub fn new() -> CallMessage_Busy {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CallMessage_Busy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Busy {
        CallMessage_Busy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Busy| { &m.id },
                |m: &mut CallMessage_Busy| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Busy>(
                "CallMessage.Busy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Busy {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Busy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Busy::new)
    }
}

impl ::protobuf::Clear for CallMessage_Busy {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Busy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Busy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Hangup {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Hangup {
    fn default() -> &'a CallMessage_Hangup {
        <CallMessage_Hangup as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Hangup {
    pub fn new() -> CallMessage_Hangup {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CallMessage_Hangup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Hangup {
        CallMessage_Hangup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Hangup| { &m.id },
                |m: &mut CallMessage_Hangup| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Hangup>(
                "CallMessage.Hangup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Hangup {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Hangup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Hangup::new)
    }
}

impl ::protobuf::Clear for CallMessage_Hangup {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Hangup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Hangup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage {
    // message fields
    body: ::protobuf::SingularField<::std::string::String>,
    pub attachments: ::protobuf::RepeatedField<AttachmentPointer>,
    pub group: ::protobuf::SingularPtrField<GroupContext>,
    flags: ::std::option::Option<u32>,
    expireTimer: ::std::option::Option<u32>,
    profileKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timestamp: ::std::option::Option<u64>,
    pub quote: ::protobuf::SingularPtrField<DataMessage_Quote>,
    pub contact: ::protobuf::RepeatedField<DataMessage_Contact>,
    pub preview: ::protobuf::RepeatedField<DataMessage_Preview>,
    pub sticker: ::protobuf::SingularPtrField<DataMessage_Sticker>,
    requiredProtocolVersion: ::std::option::Option<u32>,
    isViewOnce: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage {
    fn default() -> &'a DataMessage {
        <DataMessage as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage {
    pub fn new() -> DataMessage {
        ::std::default::Default::default()
    }

    // optional string body = 1;


    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .signalservice.AttachmentPointer attachments = 2;


    pub fn get_attachments(&self) -> &[AttachmentPointer] {
        &self.attachments
    }
    pub fn clear_attachments(&mut self) {
        self.attachments.clear();
    }

    // Param is passed by value, moved
    pub fn set_attachments(&mut self, v: ::protobuf::RepeatedField<AttachmentPointer>) {
        self.attachments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attachments(&mut self) -> &mut ::protobuf::RepeatedField<AttachmentPointer> {
        &mut self.attachments
    }

    // Take field
    pub fn take_attachments(&mut self) -> ::protobuf::RepeatedField<AttachmentPointer> {
        ::std::mem::replace(&mut self.attachments, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.GroupContext group = 3;


    pub fn get_group(&self) -> &GroupContext {
        self.group.as_ref().unwrap_or_else(|| <GroupContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: GroupContext) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut GroupContext {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> GroupContext {
        self.group.take().unwrap_or_else(|| GroupContext::new())
    }

    // optional uint32 flags = 4;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 5;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }

    // optional bytes profileKey = 6;


    pub fn get_profileKey(&self) -> &[u8] {
        match self.profileKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    pub fn has_profileKey(&self) -> bool {
        self.profileKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.profileKey.is_none() {
            self.profileKey.set_default();
        }
        self.profileKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        self.profileKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 timestamp = 7;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.DataMessage.Quote quote = 8;


    pub fn get_quote(&self) -> &DataMessage_Quote {
        self.quote.as_ref().unwrap_or_else(|| <DataMessage_Quote as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: DataMessage_Quote) {
        self.quote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut DataMessage_Quote {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> DataMessage_Quote {
        self.quote.take().unwrap_or_else(|| DataMessage_Quote::new())
    }

    // repeated .signalservice.DataMessage.Contact contact = 9;


    pub fn get_contact(&self) -> &[DataMessage_Contact] {
        &self.contact
    }
    pub fn clear_contact(&mut self) {
        self.contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact>) {
        self.contact = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contact(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact> {
        &mut self.contact
    }

    // Take field
    pub fn take_contact(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact> {
        ::std::mem::replace(&mut self.contact, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Preview preview = 10;


    pub fn get_preview(&self) -> &[DataMessage_Preview] {
        &self.preview
    }
    pub fn clear_preview(&mut self) {
        self.preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_preview(&mut self, v: ::protobuf::RepeatedField<DataMessage_Preview>) {
        self.preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preview(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Preview> {
        &mut self.preview
    }

    // Take field
    pub fn take_preview(&mut self) -> ::protobuf::RepeatedField<DataMessage_Preview> {
        ::std::mem::replace(&mut self.preview, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.DataMessage.Sticker sticker = 11;


    pub fn get_sticker(&self) -> &DataMessage_Sticker {
        self.sticker.as_ref().unwrap_or_else(|| <DataMessage_Sticker as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sticker(&mut self) {
        self.sticker.clear();
    }

    pub fn has_sticker(&self) -> bool {
        self.sticker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker(&mut self, v: DataMessage_Sticker) {
        self.sticker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sticker(&mut self) -> &mut DataMessage_Sticker {
        if self.sticker.is_none() {
            self.sticker.set_default();
        }
        self.sticker.as_mut().unwrap()
    }

    // Take field
    pub fn take_sticker(&mut self) -> DataMessage_Sticker {
        self.sticker.take().unwrap_or_else(|| DataMessage_Sticker::new())
    }

    // optional uint32 requiredProtocolVersion = 12;


    pub fn get_requiredProtocolVersion(&self) -> u32 {
        self.requiredProtocolVersion.unwrap_or(0)
    }
    pub fn clear_requiredProtocolVersion(&mut self) {
        self.requiredProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_requiredProtocolVersion(&self) -> bool {
        self.requiredProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requiredProtocolVersion(&mut self, v: u32) {
        self.requiredProtocolVersion = ::std::option::Option::Some(v);
    }

    // optional bool isViewOnce = 14;


    pub fn get_isViewOnce(&self) -> bool {
        self.isViewOnce.unwrap_or(false)
    }
    pub fn clear_isViewOnce(&mut self) {
        self.isViewOnce = ::std::option::Option::None;
    }

    pub fn has_isViewOnce(&self) -> bool {
        self.isViewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isViewOnce(&mut self, v: bool) {
        self.isViewOnce = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.attachments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quote {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contact {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sticker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attachments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contact)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preview)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sticker)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requiredProtocolVersion = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isViewOnce = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.contact {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sticker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requiredProtocolVersion {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isViewOnce {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.attachments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(7, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.contact {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preview {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sticker.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.requiredProtocolVersion {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.isViewOnce {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage {
        DataMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &DataMessage| { &m.body },
                |m: &mut DataMessage| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "attachments",
                |m: &DataMessage| { &m.attachments },
                |m: &mut DataMessage| { &mut m.attachments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupContext>>(
                "group",
                |m: &DataMessage| { &m.group },
                |m: &mut DataMessage| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &DataMessage| { &m.flags },
                |m: &mut DataMessage| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &DataMessage| { &m.expireTimer },
                |m: &mut DataMessage| { &mut m.expireTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &DataMessage| { &m.profileKey },
                |m: &mut DataMessage| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &DataMessage| { &m.timestamp },
                |m: &mut DataMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Quote>>(
                "quote",
                |m: &DataMessage| { &m.quote },
                |m: &mut DataMessage| { &mut m.quote },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact>>(
                "contact",
                |m: &DataMessage| { &m.contact },
                |m: &mut DataMessage| { &mut m.contact },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Preview>>(
                "preview",
                |m: &DataMessage| { &m.preview },
                |m: &mut DataMessage| { &mut m.preview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Sticker>>(
                "sticker",
                |m: &DataMessage| { &m.sticker },
                |m: &mut DataMessage| { &mut m.sticker },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "requiredProtocolVersion",
                |m: &DataMessage| { &m.requiredProtocolVersion },
                |m: &mut DataMessage| { &mut m.requiredProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isViewOnce",
                |m: &DataMessage| { &m.isViewOnce },
                |m: &mut DataMessage| { &mut m.isViewOnce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage>(
                "DataMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage {
        static instance: ::protobuf::rt::LazyV2<DataMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage::new)
    }
}

impl ::protobuf::Clear for DataMessage {
    fn clear(&mut self) {
        self.body.clear();
        self.attachments.clear();
        self.group.clear();
        self.flags = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.profileKey.clear();
        self.timestamp = ::std::option::Option::None;
        self.quote.clear();
        self.contact.clear();
        self.preview.clear();
        self.sticker.clear();
        self.requiredProtocolVersion = ::std::option::Option::None;
        self.isViewOnce = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Quote {
    // message fields
    id: ::std::option::Option<u64>,
    authorE164: ::protobuf::SingularField<::std::string::String>,
    authorUuid: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    pub attachments: ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Quote {
    fn default() -> &'a DataMessage_Quote {
        <DataMessage_Quote as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Quote {
    pub fn new() -> DataMessage_Quote {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string authorE164 = 2;


    pub fn get_authorE164(&self) -> &str {
        match self.authorE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_authorE164(&mut self) {
        self.authorE164.clear();
    }

    pub fn has_authorE164(&self) -> bool {
        self.authorE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorE164(&mut self, v: ::std::string::String) {
        self.authorE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorE164(&mut self) -> &mut ::std::string::String {
        if self.authorE164.is_none() {
            self.authorE164.set_default();
        }
        self.authorE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorE164(&mut self) -> ::std::string::String {
        self.authorE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string authorUuid = 5;


    pub fn get_authorUuid(&self) -> &str {
        match self.authorUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_authorUuid(&mut self) {
        self.authorUuid.clear();
    }

    pub fn has_authorUuid(&self) -> bool {
        self.authorUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorUuid(&mut self, v: ::std::string::String) {
        self.authorUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorUuid(&mut self) -> &mut ::std::string::String {
        if self.authorUuid.is_none() {
            self.authorUuid.set_default();
        }
        self.authorUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorUuid(&mut self) -> ::std::string::String {
        self.authorUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 3;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .signalservice.DataMessage.Quote.QuotedAttachment attachments = 4;


    pub fn get_attachments(&self) -> &[DataMessage_Quote_QuotedAttachment] {
        &self.attachments
    }
    pub fn clear_attachments(&mut self) {
        self.attachments.clear();
    }

    // Param is passed by value, moved
    pub fn set_attachments(&mut self, v: ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment>) {
        self.attachments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attachments(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment> {
        &mut self.attachments
    }

    // Take field
    pub fn take_attachments(&mut self) -> ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment> {
        ::std::mem::replace(&mut self.attachments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DataMessage_Quote {
    fn is_initialized(&self) -> bool {
        for v in &self.attachments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorE164)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorUuid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attachments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.authorE164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.authorUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.authorE164.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.authorUuid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.attachments {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Quote {
        DataMessage_Quote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &DataMessage_Quote| { &m.id },
                |m: &mut DataMessage_Quote| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorE164",
                |m: &DataMessage_Quote| { &m.authorE164 },
                |m: &mut DataMessage_Quote| { &mut m.authorE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorUuid",
                |m: &DataMessage_Quote| { &m.authorUuid },
                |m: &mut DataMessage_Quote| { &mut m.authorUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &DataMessage_Quote| { &m.text },
                |m: &mut DataMessage_Quote| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Quote_QuotedAttachment>>(
                "attachments",
                |m: &DataMessage_Quote| { &m.attachments },
                |m: &mut DataMessage_Quote| { &mut m.attachments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Quote>(
                "DataMessage.Quote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Quote {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Quote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Quote::new)
    }
}

impl ::protobuf::Clear for DataMessage_Quote {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.authorE164.clear();
        self.authorUuid.clear();
        self.text.clear();
        self.attachments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Quote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Quote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Quote_QuotedAttachment {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    fileName: ::protobuf::SingularField<::std::string::String>,
    pub thumbnail: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Quote_QuotedAttachment {
    fn default() -> &'a DataMessage_Quote_QuotedAttachment {
        <DataMessage_Quote_QuotedAttachment as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Quote_QuotedAttachment {
    pub fn new() -> DataMessage_Quote_QuotedAttachment {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fileName = 2;


    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fileName(&mut self) {
        self.fileName.clear();
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName.set_default();
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.AttachmentPointer thumbnail = 3;


    pub fn get_thumbnail(&self) -> &AttachmentPointer {
        self.thumbnail.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_thumbnail(&mut self) {
        self.thumbnail.clear();
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: AttachmentPointer) {
        self.thumbnail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut AttachmentPointer {
        if self.thumbnail.is_none() {
            self.thumbnail.set_default();
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> AttachmentPointer {
        self.thumbnail.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for DataMessage_Quote_QuotedAttachment {
    fn is_initialized(&self) -> bool {
        for v in &self.thumbnail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.thumbnail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fileName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Quote_QuotedAttachment {
        DataMessage_Quote_QuotedAttachment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.contentType },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fileName",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.fileName },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "thumbnail",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.thumbnail },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.thumbnail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Quote_QuotedAttachment>(
                "DataMessage.Quote.QuotedAttachment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Quote_QuotedAttachment {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Quote_QuotedAttachment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Quote_QuotedAttachment::new)
    }
}

impl ::protobuf::Clear for DataMessage_Quote_QuotedAttachment {
    fn clear(&mut self) {
        self.contentType.clear();
        self.fileName.clear();
        self.thumbnail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Quote_QuotedAttachment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Quote_QuotedAttachment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact {
    // message fields
    pub name: ::protobuf::SingularPtrField<DataMessage_Contact_Name>,
    pub number: ::protobuf::RepeatedField<DataMessage_Contact_Phone>,
    pub email: ::protobuf::RepeatedField<DataMessage_Contact_Email>,
    pub address: ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress>,
    pub avatar: ::protobuf::SingularPtrField<DataMessage_Contact_Avatar>,
    organization: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact {
    fn default() -> &'a DataMessage_Contact {
        <DataMessage_Contact as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact {
    pub fn new() -> DataMessage_Contact {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Contact.Name name = 1;


    pub fn get_name(&self) -> &DataMessage_Contact_Name {
        self.name.as_ref().unwrap_or_else(|| <DataMessage_Contact_Name as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: DataMessage_Contact_Name) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut DataMessage_Contact_Name {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> DataMessage_Contact_Name {
        self.name.take().unwrap_or_else(|| DataMessage_Contact_Name::new())
    }

    // repeated .signalservice.DataMessage.Contact.Phone number = 3;


    pub fn get_number(&self) -> &[DataMessage_Contact_Phone] {
        &self.number
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_Phone>) {
        self.number = v;
    }

    // Mutable pointer to the field.
    pub fn mut_number(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_Phone> {
        &mut self.number
    }

    // Take field
    pub fn take_number(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_Phone> {
        ::std::mem::replace(&mut self.number, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Contact.Email email = 4;


    pub fn get_email(&self) -> &[DataMessage_Contact_Email] {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_Email>) {
        self.email = v;
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_Email> {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_Email> {
        ::std::mem::replace(&mut self.email, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Contact.PostalAddress address = 5;


    pub fn get_address(&self) -> &[DataMessage_Contact_PostalAddress] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress> {
        ::std::mem::replace(&mut self.address, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.DataMessage.Contact.Avatar avatar = 6;


    pub fn get_avatar(&self) -> &DataMessage_Contact_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <DataMessage_Contact_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: DataMessage_Contact_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut DataMessage_Contact_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> DataMessage_Contact_Avatar {
        self.avatar.take().unwrap_or_else(|| DataMessage_Contact_Avatar::new())
    }

    // optional string organization = 7;


    pub fn get_organization(&self) -> &str {
        match self.organization.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_organization(&mut self) {
        self.organization.clear();
    }

    pub fn has_organization(&self) -> bool {
        self.organization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_organization(&mut self, v: ::std::string::String) {
        self.organization = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organization(&mut self) -> &mut ::std::string::String {
        if self.organization.is_none() {
            self.organization.set_default();
        }
        self.organization.as_mut().unwrap()
    }

    // Take field
    pub fn take_organization(&mut self) -> ::std::string::String {
        self.organization.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.number {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.email {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.number)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.email)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.organization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.number {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.email {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.address {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.organization.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.number {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.email {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.address {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.organization.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact {
        DataMessage_Contact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Name>>(
                "name",
                |m: &DataMessage_Contact| { &m.name },
                |m: &mut DataMessage_Contact| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Phone>>(
                "number",
                |m: &DataMessage_Contact| { &m.number },
                |m: &mut DataMessage_Contact| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Email>>(
                "email",
                |m: &DataMessage_Contact| { &m.email },
                |m: &mut DataMessage_Contact| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_PostalAddress>>(
                "address",
                |m: &DataMessage_Contact| { &m.address },
                |m: &mut DataMessage_Contact| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Avatar>>(
                "avatar",
                |m: &DataMessage_Contact| { &m.avatar },
                |m: &mut DataMessage_Contact| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organization",
                |m: &DataMessage_Contact| { &m.organization },
                |m: &mut DataMessage_Contact| { &mut m.organization },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact>(
                "DataMessage.Contact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact {
    fn clear(&mut self) {
        self.name.clear();
        self.number.clear();
        self.email.clear();
        self.address.clear();
        self.avatar.clear();
        self.organization.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Name {
    // message fields
    givenName: ::protobuf::SingularField<::std::string::String>,
    familyName: ::protobuf::SingularField<::std::string::String>,
    prefix: ::protobuf::SingularField<::std::string::String>,
    suffix: ::protobuf::SingularField<::std::string::String>,
    middleName: ::protobuf::SingularField<::std::string::String>,
    displayName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Name {
    fn default() -> &'a DataMessage_Contact_Name {
        <DataMessage_Contact_Name as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Name {
    pub fn new() -> DataMessage_Contact_Name {
        ::std::default::Default::default()
    }

    // optional string givenName = 1;


    pub fn get_givenName(&self) -> &str {
        match self.givenName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_givenName(&mut self) {
        self.givenName.clear();
    }

    pub fn has_givenName(&self) -> bool {
        self.givenName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_givenName(&mut self, v: ::std::string::String) {
        self.givenName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_givenName(&mut self) -> &mut ::std::string::String {
        if self.givenName.is_none() {
            self.givenName.set_default();
        }
        self.givenName.as_mut().unwrap()
    }

    // Take field
    pub fn take_givenName(&mut self) -> ::std::string::String {
        self.givenName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string familyName = 2;


    pub fn get_familyName(&self) -> &str {
        match self.familyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_familyName(&mut self) {
        self.familyName.clear();
    }

    pub fn has_familyName(&self) -> bool {
        self.familyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_familyName(&mut self, v: ::std::string::String) {
        self.familyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_familyName(&mut self) -> &mut ::std::string::String {
        if self.familyName.is_none() {
            self.familyName.set_default();
        }
        self.familyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_familyName(&mut self) -> ::std::string::String {
        self.familyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string prefix = 3;


    pub fn get_prefix(&self) -> &str {
        match self.prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if self.prefix.is_none() {
            self.prefix.set_default();
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        self.prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string suffix = 4;


    pub fn get_suffix(&self) -> &str {
        match self.suffix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    pub fn has_suffix(&self) -> bool {
        self.suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        if self.suffix.is_none() {
            self.suffix.set_default();
        }
        self.suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        self.suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string middleName = 5;


    pub fn get_middleName(&self) -> &str {
        match self.middleName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_middleName(&mut self) {
        self.middleName.clear();
    }

    pub fn has_middleName(&self) -> bool {
        self.middleName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_middleName(&mut self, v: ::std::string::String) {
        self.middleName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_middleName(&mut self) -> &mut ::std::string::String {
        if self.middleName.is_none() {
            self.middleName.set_default();
        }
        self.middleName.as_mut().unwrap()
    }

    // Take field
    pub fn take_middleName(&mut self) -> ::std::string::String {
        self.middleName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string displayName = 6;


    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_displayName(&mut self) {
        self.displayName.clear();
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName.set_default();
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Name {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.givenName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.familyName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefix)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suffix)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.middleName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.givenName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.familyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.middleName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.givenName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.familyName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.prefix.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.suffix.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.middleName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.displayName.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Name {
        DataMessage_Contact_Name::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "givenName",
                |m: &DataMessage_Contact_Name| { &m.givenName },
                |m: &mut DataMessage_Contact_Name| { &mut m.givenName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "familyName",
                |m: &DataMessage_Contact_Name| { &m.familyName },
                |m: &mut DataMessage_Contact_Name| { &mut m.familyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &DataMessage_Contact_Name| { &m.prefix },
                |m: &mut DataMessage_Contact_Name| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suffix",
                |m: &DataMessage_Contact_Name| { &m.suffix },
                |m: &mut DataMessage_Contact_Name| { &mut m.suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "middleName",
                |m: &DataMessage_Contact_Name| { &m.middleName },
                |m: &mut DataMessage_Contact_Name| { &mut m.middleName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayName",
                |m: &DataMessage_Contact_Name| { &m.displayName },
                |m: &mut DataMessage_Contact_Name| { &mut m.displayName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Name>(
                "DataMessage.Contact.Name",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Name {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Name> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Name::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Name {
    fn clear(&mut self) {
        self.givenName.clear();
        self.familyName.clear();
        self.prefix.clear();
        self.suffix.clear();
        self.middleName.clear();
        self.displayName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Name {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Name {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Phone {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DataMessage_Contact_Phone_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Phone {
    fn default() -> &'a DataMessage_Contact_Phone {
        <DataMessage_Contact_Phone as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Phone {
    pub fn new() -> DataMessage_Contact_Phone {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.DataMessage.Contact.Phone.Type type = 2;


    pub fn get_field_type(&self) -> DataMessage_Contact_Phone_Type {
        self.field_type.unwrap_or(DataMessage_Contact_Phone_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_Phone_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 3;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Phone {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Phone {
        DataMessage_Contact_Phone::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &DataMessage_Contact_Phone| { &m.value },
                |m: &mut DataMessage_Contact_Phone| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_Phone_Type>>(
                "type",
                |m: &DataMessage_Contact_Phone| { &m.field_type },
                |m: &mut DataMessage_Contact_Phone| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_Phone| { &m.label },
                |m: &mut DataMessage_Contact_Phone| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Phone>(
                "DataMessage.Contact.Phone",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Phone {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Phone> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Phone::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Phone {
    fn clear(&mut self) {
        self.value.clear();
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Phone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Phone {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_Phone_Type {
    HOME = 1,
    MOBILE = 2,
    WORK = 3,
    CUSTOM = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_Phone_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_Phone_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::MOBILE),
            3 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::WORK),
            4 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_Phone_Type] = &[
            DataMessage_Contact_Phone_Type::HOME,
            DataMessage_Contact_Phone_Type::MOBILE,
            DataMessage_Contact_Phone_Type::WORK,
            DataMessage_Contact_Phone_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_Phone_Type>("DataMessage.Contact.Phone.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_Phone_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_Phone_Type {
    fn default() -> Self {
        DataMessage_Contact_Phone_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Phone_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Email {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DataMessage_Contact_Email_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Email {
    fn default() -> &'a DataMessage_Contact_Email {
        <DataMessage_Contact_Email as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Email {
    pub fn new() -> DataMessage_Contact_Email {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.DataMessage.Contact.Email.Type type = 2;


    pub fn get_field_type(&self) -> DataMessage_Contact_Email_Type {
        self.field_type.unwrap_or(DataMessage_Contact_Email_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_Email_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 3;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Email {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Email {
        DataMessage_Contact_Email::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &DataMessage_Contact_Email| { &m.value },
                |m: &mut DataMessage_Contact_Email| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_Email_Type>>(
                "type",
                |m: &DataMessage_Contact_Email| { &m.field_type },
                |m: &mut DataMessage_Contact_Email| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_Email| { &m.label },
                |m: &mut DataMessage_Contact_Email| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Email>(
                "DataMessage.Contact.Email",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Email {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Email> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Email::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Email {
    fn clear(&mut self) {
        self.value.clear();
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Email {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Email {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_Email_Type {
    HOME = 1,
    MOBILE = 2,
    WORK = 3,
    CUSTOM = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_Email_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_Email_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::MOBILE),
            3 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::WORK),
            4 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_Email_Type] = &[
            DataMessage_Contact_Email_Type::HOME,
            DataMessage_Contact_Email_Type::MOBILE,
            DataMessage_Contact_Email_Type::WORK,
            DataMessage_Contact_Email_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_Email_Type>("DataMessage.Contact.Email.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_Email_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_Email_Type {
    fn default() -> Self {
        DataMessage_Contact_Email_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Email_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_PostalAddress {
    // message fields
    field_type: ::std::option::Option<DataMessage_Contact_PostalAddress_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    street: ::protobuf::SingularField<::std::string::String>,
    pobox: ::protobuf::SingularField<::std::string::String>,
    neighborhood: ::protobuf::SingularField<::std::string::String>,
    city: ::protobuf::SingularField<::std::string::String>,
    region: ::protobuf::SingularField<::std::string::String>,
    postcode: ::protobuf::SingularField<::std::string::String>,
    country: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_PostalAddress {
    fn default() -> &'a DataMessage_Contact_PostalAddress {
        <DataMessage_Contact_PostalAddress as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_PostalAddress {
    pub fn new() -> DataMessage_Contact_PostalAddress {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Contact.PostalAddress.Type type = 1;


    pub fn get_field_type(&self) -> DataMessage_Contact_PostalAddress_Type {
        self.field_type.unwrap_or(DataMessage_Contact_PostalAddress_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_PostalAddress_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 2;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string street = 3;


    pub fn get_street(&self) -> &str {
        match self.street.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_street(&mut self) {
        self.street.clear();
    }

    pub fn has_street(&self) -> bool {
        self.street.is_some()
    }

    // Param is passed by value, moved
    pub fn set_street(&mut self, v: ::std::string::String) {
        self.street = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_street(&mut self) -> &mut ::std::string::String {
        if self.street.is_none() {
            self.street.set_default();
        }
        self.street.as_mut().unwrap()
    }

    // Take field
    pub fn take_street(&mut self) -> ::std::string::String {
        self.street.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pobox = 4;


    pub fn get_pobox(&self) -> &str {
        match self.pobox.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pobox(&mut self) {
        self.pobox.clear();
    }

    pub fn has_pobox(&self) -> bool {
        self.pobox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pobox(&mut self, v: ::std::string::String) {
        self.pobox = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pobox(&mut self) -> &mut ::std::string::String {
        if self.pobox.is_none() {
            self.pobox.set_default();
        }
        self.pobox.as_mut().unwrap()
    }

    // Take field
    pub fn take_pobox(&mut self) -> ::std::string::String {
        self.pobox.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string neighborhood = 5;


    pub fn get_neighborhood(&self) -> &str {
        match self.neighborhood.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_neighborhood(&mut self) {
        self.neighborhood.clear();
    }

    pub fn has_neighborhood(&self) -> bool {
        self.neighborhood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neighborhood(&mut self, v: ::std::string::String) {
        self.neighborhood = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighborhood(&mut self) -> &mut ::std::string::String {
        if self.neighborhood.is_none() {
            self.neighborhood.set_default();
        }
        self.neighborhood.as_mut().unwrap()
    }

    // Take field
    pub fn take_neighborhood(&mut self) -> ::std::string::String {
        self.neighborhood.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 6;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city.set_default();
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 7;


    pub fn get_region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;


    pub fn get_postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_postcode(&mut self) {
        self.postcode.clear();
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode.set_default();
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country = 9;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_PostalAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.street)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pobox)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.neighborhood)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.region)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postcode)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.street.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pobox.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.neighborhood.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.postcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.street.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pobox.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.neighborhood.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.region.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.postcode.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_PostalAddress {
        DataMessage_Contact_PostalAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_PostalAddress_Type>>(
                "type",
                |m: &DataMessage_Contact_PostalAddress| { &m.field_type },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_PostalAddress| { &m.label },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "street",
                |m: &DataMessage_Contact_PostalAddress| { &m.street },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.street },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pobox",
                |m: &DataMessage_Contact_PostalAddress| { &m.pobox },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.pobox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "neighborhood",
                |m: &DataMessage_Contact_PostalAddress| { &m.neighborhood },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.neighborhood },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &DataMessage_Contact_PostalAddress| { &m.city },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "region",
                |m: &DataMessage_Contact_PostalAddress| { &m.region },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postcode",
                |m: &DataMessage_Contact_PostalAddress| { &m.postcode },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.postcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &DataMessage_Contact_PostalAddress| { &m.country },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.country },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_PostalAddress>(
                "DataMessage.Contact.PostalAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_PostalAddress {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_PostalAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_PostalAddress::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_PostalAddress {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.street.clear();
        self.pobox.clear();
        self.neighborhood.clear();
        self.city.clear();
        self.region.clear();
        self.postcode.clear();
        self.country.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_PostalAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_PostalAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_PostalAddress_Type {
    HOME = 1,
    WORK = 2,
    CUSTOM = 3,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_PostalAddress_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_PostalAddress_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::WORK),
            3 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_PostalAddress_Type] = &[
            DataMessage_Contact_PostalAddress_Type::HOME,
            DataMessage_Contact_PostalAddress_Type::WORK,
            DataMessage_Contact_PostalAddress_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_PostalAddress_Type>("DataMessage.Contact.PostalAddress.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_PostalAddress_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_PostalAddress_Type {
    fn default() -> Self {
        DataMessage_Contact_PostalAddress_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_PostalAddress_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Avatar {
    // message fields
    pub avatar: ::protobuf::SingularPtrField<AttachmentPointer>,
    isProfile: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Avatar {
    fn default() -> &'a DataMessage_Contact_Avatar {
        <DataMessage_Contact_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Avatar {
    pub fn new() -> DataMessage_Contact_Avatar {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer avatar = 1;


    pub fn get_avatar(&self) -> &AttachmentPointer {
        self.avatar.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: AttachmentPointer) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut AttachmentPointer {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> AttachmentPointer {
        self.avatar.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional bool isProfile = 2;


    pub fn get_isProfile(&self) -> bool {
        self.isProfile.unwrap_or(false)
    }
    pub fn clear_isProfile(&mut self) {
        self.isProfile = ::std::option::Option::None;
    }

    pub fn has_isProfile(&self) -> bool {
        self.isProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isProfile(&mut self, v: bool) {
        self.isProfile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Contact_Avatar {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isProfile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isProfile {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isProfile {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Avatar {
        DataMessage_Contact_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "avatar",
                |m: &DataMessage_Contact_Avatar| { &m.avatar },
                |m: &mut DataMessage_Contact_Avatar| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isProfile",
                |m: &DataMessage_Contact_Avatar| { &m.isProfile },
                |m: &mut DataMessage_Contact_Avatar| { &mut m.isProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Avatar>(
                "DataMessage.Contact.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Avatar {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Avatar::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Avatar {
    fn clear(&mut self) {
        self.avatar.clear();
        self.isProfile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Preview {
    // message fields
    url: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Preview {
    fn default() -> &'a DataMessage_Preview {
        <DataMessage_Preview as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Preview {
    pub fn new() -> DataMessage_Preview {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.AttachmentPointer image = 3;


    pub fn get_image(&self) -> &AttachmentPointer {
        self.image.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: AttachmentPointer) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut AttachmentPointer {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> AttachmentPointer {
        self.image.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for DataMessage_Preview {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Preview {
        DataMessage_Preview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &DataMessage_Preview| { &m.url },
                |m: &mut DataMessage_Preview| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DataMessage_Preview| { &m.title },
                |m: &mut DataMessage_Preview| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "image",
                |m: &DataMessage_Preview| { &m.image },
                |m: &mut DataMessage_Preview| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Preview>(
                "DataMessage.Preview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Preview {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Preview> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Preview::new)
    }
}

impl ::protobuf::Clear for DataMessage_Preview {
    fn clear(&mut self) {
        self.url.clear();
        self.title.clear();
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Preview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Preview {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Sticker {
    // message fields
    packId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    packKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    stickerId: ::std::option::Option<u32>,
    pub data: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Sticker {
    fn default() -> &'a DataMessage_Sticker {
        <DataMessage_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Sticker {
    pub fn new() -> DataMessage_Sticker {
        ::std::default::Default::default()
    }

    // optional bytes packId = 1;


    pub fn get_packId(&self) -> &[u8] {
        match self.packId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packId(&mut self) {
        self.packId.clear();
    }

    pub fn has_packId(&self) -> bool {
        self.packId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packId(&mut self, v: ::std::vec::Vec<u8>) {
        self.packId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packId.is_none() {
            self.packId.set_default();
        }
        self.packId.as_mut().unwrap()
    }

    // Take field
    pub fn take_packId(&mut self) -> ::std::vec::Vec<u8> {
        self.packId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes packKey = 2;


    pub fn get_packKey(&self) -> &[u8] {
        match self.packKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packKey(&mut self) {
        self.packKey.clear();
    }

    pub fn has_packKey(&self) -> bool {
        self.packKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.packKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packKey.is_none() {
            self.packKey.set_default();
        }
        self.packKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_packKey(&mut self) -> ::std::vec::Vec<u8> {
        self.packKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 stickerId = 3;


    pub fn get_stickerId(&self) -> u32 {
        self.stickerId.unwrap_or(0)
    }
    pub fn clear_stickerId(&mut self) {
        self.stickerId = ::std::option::Option::None;
    }

    pub fn has_stickerId(&self) -> bool {
        self.stickerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerId(&mut self, v: u32) {
        self.stickerId = ::std::option::Option::Some(v);
    }

    // optional .signalservice.AttachmentPointer data = 4;


    pub fn get_data(&self) -> &AttachmentPointer {
        self.data.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: AttachmentPointer) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut AttachmentPointer {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> AttachmentPointer {
        self.data.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for DataMessage_Sticker {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packKey)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stickerId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.packKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.stickerId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packId.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.packKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.stickerId {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Sticker {
        DataMessage_Sticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packId",
                |m: &DataMessage_Sticker| { &m.packId },
                |m: &mut DataMessage_Sticker| { &mut m.packId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packKey",
                |m: &DataMessage_Sticker| { &m.packKey },
                |m: &mut DataMessage_Sticker| { &mut m.packKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stickerId",
                |m: &DataMessage_Sticker| { &m.stickerId },
                |m: &mut DataMessage_Sticker| { &mut m.stickerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "data",
                |m: &DataMessage_Sticker| { &m.data },
                |m: &mut DataMessage_Sticker| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Sticker>(
                "DataMessage.Sticker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Sticker {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Sticker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Sticker::new)
    }
}

impl ::protobuf::Clear for DataMessage_Sticker {
    fn clear(&mut self) {
        self.packId.clear();
        self.packKey.clear();
        self.stickerId = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Flags {
    END_SESSION = 1,
    EXPIRATION_TIMER_UPDATE = 2,
    PROFILE_KEY_UPDATE = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Flags> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Flags::END_SESSION),
            2 => ::std::option::Option::Some(DataMessage_Flags::EXPIRATION_TIMER_UPDATE),
            4 => ::std::option::Option::Some(DataMessage_Flags::PROFILE_KEY_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Flags] = &[
            DataMessage_Flags::END_SESSION,
            DataMessage_Flags::EXPIRATION_TIMER_UPDATE,
            DataMessage_Flags::PROFILE_KEY_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Flags>("DataMessage.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Flags {
    fn default() -> Self {
        DataMessage_Flags::END_SESSION
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Eq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_ProtocolVersion {
    INITIAL, // 0
    MESSAGE_TIMERS, // 1
    VIEW_ONCE, // 2
    VIEW_ONCE_VIDEO, // 3
    CURRENT, // 3
}

impl ::std::cmp::PartialEq for DataMessage_ProtocolVersion {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::ProtobufEnum::value(self) == ::protobuf::ProtobufEnum::value(other)
    }
}

impl ::std::hash::Hash for DataMessage_ProtocolVersion {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::ProtobufEnum::value(self))
    }
}

impl ::protobuf::ProtobufEnum for DataMessage_ProtocolVersion {
    fn value(&self) -> i32 {
        match *self {
            DataMessage_ProtocolVersion::INITIAL => 0,
            DataMessage_ProtocolVersion::MESSAGE_TIMERS => 1,
            DataMessage_ProtocolVersion::VIEW_ONCE => 2,
            DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO => 3,
            DataMessage_ProtocolVersion::CURRENT => 3,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_ProtocolVersion> {
        match value {
            0 => ::std::option::Option::Some(DataMessage_ProtocolVersion::INITIAL),
            1 => ::std::option::Option::Some(DataMessage_ProtocolVersion::MESSAGE_TIMERS),
            2 => ::std::option::Option::Some(DataMessage_ProtocolVersion::VIEW_ONCE),
            3 => ::std::option::Option::Some(DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_ProtocolVersion] = &[
            DataMessage_ProtocolVersion::INITIAL,
            DataMessage_ProtocolVersion::MESSAGE_TIMERS,
            DataMessage_ProtocolVersion::VIEW_ONCE,
            DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO,
            DataMessage_ProtocolVersion::CURRENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_ProtocolVersion>("DataMessage.ProtocolVersion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_ProtocolVersion {
}

impl ::std::default::Default for DataMessage_ProtocolVersion {
    fn default() -> Self {
        DataMessage_ProtocolVersion::INITIAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_ProtocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NullMessage {
    // message fields
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NullMessage {
    fn default() -> &'a NullMessage {
        <NullMessage as ::protobuf::Message>::default_instance()
    }
}

impl NullMessage {
    pub fn new() -> NullMessage {
        ::std::default::Default::default()
    }

    // optional bytes padding = 1;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NullMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NullMessage {
        NullMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &NullMessage| { &m.padding },
                |m: &mut NullMessage| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NullMessage>(
                "NullMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NullMessage {
        static instance: ::protobuf::rt::LazyV2<NullMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NullMessage::new)
    }
}

impl ::protobuf::Clear for NullMessage {
    fn clear(&mut self) {
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NullMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NullMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReceiptMessage {
    // message fields
    field_type: ::std::option::Option<ReceiptMessage_Type>,
    pub timestamp: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiptMessage {
    fn default() -> &'a ReceiptMessage {
        <ReceiptMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceiptMessage {
    pub fn new() -> ReceiptMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.ReceiptMessage.Type type = 1;


    pub fn get_field_type(&self) -> ReceiptMessage_Type {
        self.field_type.unwrap_or(ReceiptMessage_Type::DELIVERY)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ReceiptMessage_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> &[u64] {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::vec::Vec<u64>) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.timestamp, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReceiptMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.timestamp {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.timestamp {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiptMessage {
        ReceiptMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReceiptMessage_Type>>(
                "type",
                |m: &ReceiptMessage| { &m.field_type },
                |m: &mut ReceiptMessage| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ReceiptMessage| { &m.timestamp },
                |m: &mut ReceiptMessage| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiptMessage>(
                "ReceiptMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceiptMessage {
        static instance: ::protobuf::rt::LazyV2<ReceiptMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceiptMessage::new)
    }
}

impl ::protobuf::Clear for ReceiptMessage {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiptMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiptMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ReceiptMessage_Type {
    DELIVERY = 0,
    READ = 1,
}

impl ::protobuf::ProtobufEnum for ReceiptMessage_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReceiptMessage_Type> {
        match value {
            0 => ::std::option::Option::Some(ReceiptMessage_Type::DELIVERY),
            1 => ::std::option::Option::Some(ReceiptMessage_Type::READ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReceiptMessage_Type] = &[
            ReceiptMessage_Type::DELIVERY,
            ReceiptMessage_Type::READ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReceiptMessage_Type>("ReceiptMessage.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReceiptMessage_Type {
}

impl ::std::default::Default for ReceiptMessage_Type {
    fn default() -> Self {
        ReceiptMessage_Type::DELIVERY
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiptMessage_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TypingMessage {
    // message fields
    timestamp: ::std::option::Option<u64>,
    action: ::std::option::Option<TypingMessage_Action>,
    groupId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypingMessage {
    fn default() -> &'a TypingMessage {
        <TypingMessage as ::protobuf::Message>::default_instance()
    }
}

impl TypingMessage {
    pub fn new() -> TypingMessage {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.TypingMessage.Action action = 2;


    pub fn get_action(&self) -> TypingMessage_Action {
        self.action.unwrap_or(TypingMessage_Action::STARTED)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: TypingMessage_Action) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional bytes groupId = 3;


    pub fn get_groupId(&self) -> &[u8] {
        match self.groupId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_groupId(&mut self) {
        self.groupId.clear();
    }

    pub fn has_groupId(&self) -> bool {
        self.groupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: ::std::vec::Vec<u8>) {
        self.groupId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.groupId.is_none() {
            self.groupId.set_default();
        }
        self.groupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupId(&mut self) -> ::std::vec::Vec<u8> {
        self.groupId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TypingMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.groupId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.groupId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.groupId.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypingMessage {
        TypingMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &TypingMessage| { &m.timestamp },
                |m: &mut TypingMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypingMessage_Action>>(
                "action",
                |m: &TypingMessage| { &m.action },
                |m: &mut TypingMessage| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupId",
                |m: &TypingMessage| { &m.groupId },
                |m: &mut TypingMessage| { &mut m.groupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TypingMessage>(
                "TypingMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TypingMessage {
        static instance: ::protobuf::rt::LazyV2<TypingMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypingMessage::new)
    }
}

impl ::protobuf::Clear for TypingMessage {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.groupId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypingMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum TypingMessage_Action {
    STARTED = 0,
    STOPPED = 1,
}

impl ::protobuf::ProtobufEnum for TypingMessage_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypingMessage_Action> {
        match value {
            0 => ::std::option::Option::Some(TypingMessage_Action::STARTED),
            1 => ::std::option::Option::Some(TypingMessage_Action::STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypingMessage_Action] = &[
            TypingMessage_Action::STARTED,
            TypingMessage_Action::STOPPED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TypingMessage_Action>("TypingMessage.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TypingMessage_Action {
}

impl ::std::default::Default for TypingMessage_Action {
    fn default() -> Self {
        TypingMessage_Action::STARTED
    }
}

impl ::protobuf::reflect::ProtobufValue for TypingMessage_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Verified {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    identityKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    state: ::std::option::Option<Verified_State>,
    nullMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Verified {
    fn default() -> &'a Verified {
        <Verified as ::protobuf::Message>::default_instance()
    }
}

impl Verified {
    pub fn new() -> Verified {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 5;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes identityKey = 2;


    pub fn get_identityKey(&self) -> &[u8] {
        match self.identityKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_identityKey(&mut self) {
        self.identityKey.clear();
    }

    pub fn has_identityKey(&self) -> bool {
        self.identityKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identityKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.identityKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identityKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identityKey.is_none() {
            self.identityKey.set_default();
        }
        self.identityKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_identityKey(&mut self) -> ::std::vec::Vec<u8> {
        self.identityKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.Verified.State state = 3;


    pub fn get_state(&self) -> Verified_State {
        self.state.unwrap_or(Verified_State::DEFAULT)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Verified_State) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional bytes nullMessage = 4;


    pub fn get_nullMessage(&self) -> &[u8] {
        match self.nullMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nullMessage(&mut self) {
        self.nullMessage.clear();
    }

    pub fn has_nullMessage(&self) -> bool {
        self.nullMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nullMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.nullMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nullMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nullMessage.is_none() {
            self.nullMessage.set_default();
        }
        self.nullMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_nullMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.nullMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Verified {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.identityKey)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nullMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.identityKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.identityKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Verified {
        Verified::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &Verified| { &m.destinationE164 },
                |m: &mut Verified| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &Verified| { &m.destinationUuid },
                |m: &mut Verified| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "identityKey",
                |m: &Verified| { &m.identityKey },
                |m: &mut Verified| { &mut m.identityKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Verified_State>>(
                "state",
                |m: &Verified| { &m.state },
                |m: &mut Verified| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nullMessage",
                |m: &Verified| { &m.nullMessage },
                |m: &mut Verified| { &mut m.nullMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Verified>(
                "Verified",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Verified {
        static instance: ::protobuf::rt::LazyV2<Verified> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Verified::new)
    }
}

impl ::protobuf::Clear for Verified {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.identityKey.clear();
        self.state = ::std::option::Option::None;
        self.nullMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Verified {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Verified {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Verified_State {
    DEFAULT = 0,
    VERIFIED = 1,
    UNVERIFIED = 2,
}

impl ::protobuf::ProtobufEnum for Verified_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Verified_State> {
        match value {
            0 => ::std::option::Option::Some(Verified_State::DEFAULT),
            1 => ::std::option::Option::Some(Verified_State::VERIFIED),
            2 => ::std::option::Option::Some(Verified_State::UNVERIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Verified_State] = &[
            Verified_State::DEFAULT,
            Verified_State::VERIFIED,
            Verified_State::UNVERIFIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Verified_State>("Verified.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Verified_State {
}

impl ::std::default::Default for Verified_State {
    fn default() -> Self {
        Verified_State::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for Verified_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage {
    // message fields
    pub sent: ::protobuf::SingularPtrField<SyncMessage_Sent>,
    pub contacts: ::protobuf::SingularPtrField<SyncMessage_Contacts>,
    pub groups: ::protobuf::SingularPtrField<SyncMessage_Groups>,
    pub request: ::protobuf::SingularPtrField<SyncMessage_Request>,
    pub read: ::protobuf::RepeatedField<SyncMessage_Read>,
    pub blocked: ::protobuf::SingularPtrField<SyncMessage_Blocked>,
    pub verified: ::protobuf::SingularPtrField<Verified>,
    pub configuration: ::protobuf::SingularPtrField<SyncMessage_Configuration>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub stickerPackOperation: ::protobuf::RepeatedField<SyncMessage_StickerPackOperation>,
    pub viewOnceOpen: ::protobuf::SingularPtrField<SyncMessage_ViewOnceOpen>,
    pub fetchLatest: ::protobuf::SingularPtrField<SyncMessage_FetchLatest>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage {
    fn default() -> &'a SyncMessage {
        <SyncMessage as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage {
    pub fn new() -> SyncMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.Sent sent = 1;


    pub fn get_sent(&self) -> &SyncMessage_Sent {
        self.sent.as_ref().unwrap_or_else(|| <SyncMessage_Sent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sent(&mut self) {
        self.sent.clear();
    }

    pub fn has_sent(&self) -> bool {
        self.sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sent(&mut self, v: SyncMessage_Sent) {
        self.sent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sent(&mut self) -> &mut SyncMessage_Sent {
        if self.sent.is_none() {
            self.sent.set_default();
        }
        self.sent.as_mut().unwrap()
    }

    // Take field
    pub fn take_sent(&mut self) -> SyncMessage_Sent {
        self.sent.take().unwrap_or_else(|| SyncMessage_Sent::new())
    }

    // optional .signalservice.SyncMessage.Contacts contacts = 2;


    pub fn get_contacts(&self) -> &SyncMessage_Contacts {
        self.contacts.as_ref().unwrap_or_else(|| <SyncMessage_Contacts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    pub fn has_contacts(&self) -> bool {
        self.contacts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: SyncMessage_Contacts) {
        self.contacts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contacts(&mut self) -> &mut SyncMessage_Contacts {
        if self.contacts.is_none() {
            self.contacts.set_default();
        }
        self.contacts.as_mut().unwrap()
    }

    // Take field
    pub fn take_contacts(&mut self) -> SyncMessage_Contacts {
        self.contacts.take().unwrap_or_else(|| SyncMessage_Contacts::new())
    }

    // optional .signalservice.SyncMessage.Groups groups = 3;


    pub fn get_groups(&self) -> &SyncMessage_Groups {
        self.groups.as_ref().unwrap_or_else(|| <SyncMessage_Groups as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    pub fn has_groups(&self) -> bool {
        self.groups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: SyncMessage_Groups) {
        self.groups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groups(&mut self) -> &mut SyncMessage_Groups {
        if self.groups.is_none() {
            self.groups.set_default();
        }
        self.groups.as_mut().unwrap()
    }

    // Take field
    pub fn take_groups(&mut self) -> SyncMessage_Groups {
        self.groups.take().unwrap_or_else(|| SyncMessage_Groups::new())
    }

    // optional .signalservice.SyncMessage.Request request = 4;


    pub fn get_request(&self) -> &SyncMessage_Request {
        self.request.as_ref().unwrap_or_else(|| <SyncMessage_Request as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: SyncMessage_Request) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut SyncMessage_Request {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> SyncMessage_Request {
        self.request.take().unwrap_or_else(|| SyncMessage_Request::new())
    }

    // repeated .signalservice.SyncMessage.Read read = 5;


    pub fn get_read(&self) -> &[SyncMessage_Read] {
        &self.read
    }
    pub fn clear_read(&mut self) {
        self.read.clear();
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: ::protobuf::RepeatedField<SyncMessage_Read>) {
        self.read = v;
    }

    // Mutable pointer to the field.
    pub fn mut_read(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_Read> {
        &mut self.read
    }

    // Take field
    pub fn take_read(&mut self) -> ::protobuf::RepeatedField<SyncMessage_Read> {
        ::std::mem::replace(&mut self.read, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.SyncMessage.Blocked blocked = 6;


    pub fn get_blocked(&self) -> &SyncMessage_Blocked {
        self.blocked.as_ref().unwrap_or_else(|| <SyncMessage_Blocked as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blocked(&mut self) {
        self.blocked.clear();
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: SyncMessage_Blocked) {
        self.blocked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blocked(&mut self) -> &mut SyncMessage_Blocked {
        if self.blocked.is_none() {
            self.blocked.set_default();
        }
        self.blocked.as_mut().unwrap()
    }

    // Take field
    pub fn take_blocked(&mut self) -> SyncMessage_Blocked {
        self.blocked.take().unwrap_or_else(|| SyncMessage_Blocked::new())
    }

    // optional .signalservice.Verified verified = 7;


    pub fn get_verified(&self) -> &Verified {
        self.verified.as_ref().unwrap_or_else(|| <Verified as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verified(&mut self) {
        self.verified.clear();
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: Verified) {
        self.verified = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verified(&mut self) -> &mut Verified {
        if self.verified.is_none() {
            self.verified.set_default();
        }
        self.verified.as_mut().unwrap()
    }

    // Take field
    pub fn take_verified(&mut self) -> Verified {
        self.verified.take().unwrap_or_else(|| Verified::new())
    }

    // optional .signalservice.SyncMessage.Configuration configuration = 9;


    pub fn get_configuration(&self) -> &SyncMessage_Configuration {
        self.configuration.as_ref().unwrap_or_else(|| <SyncMessage_Configuration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configuration(&mut self) {
        self.configuration.clear();
    }

    pub fn has_configuration(&self) -> bool {
        self.configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration(&mut self, v: SyncMessage_Configuration) {
        self.configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration(&mut self) -> &mut SyncMessage_Configuration {
        if self.configuration.is_none() {
            self.configuration.set_default();
        }
        self.configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration(&mut self) -> SyncMessage_Configuration {
        self.configuration.take().unwrap_or_else(|| SyncMessage_Configuration::new())
    }

    // optional bytes padding = 8;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .signalservice.SyncMessage.StickerPackOperation stickerPackOperation = 10;


    pub fn get_stickerPackOperation(&self) -> &[SyncMessage_StickerPackOperation] {
        &self.stickerPackOperation
    }
    pub fn clear_stickerPackOperation(&mut self) {
        self.stickerPackOperation.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickerPackOperation(&mut self, v: ::protobuf::RepeatedField<SyncMessage_StickerPackOperation>) {
        self.stickerPackOperation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickerPackOperation(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_StickerPackOperation> {
        &mut self.stickerPackOperation
    }

    // Take field
    pub fn take_stickerPackOperation(&mut self) -> ::protobuf::RepeatedField<SyncMessage_StickerPackOperation> {
        ::std::mem::replace(&mut self.stickerPackOperation, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.SyncMessage.ViewOnceOpen viewOnceOpen = 11;


    pub fn get_viewOnceOpen(&self) -> &SyncMessage_ViewOnceOpen {
        self.viewOnceOpen.as_ref().unwrap_or_else(|| <SyncMessage_ViewOnceOpen as ::protobuf::Message>::default_instance())
    }
    pub fn clear_viewOnceOpen(&mut self) {
        self.viewOnceOpen.clear();
    }

    pub fn has_viewOnceOpen(&self) -> bool {
        self.viewOnceOpen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnceOpen(&mut self, v: SyncMessage_ViewOnceOpen) {
        self.viewOnceOpen = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_viewOnceOpen(&mut self) -> &mut SyncMessage_ViewOnceOpen {
        if self.viewOnceOpen.is_none() {
            self.viewOnceOpen.set_default();
        }
        self.viewOnceOpen.as_mut().unwrap()
    }

    // Take field
    pub fn take_viewOnceOpen(&mut self) -> SyncMessage_ViewOnceOpen {
        self.viewOnceOpen.take().unwrap_or_else(|| SyncMessage_ViewOnceOpen::new())
    }

    // optional .signalservice.SyncMessage.FetchLatest fetchLatest = 12;


    pub fn get_fetchLatest(&self) -> &SyncMessage_FetchLatest {
        self.fetchLatest.as_ref().unwrap_or_else(|| <SyncMessage_FetchLatest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fetchLatest(&mut self) {
        self.fetchLatest.clear();
    }

    pub fn has_fetchLatest(&self) -> bool {
        self.fetchLatest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fetchLatest(&mut self, v: SyncMessage_FetchLatest) {
        self.fetchLatest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fetchLatest(&mut self) -> &mut SyncMessage_FetchLatest {
        if self.fetchLatest.is_none() {
            self.fetchLatest.set_default();
        }
        self.fetchLatest.as_mut().unwrap()
    }

    // Take field
    pub fn take_fetchLatest(&mut self) -> SyncMessage_FetchLatest {
        self.fetchLatest.take().unwrap_or_else(|| SyncMessage_FetchLatest::new())
    }
}

impl ::protobuf::Message for SyncMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contacts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blocked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verified {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickerPackOperation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewOnceOpen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fetchLatest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contacts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groups)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.read)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blocked)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verified)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configuration)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stickerPackOperation)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.viewOnceOpen)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fetchLatest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contacts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.groups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.read {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.blocked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.verified.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.stickerPackOperation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.viewOnceOpen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fetchLatest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sent.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contacts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.groups.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.read {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.blocked.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.verified.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(8, &v)?;
        }
        for v in &self.stickerPackOperation {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.viewOnceOpen.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fetchLatest.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage {
        SyncMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Sent>>(
                "sent",
                |m: &SyncMessage| { &m.sent },
                |m: &mut SyncMessage| { &mut m.sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Contacts>>(
                "contacts",
                |m: &SyncMessage| { &m.contacts },
                |m: &mut SyncMessage| { &mut m.contacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Groups>>(
                "groups",
                |m: &SyncMessage| { &m.groups },
                |m: &mut SyncMessage| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Request>>(
                "request",
                |m: &SyncMessage| { &m.request },
                |m: &mut SyncMessage| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Read>>(
                "read",
                |m: &SyncMessage| { &m.read },
                |m: &mut SyncMessage| { &mut m.read },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Blocked>>(
                "blocked",
                |m: &SyncMessage| { &m.blocked },
                |m: &mut SyncMessage| { &mut m.blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Verified>>(
                "verified",
                |m: &SyncMessage| { &m.verified },
                |m: &mut SyncMessage| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Configuration>>(
                "configuration",
                |m: &SyncMessage| { &m.configuration },
                |m: &mut SyncMessage| { &mut m.configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &SyncMessage| { &m.padding },
                |m: &mut SyncMessage| { &mut m.padding },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_StickerPackOperation>>(
                "stickerPackOperation",
                |m: &SyncMessage| { &m.stickerPackOperation },
                |m: &mut SyncMessage| { &mut m.stickerPackOperation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_ViewOnceOpen>>(
                "viewOnceOpen",
                |m: &SyncMessage| { &m.viewOnceOpen },
                |m: &mut SyncMessage| { &mut m.viewOnceOpen },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_FetchLatest>>(
                "fetchLatest",
                |m: &SyncMessage| { &m.fetchLatest },
                |m: &mut SyncMessage| { &mut m.fetchLatest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage>(
                "SyncMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage {
        static instance: ::protobuf::rt::LazyV2<SyncMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage::new)
    }
}

impl ::protobuf::Clear for SyncMessage {
    fn clear(&mut self) {
        self.sent.clear();
        self.contacts.clear();
        self.groups.clear();
        self.request.clear();
        self.read.clear();
        self.blocked.clear();
        self.verified.clear();
        self.configuration.clear();
        self.padding.clear();
        self.stickerPackOperation.clear();
        self.viewOnceOpen.clear();
        self.fetchLatest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Sent {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    pub message: ::protobuf::SingularPtrField<DataMessage>,
    expirationStartTimestamp: ::std::option::Option<u64>,
    pub unidentifiedStatus: ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus>,
    isRecipientUpdate: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Sent {
    fn default() -> &'a SyncMessage_Sent {
        <SyncMessage_Sent as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Sent {
    pub fn new() -> SyncMessage_Sent {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 7;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.DataMessage message = 3;


    pub fn get_message(&self) -> &DataMessage {
        self.message.as_ref().unwrap_or_else(|| <DataMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: DataMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut DataMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> DataMessage {
        self.message.take().unwrap_or_else(|| DataMessage::new())
    }

    // optional uint64 expirationStartTimestamp = 4;


    pub fn get_expirationStartTimestamp(&self) -> u64 {
        self.expirationStartTimestamp.unwrap_or(0)
    }
    pub fn clear_expirationStartTimestamp(&mut self) {
        self.expirationStartTimestamp = ::std::option::Option::None;
    }

    pub fn has_expirationStartTimestamp(&self) -> bool {
        self.expirationStartTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationStartTimestamp(&mut self, v: u64) {
        self.expirationStartTimestamp = ::std::option::Option::Some(v);
    }

    // repeated .signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus unidentifiedStatus = 5;


    pub fn get_unidentifiedStatus(&self) -> &[SyncMessage_Sent_UnidentifiedDeliveryStatus] {
        &self.unidentifiedStatus
    }
    pub fn clear_unidentifiedStatus(&mut self) {
        self.unidentifiedStatus.clear();
    }

    // Param is passed by value, moved
    pub fn set_unidentifiedStatus(&mut self, v: ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus>) {
        self.unidentifiedStatus = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unidentifiedStatus(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus> {
        &mut self.unidentifiedStatus
    }

    // Take field
    pub fn take_unidentifiedStatus(&mut self) -> ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus> {
        ::std::mem::replace(&mut self.unidentifiedStatus, ::protobuf::RepeatedField::new())
    }

    // optional bool isRecipientUpdate = 6;


    pub fn get_isRecipientUpdate(&self) -> bool {
        self.isRecipientUpdate.unwrap_or(false)
    }
    pub fn clear_isRecipientUpdate(&mut self) {
        self.isRecipientUpdate = ::std::option::Option::None;
    }

    pub fn has_isRecipientUpdate(&self) -> bool {
        self.isRecipientUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRecipientUpdate(&mut self, v: bool) {
        self.isRecipientUpdate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Sent {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unidentifiedStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expirationStartTimestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unidentifiedStatus)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRecipientUpdate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.expirationStartTimestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unidentifiedStatus {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.isRecipientUpdate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.expirationStartTimestamp {
            os.write_uint64(4, v)?;
        }
        for v in &self.unidentifiedStatus {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.isRecipientUpdate {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Sent {
        SyncMessage_Sent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &SyncMessage_Sent| { &m.destinationE164 },
                |m: &mut SyncMessage_Sent| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &SyncMessage_Sent| { &m.destinationUuid },
                |m: &mut SyncMessage_Sent| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_Sent| { &m.timestamp },
                |m: &mut SyncMessage_Sent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage>>(
                "message",
                |m: &SyncMessage_Sent| { &m.message },
                |m: &mut SyncMessage_Sent| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expirationStartTimestamp",
                |m: &SyncMessage_Sent| { &m.expirationStartTimestamp },
                |m: &mut SyncMessage_Sent| { &mut m.expirationStartTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Sent_UnidentifiedDeliveryStatus>>(
                "unidentifiedStatus",
                |m: &SyncMessage_Sent| { &m.unidentifiedStatus },
                |m: &mut SyncMessage_Sent| { &mut m.unidentifiedStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isRecipientUpdate",
                |m: &SyncMessage_Sent| { &m.isRecipientUpdate },
                |m: &mut SyncMessage_Sent| { &mut m.isRecipientUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Sent>(
                "SyncMessage.Sent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Sent {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Sent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Sent::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Sent {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.message.clear();
        self.expirationStartTimestamp = ::std::option::Option::None;
        self.unidentifiedStatus.clear();
        self.isRecipientUpdate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Sent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Sent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Sent_UnidentifiedDeliveryStatus {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    unidentified: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn default() -> &'a SyncMessage_Sent_UnidentifiedDeliveryStatus {
        <SyncMessage_Sent_UnidentifiedDeliveryStatus as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Sent_UnidentifiedDeliveryStatus {
    pub fn new() -> SyncMessage_Sent_UnidentifiedDeliveryStatus {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 3;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unidentified = 2;


    pub fn get_unidentified(&self) -> bool {
        self.unidentified.unwrap_or(false)
    }
    pub fn clear_unidentified(&mut self) {
        self.unidentified = ::std::option::Option::None;
    }

    pub fn has_unidentified(&self) -> bool {
        self.unidentified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unidentified(&mut self, v: bool) {
        self.unidentified = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unidentified = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unidentified {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.unidentified {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Sent_UnidentifiedDeliveryStatus {
        SyncMessage_Sent_UnidentifiedDeliveryStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.destinationE164 },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.destinationUuid },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unidentified",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.unidentified },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.unidentified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Sent_UnidentifiedDeliveryStatus>(
                "SyncMessage.Sent.UnidentifiedDeliveryStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Sent_UnidentifiedDeliveryStatus {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Sent_UnidentifiedDeliveryStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Sent_UnidentifiedDeliveryStatus::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.unidentified = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Contacts {
    // message fields
    pub blob: ::protobuf::SingularPtrField<AttachmentPointer>,
    complete: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Contacts {
    fn default() -> &'a SyncMessage_Contacts {
        <SyncMessage_Contacts as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Contacts {
    pub fn new() -> SyncMessage_Contacts {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer blob = 1;


    pub fn get_blob(&self) -> &AttachmentPointer {
        self.blob.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: AttachmentPointer) {
        self.blob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut AttachmentPointer {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> AttachmentPointer {
        self.blob.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional bool complete = 2;


    pub fn get_complete(&self) -> bool {
        self.complete.unwrap_or(false)
    }
    pub fn clear_complete(&mut self) {
        self.complete = ::std::option::Option::None;
    }

    pub fn has_complete(&self) -> bool {
        self.complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete(&mut self, v: bool) {
        self.complete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Contacts {
    fn is_initialized(&self) -> bool {
        for v in &self.blob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blob)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.complete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.complete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blob.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.complete {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Contacts {
        SyncMessage_Contacts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "blob",
                |m: &SyncMessage_Contacts| { &m.blob },
                |m: &mut SyncMessage_Contacts| { &mut m.blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "complete",
                |m: &SyncMessage_Contacts| { &m.complete },
                |m: &mut SyncMessage_Contacts| { &mut m.complete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Contacts>(
                "SyncMessage.Contacts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Contacts {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Contacts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Contacts::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Contacts {
    fn clear(&mut self) {
        self.blob.clear();
        self.complete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Contacts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Contacts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Groups {
    // message fields
    pub blob: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Groups {
    fn default() -> &'a SyncMessage_Groups {
        <SyncMessage_Groups as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Groups {
    pub fn new() -> SyncMessage_Groups {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer blob = 1;


    pub fn get_blob(&self) -> &AttachmentPointer {
        self.blob.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: AttachmentPointer) {
        self.blob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut AttachmentPointer {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> AttachmentPointer {
        self.blob.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for SyncMessage_Groups {
    fn is_initialized(&self) -> bool {
        for v in &self.blob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blob.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Groups {
        SyncMessage_Groups::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "blob",
                |m: &SyncMessage_Groups| { &m.blob },
                |m: &mut SyncMessage_Groups| { &mut m.blob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Groups>(
                "SyncMessage.Groups",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Groups {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Groups> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Groups::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Groups {
    fn clear(&mut self) {
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Groups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Groups {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Blocked {
    // message fields
    pub numbers: ::protobuf::RepeatedField<::std::string::String>,
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    pub groupIds: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Blocked {
    fn default() -> &'a SyncMessage_Blocked {
        <SyncMessage_Blocked as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Blocked {
    pub fn new() -> SyncMessage_Blocked {
        ::std::default::Default::default()
    }

    // repeated string numbers = 1;


    pub fn get_numbers(&self) -> &[::std::string::String] {
        &self.numbers
    }
    pub fn clear_numbers(&mut self) {
        self.numbers.clear();
    }

    // Param is passed by value, moved
    pub fn set_numbers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.numbers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numbers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.numbers
    }

    // Take field
    pub fn take_numbers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.numbers, ::protobuf::RepeatedField::new())
    }

    // repeated string uuids = 3;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes groupIds = 2;


    pub fn get_groupIds(&self) -> &[::std::vec::Vec<u8>] {
        &self.groupIds
    }
    pub fn clear_groupIds(&mut self) {
        self.groupIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_groupIds(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.groupIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groupIds(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.groupIds
    }

    // Take field
    pub fn take_groupIds(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.groupIds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncMessage_Blocked {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.numbers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.groupIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.numbers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.groupIds {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.numbers {
            os.write_string(1, &v)?;
        };
        for v in &self.uuids {
            os.write_string(3, &v)?;
        };
        for v in &self.groupIds {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Blocked {
        SyncMessage_Blocked::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "numbers",
                |m: &SyncMessage_Blocked| { &m.numbers },
                |m: &mut SyncMessage_Blocked| { &mut m.numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &SyncMessage_Blocked| { &m.uuids },
                |m: &mut SyncMessage_Blocked| { &mut m.uuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupIds",
                |m: &SyncMessage_Blocked| { &m.groupIds },
                |m: &mut SyncMessage_Blocked| { &mut m.groupIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Blocked>(
                "SyncMessage.Blocked",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Blocked {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Blocked> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Blocked::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Blocked {
    fn clear(&mut self) {
        self.numbers.clear();
        self.uuids.clear();
        self.groupIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Blocked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Blocked {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Request {
    // message fields
    field_type: ::std::option::Option<SyncMessage_Request_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Request {
    fn default() -> &'a SyncMessage_Request {
        <SyncMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Request {
    pub fn new() -> SyncMessage_Request {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.Request.Type type = 1;


    pub fn get_field_type(&self) -> SyncMessage_Request_Type {
        self.field_type.unwrap_or(SyncMessage_Request_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_Request_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Request {
        SyncMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_Request_Type>>(
                "type",
                |m: &SyncMessage_Request| { &m.field_type },
                |m: &mut SyncMessage_Request| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Request>(
                "SyncMessage.Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Request {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Request::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Request {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_Request_Type {
    UNKNOWN = 0,
    CONTACTS = 1,
    GROUPS = 2,
    BLOCKED = 3,
    CONFIGURATION = 4,
}

impl ::protobuf::ProtobufEnum for SyncMessage_Request_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_Request_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_Request_Type::UNKNOWN),
            1 => ::std::option::Option::Some(SyncMessage_Request_Type::CONTACTS),
            2 => ::std::option::Option::Some(SyncMessage_Request_Type::GROUPS),
            3 => ::std::option::Option::Some(SyncMessage_Request_Type::BLOCKED),
            4 => ::std::option::Option::Some(SyncMessage_Request_Type::CONFIGURATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_Request_Type] = &[
            SyncMessage_Request_Type::UNKNOWN,
            SyncMessage_Request_Type::CONTACTS,
            SyncMessage_Request_Type::GROUPS,
            SyncMessage_Request_Type::BLOCKED,
            SyncMessage_Request_Type::CONFIGURATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_Request_Type>("SyncMessage.Request.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_Request_Type {
}

impl ::std::default::Default for SyncMessage_Request_Type {
    fn default() -> Self {
        SyncMessage_Request_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Request_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Read {
    // message fields
    senderE164: ::protobuf::SingularField<::std::string::String>,
    senderUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Read {
    fn default() -> &'a SyncMessage_Read {
        <SyncMessage_Read as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Read {
    pub fn new() -> SyncMessage_Read {
        ::std::default::Default::default()
    }

    // optional string senderE164 = 1;


    pub fn get_senderE164(&self) -> &str {
        match self.senderE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderE164(&mut self) {
        self.senderE164.clear();
    }

    pub fn has_senderE164(&self) -> bool {
        self.senderE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderE164(&mut self, v: ::std::string::String) {
        self.senderE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderE164(&mut self) -> &mut ::std::string::String {
        if self.senderE164.is_none() {
            self.senderE164.set_default();
        }
        self.senderE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderE164(&mut self) -> ::std::string::String {
        self.senderE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string senderUuid = 3;


    pub fn get_senderUuid(&self) -> &str {
        match self.senderUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderUuid(&mut self) {
        self.senderUuid.clear();
    }

    pub fn has_senderUuid(&self) -> bool {
        self.senderUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderUuid(&mut self, v: ::std::string::String) {
        self.senderUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderUuid(&mut self) -> &mut ::std::string::String {
        if self.senderUuid.is_none() {
            self.senderUuid.set_default();
        }
        self.senderUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderUuid(&mut self) -> ::std::string::String {
        self.senderUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Read {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.senderE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.senderE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Read {
        SyncMessage_Read::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderE164",
                |m: &SyncMessage_Read| { &m.senderE164 },
                |m: &mut SyncMessage_Read| { &mut m.senderE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderUuid",
                |m: &SyncMessage_Read| { &m.senderUuid },
                |m: &mut SyncMessage_Read| { &mut m.senderUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_Read| { &m.timestamp },
                |m: &mut SyncMessage_Read| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Read>(
                "SyncMessage.Read",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Read {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Read> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Read::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Read {
    fn clear(&mut self) {
        self.senderE164.clear();
        self.senderUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Read {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Read {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Configuration {
    // message fields
    readReceipts: ::std::option::Option<bool>,
    unidentifiedDeliveryIndicators: ::std::option::Option<bool>,
    typingIndicators: ::std::option::Option<bool>,
    linkPreviews: ::std::option::Option<bool>,
    provisioningVersion: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Configuration {
    fn default() -> &'a SyncMessage_Configuration {
        <SyncMessage_Configuration as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Configuration {
    pub fn new() -> SyncMessage_Configuration {
        ::std::default::Default::default()
    }

    // optional bool readReceipts = 1;


    pub fn get_readReceipts(&self) -> bool {
        self.readReceipts.unwrap_or(false)
    }
    pub fn clear_readReceipts(&mut self) {
        self.readReceipts = ::std::option::Option::None;
    }

    pub fn has_readReceipts(&self) -> bool {
        self.readReceipts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readReceipts(&mut self, v: bool) {
        self.readReceipts = ::std::option::Option::Some(v);
    }

    // optional bool unidentifiedDeliveryIndicators = 2;


    pub fn get_unidentifiedDeliveryIndicators(&self) -> bool {
        self.unidentifiedDeliveryIndicators.unwrap_or(false)
    }
    pub fn clear_unidentifiedDeliveryIndicators(&mut self) {
        self.unidentifiedDeliveryIndicators = ::std::option::Option::None;
    }

    pub fn has_unidentifiedDeliveryIndicators(&self) -> bool {
        self.unidentifiedDeliveryIndicators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unidentifiedDeliveryIndicators(&mut self, v: bool) {
        self.unidentifiedDeliveryIndicators = ::std::option::Option::Some(v);
    }

    // optional bool typingIndicators = 3;


    pub fn get_typingIndicators(&self) -> bool {
        self.typingIndicators.unwrap_or(false)
    }
    pub fn clear_typingIndicators(&mut self) {
        self.typingIndicators = ::std::option::Option::None;
    }

    pub fn has_typingIndicators(&self) -> bool {
        self.typingIndicators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typingIndicators(&mut self, v: bool) {
        self.typingIndicators = ::std::option::Option::Some(v);
    }

    // optional bool linkPreviews = 4;


    pub fn get_linkPreviews(&self) -> bool {
        self.linkPreviews.unwrap_or(false)
    }
    pub fn clear_linkPreviews(&mut self) {
        self.linkPreviews = ::std::option::Option::None;
    }

    pub fn has_linkPreviews(&self) -> bool {
        self.linkPreviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linkPreviews(&mut self, v: bool) {
        self.linkPreviews = ::std::option::Option::Some(v);
    }

    // optional uint32 provisioningVersion = 5;


    pub fn get_provisioningVersion(&self) -> u32 {
        self.provisioningVersion.unwrap_or(0)
    }
    pub fn clear_provisioningVersion(&mut self) {
        self.provisioningVersion = ::std::option::Option::None;
    }

    pub fn has_provisioningVersion(&self) -> bool {
        self.provisioningVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provisioningVersion(&mut self, v: u32) {
        self.provisioningVersion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Configuration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readReceipts = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unidentifiedDeliveryIndicators = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.typingIndicators = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.linkPreviews = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.provisioningVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.readReceipts {
            my_size += 2;
        }
        if let Some(v) = self.unidentifiedDeliveryIndicators {
            my_size += 2;
        }
        if let Some(v) = self.typingIndicators {
            my_size += 2;
        }
        if let Some(v) = self.linkPreviews {
            my_size += 2;
        }
        if let Some(v) = self.provisioningVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.readReceipts {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.unidentifiedDeliveryIndicators {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.typingIndicators {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.linkPreviews {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.provisioningVersion {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Configuration {
        SyncMessage_Configuration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readReceipts",
                |m: &SyncMessage_Configuration| { &m.readReceipts },
                |m: &mut SyncMessage_Configuration| { &mut m.readReceipts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unidentifiedDeliveryIndicators",
                |m: &SyncMessage_Configuration| { &m.unidentifiedDeliveryIndicators },
                |m: &mut SyncMessage_Configuration| { &mut m.unidentifiedDeliveryIndicators },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "typingIndicators",
                |m: &SyncMessage_Configuration| { &m.typingIndicators },
                |m: &mut SyncMessage_Configuration| { &mut m.typingIndicators },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "linkPreviews",
                |m: &SyncMessage_Configuration| { &m.linkPreviews },
                |m: &mut SyncMessage_Configuration| { &mut m.linkPreviews },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "provisioningVersion",
                |m: &SyncMessage_Configuration| { &m.provisioningVersion },
                |m: &mut SyncMessage_Configuration| { &mut m.provisioningVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Configuration>(
                "SyncMessage.Configuration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Configuration {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Configuration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Configuration::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Configuration {
    fn clear(&mut self) {
        self.readReceipts = ::std::option::Option::None;
        self.unidentifiedDeliveryIndicators = ::std::option::Option::None;
        self.typingIndicators = ::std::option::Option::None;
        self.linkPreviews = ::std::option::Option::None;
        self.provisioningVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Configuration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_StickerPackOperation {
    // message fields
    packId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    packKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<SyncMessage_StickerPackOperation_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_StickerPackOperation {
    fn default() -> &'a SyncMessage_StickerPackOperation {
        <SyncMessage_StickerPackOperation as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_StickerPackOperation {
    pub fn new() -> SyncMessage_StickerPackOperation {
        ::std::default::Default::default()
    }

    // optional bytes packId = 1;


    pub fn get_packId(&self) -> &[u8] {
        match self.packId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packId(&mut self) {
        self.packId.clear();
    }

    pub fn has_packId(&self) -> bool {
        self.packId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packId(&mut self, v: ::std::vec::Vec<u8>) {
        self.packId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packId.is_none() {
            self.packId.set_default();
        }
        self.packId.as_mut().unwrap()
    }

    // Take field
    pub fn take_packId(&mut self) -> ::std::vec::Vec<u8> {
        self.packId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes packKey = 2;


    pub fn get_packKey(&self) -> &[u8] {
        match self.packKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packKey(&mut self) {
        self.packKey.clear();
    }

    pub fn has_packKey(&self) -> bool {
        self.packKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.packKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packKey.is_none() {
            self.packKey.set_default();
        }
        self.packKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_packKey(&mut self) -> ::std::vec::Vec<u8> {
        self.packKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.SyncMessage.StickerPackOperation.Type type = 3;


    pub fn get_field_type(&self) -> SyncMessage_StickerPackOperation_Type {
        self.field_type.unwrap_or(SyncMessage_StickerPackOperation_Type::INSTALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_StickerPackOperation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_StickerPackOperation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packKey)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.packKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packId.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.packKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_StickerPackOperation {
        SyncMessage_StickerPackOperation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packId",
                |m: &SyncMessage_StickerPackOperation| { &m.packId },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.packId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packKey",
                |m: &SyncMessage_StickerPackOperation| { &m.packKey },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.packKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_StickerPackOperation_Type>>(
                "type",
                |m: &SyncMessage_StickerPackOperation| { &m.field_type },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_StickerPackOperation>(
                "SyncMessage.StickerPackOperation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_StickerPackOperation {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_StickerPackOperation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_StickerPackOperation::new)
    }
}

impl ::protobuf::Clear for SyncMessage_StickerPackOperation {
    fn clear(&mut self) {
        self.packId.clear();
        self.packKey.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_StickerPackOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_StickerPackOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_StickerPackOperation_Type {
    INSTALL = 0,
    REMOVE = 1,
}

impl ::protobuf::ProtobufEnum for SyncMessage_StickerPackOperation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_StickerPackOperation_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_StickerPackOperation_Type::INSTALL),
            1 => ::std::option::Option::Some(SyncMessage_StickerPackOperation_Type::REMOVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_StickerPackOperation_Type] = &[
            SyncMessage_StickerPackOperation_Type::INSTALL,
            SyncMessage_StickerPackOperation_Type::REMOVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_StickerPackOperation_Type>("SyncMessage.StickerPackOperation.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_StickerPackOperation_Type {
}

impl ::std::default::Default for SyncMessage_StickerPackOperation_Type {
    fn default() -> Self {
        SyncMessage_StickerPackOperation_Type::INSTALL
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_StickerPackOperation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_ViewOnceOpen {
    // message fields
    senderE164: ::protobuf::SingularField<::std::string::String>,
    senderUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_ViewOnceOpen {
    fn default() -> &'a SyncMessage_ViewOnceOpen {
        <SyncMessage_ViewOnceOpen as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_ViewOnceOpen {
    pub fn new() -> SyncMessage_ViewOnceOpen {
        ::std::default::Default::default()
    }

    // optional string senderE164 = 1;


    pub fn get_senderE164(&self) -> &str {
        match self.senderE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderE164(&mut self) {
        self.senderE164.clear();
    }

    pub fn has_senderE164(&self) -> bool {
        self.senderE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderE164(&mut self, v: ::std::string::String) {
        self.senderE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderE164(&mut self) -> &mut ::std::string::String {
        if self.senderE164.is_none() {
            self.senderE164.set_default();
        }
        self.senderE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderE164(&mut self) -> ::std::string::String {
        self.senderE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string senderUuid = 3;


    pub fn get_senderUuid(&self) -> &str {
        match self.senderUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderUuid(&mut self) {
        self.senderUuid.clear();
    }

    pub fn has_senderUuid(&self) -> bool {
        self.senderUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderUuid(&mut self, v: ::std::string::String) {
        self.senderUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderUuid(&mut self) -> &mut ::std::string::String {
        if self.senderUuid.is_none() {
            self.senderUuid.set_default();
        }
        self.senderUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderUuid(&mut self) -> ::std::string::String {
        self.senderUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_ViewOnceOpen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.senderE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.senderE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_ViewOnceOpen {
        SyncMessage_ViewOnceOpen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderE164",
                |m: &SyncMessage_ViewOnceOpen| { &m.senderE164 },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.senderE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderUuid",
                |m: &SyncMessage_ViewOnceOpen| { &m.senderUuid },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.senderUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_ViewOnceOpen| { &m.timestamp },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_ViewOnceOpen>(
                "SyncMessage.ViewOnceOpen",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_ViewOnceOpen {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_ViewOnceOpen> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_ViewOnceOpen::new)
    }
}

impl ::protobuf::Clear for SyncMessage_ViewOnceOpen {
    fn clear(&mut self) {
        self.senderE164.clear();
        self.senderUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_ViewOnceOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_ViewOnceOpen {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_FetchLatest {
    // message fields
    field_type: ::std::option::Option<SyncMessage_FetchLatest_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_FetchLatest {
    fn default() -> &'a SyncMessage_FetchLatest {
        <SyncMessage_FetchLatest as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_FetchLatest {
    pub fn new() -> SyncMessage_FetchLatest {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.FetchLatest.Type type = 1;


    pub fn get_field_type(&self) -> SyncMessage_FetchLatest_Type {
        self.field_type.unwrap_or(SyncMessage_FetchLatest_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_FetchLatest_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_FetchLatest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_FetchLatest {
        SyncMessage_FetchLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_FetchLatest_Type>>(
                "type",
                |m: &SyncMessage_FetchLatest| { &m.field_type },
                |m: &mut SyncMessage_FetchLatest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_FetchLatest>(
                "SyncMessage.FetchLatest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_FetchLatest {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_FetchLatest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_FetchLatest::new)
    }
}

impl ::protobuf::Clear for SyncMessage_FetchLatest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_FetchLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_FetchLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_FetchLatest_Type {
    UNKNOWN = 0,
    LOCAL_PROFILE = 1,
    STORAGE_MANIFEST = 2,
}

impl ::protobuf::ProtobufEnum for SyncMessage_FetchLatest_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_FetchLatest_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::UNKNOWN),
            1 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::LOCAL_PROFILE),
            2 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::STORAGE_MANIFEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_FetchLatest_Type] = &[
            SyncMessage_FetchLatest_Type::UNKNOWN,
            SyncMessage_FetchLatest_Type::LOCAL_PROFILE,
            SyncMessage_FetchLatest_Type::STORAGE_MANIFEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_FetchLatest_Type>("SyncMessage.FetchLatest.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_FetchLatest_Type {
}

impl ::std::default::Default for SyncMessage_FetchLatest_Type {
    fn default() -> Self {
        SyncMessage_FetchLatest_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_FetchLatest_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AttachmentPointer {
    // message fields
    id: ::std::option::Option<u64>,
    contentType: ::protobuf::SingularField<::std::string::String>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    size: ::std::option::Option<u32>,
    thumbnail: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    digest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fileName: ::protobuf::SingularField<::std::string::String>,
    flags: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    caption: ::protobuf::SingularField<::std::string::String>,
    blurHash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachmentPointer {
    fn default() -> &'a AttachmentPointer {
        <AttachmentPointer as ::protobuf::Message>::default_instance()
    }
}

impl AttachmentPointer {
    pub fn new() -> AttachmentPointer {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string contentType = 2;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 size = 4;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional bytes thumbnail = 5;


    pub fn get_thumbnail(&self) -> &[u8] {
        match self.thumbnail.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_thumbnail(&mut self) {
        self.thumbnail.clear();
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail.is_none() {
            self.thumbnail.set_default();
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes digest = 6;


    pub fn get_digest(&self) -> &[u8] {
        match self.digest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    pub fn has_digest(&self) -> bool {
        self.digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.digest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.digest.is_none() {
            self.digest.set_default();
        }
        self.digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::vec::Vec<u8> {
        self.digest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string fileName = 7;


    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fileName(&mut self) {
        self.fileName.clear();
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName.set_default();
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flags = 8;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 9;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 10;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional string caption = 11;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string blurHash = 12;


    pub fn get_blurHash(&self) -> &str {
        match self.blurHash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blurHash(&mut self) {
        self.blurHash.clear();
    }

    pub fn has_blurHash(&self) -> bool {
        self.blurHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blurHash(&mut self, v: ::std::string::String) {
        self.blurHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blurHash(&mut self) -> &mut ::std::string::String {
        if self.blurHash.is_none() {
            self.blurHash.set_default();
        }
        self.blurHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_blurHash(&mut self) -> ::std::string::String {
        self.blurHash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttachmentPointer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.thumbnail)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.digest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blurHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 9;
        }
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.blurHash.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.digest.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.fileName.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.blurHash.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachmentPointer {
        AttachmentPointer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "id",
                |m: &AttachmentPointer| { &m.id },
                |m: &mut AttachmentPointer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &AttachmentPointer| { &m.contentType },
                |m: &mut AttachmentPointer| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &AttachmentPointer| { &m.key },
                |m: &mut AttachmentPointer| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &AttachmentPointer| { &m.size },
                |m: &mut AttachmentPointer| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "thumbnail",
                |m: &AttachmentPointer| { &m.thumbnail },
                |m: &mut AttachmentPointer| { &mut m.thumbnail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "digest",
                |m: &AttachmentPointer| { &m.digest },
                |m: &mut AttachmentPointer| { &mut m.digest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fileName",
                |m: &AttachmentPointer| { &m.fileName },
                |m: &mut AttachmentPointer| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &AttachmentPointer| { &m.flags },
                |m: &mut AttachmentPointer| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &AttachmentPointer| { &m.width },
                |m: &mut AttachmentPointer| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &AttachmentPointer| { &m.height },
                |m: &mut AttachmentPointer| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &AttachmentPointer| { &m.caption },
                |m: &mut AttachmentPointer| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blurHash",
                |m: &AttachmentPointer| { &m.blurHash },
                |m: &mut AttachmentPointer| { &mut m.blurHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachmentPointer>(
                "AttachmentPointer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachmentPointer {
        static instance: ::protobuf::rt::LazyV2<AttachmentPointer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachmentPointer::new)
    }
}

impl ::protobuf::Clear for AttachmentPointer {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.contentType.clear();
        self.key.clear();
        self.size = ::std::option::Option::None;
        self.thumbnail.clear();
        self.digest.clear();
        self.fileName.clear();
        self.flags = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.caption.clear();
        self.blurHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachmentPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachmentPointer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AttachmentPointer_Flags {
    VOICE_MESSAGE = 1,
}

impl ::protobuf::ProtobufEnum for AttachmentPointer_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttachmentPointer_Flags> {
        match value {
            1 => ::std::option::Option::Some(AttachmentPointer_Flags::VOICE_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttachmentPointer_Flags] = &[
            AttachmentPointer_Flags::VOICE_MESSAGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AttachmentPointer_Flags>("AttachmentPointer.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AttachmentPointer_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AttachmentPointer_Flags {
    fn default() -> Self {
        AttachmentPointer_Flags::VOICE_MESSAGE
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachmentPointer_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupContext {
    // message fields
    id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<GroupContext_Type>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub membersE164: ::protobuf::RepeatedField<::std::string::String>,
    pub members: ::protobuf::RepeatedField<GroupContext_Member>,
    pub avatar: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupContext {
    fn default() -> &'a GroupContext {
        <GroupContext as ::protobuf::Message>::default_instance()
    }
}

impl GroupContext {
    pub fn new() -> GroupContext {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.GroupContext.Type type = 2;


    pub fn get_field_type(&self) -> GroupContext_Type {
        self.field_type.unwrap_or(GroupContext_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: GroupContext_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string membersE164 = 4;


    pub fn get_membersE164(&self) -> &[::std::string::String] {
        &self.membersE164
    }
    pub fn clear_membersE164(&mut self) {
        self.membersE164.clear();
    }

    // Param is passed by value, moved
    pub fn set_membersE164(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.membersE164 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_membersE164(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.membersE164
    }

    // Take field
    pub fn take_membersE164(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.membersE164, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupContext.Member members = 6;


    pub fn get_members(&self) -> &[GroupContext_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<GroupContext_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<GroupContext_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<GroupContext_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.AttachmentPointer avatar = 5;


    pub fn get_avatar(&self) -> &AttachmentPointer {
        self.avatar.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: AttachmentPointer) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut AttachmentPointer {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> AttachmentPointer {
        self.avatar.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for GroupContext {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.membersE164)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.membersE164 {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.membersE164 {
            os.write_string(4, &v)?;
        };
        for v in &self.members {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupContext {
        GroupContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &GroupContext| { &m.id },
                |m: &mut GroupContext| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GroupContext_Type>>(
                "type",
                |m: &GroupContext| { &m.field_type },
                |m: &mut GroupContext| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GroupContext| { &m.name },
                |m: &mut GroupContext| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "membersE164",
                |m: &GroupContext| { &m.membersE164 },
                |m: &mut GroupContext| { &mut m.membersE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupContext_Member>>(
                "members",
                |m: &GroupContext| { &m.members },
                |m: &mut GroupContext| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "avatar",
                |m: &GroupContext| { &m.avatar },
                |m: &mut GroupContext| { &mut m.avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupContext>(
                "GroupContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupContext {
        static instance: ::protobuf::rt::LazyV2<GroupContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupContext::new)
    }
}

impl ::protobuf::Clear for GroupContext {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = ::std::option::Option::None;
        self.name.clear();
        self.membersE164.clear();
        self.members.clear();
        self.avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupContext_Member {
    // message fields
    uuid: ::protobuf::SingularField<::std::string::String>,
    e164: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupContext_Member {
    fn default() -> &'a GroupContext_Member {
        <GroupContext_Member as ::protobuf::Message>::default_instance()
    }
}

impl GroupContext_Member {
    pub fn new() -> GroupContext_Member {
        ::std::default::Default::default()
    }

    // optional string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string e164 = 2;


    pub fn get_e164(&self) -> &str {
        match self.e164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_e164(&mut self) {
        self.e164.clear();
    }

    pub fn has_e164(&self) -> bool {
        self.e164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e164(&mut self, v: ::std::string::String) {
        self.e164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e164(&mut self) -> &mut ::std::string::String {
        if self.e164.is_none() {
            self.e164.set_default();
        }
        self.e164.as_mut().unwrap()
    }

    // Take field
    pub fn take_e164(&mut self) -> ::std::string::String {
        self.e164.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupContext_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.e164)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.e164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.e164.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupContext_Member {
        GroupContext_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &GroupContext_Member| { &m.uuid },
                |m: &mut GroupContext_Member| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "e164",
                |m: &GroupContext_Member| { &m.e164 },
                |m: &mut GroupContext_Member| { &mut m.e164 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupContext_Member>(
                "GroupContext.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupContext_Member {
        static instance: ::protobuf::rt::LazyV2<GroupContext_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupContext_Member::new)
    }
}

impl ::protobuf::Clear for GroupContext_Member {
    fn clear(&mut self) {
        self.uuid.clear();
        self.e164.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupContext_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum GroupContext_Type {
    UNKNOWN = 0,
    UPDATE = 1,
    DELIVER = 2,
    QUIT = 3,
    REQUEST_INFO = 4,
}

impl ::protobuf::ProtobufEnum for GroupContext_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupContext_Type> {
        match value {
            0 => ::std::option::Option::Some(GroupContext_Type::UNKNOWN),
            1 => ::std::option::Option::Some(GroupContext_Type::UPDATE),
            2 => ::std::option::Option::Some(GroupContext_Type::DELIVER),
            3 => ::std::option::Option::Some(GroupContext_Type::QUIT),
            4 => ::std::option::Option::Some(GroupContext_Type::REQUEST_INFO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupContext_Type] = &[
            GroupContext_Type::UNKNOWN,
            GroupContext_Type::UPDATE,
            GroupContext_Type::DELIVER,
            GroupContext_Type::QUIT,
            GroupContext_Type::REQUEST_INFO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GroupContext_Type>("GroupContext.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GroupContext_Type {
}

impl ::std::default::Default for GroupContext_Type {
    fn default() -> Self {
        GroupContext_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContactDetails {
    // message fields
    number: ::protobuf::SingularField<::std::string::String>,
    uuid: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub avatar: ::protobuf::SingularPtrField<ContactDetails_Avatar>,
    color: ::protobuf::SingularField<::std::string::String>,
    pub verified: ::protobuf::SingularPtrField<Verified>,
    profileKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blocked: ::std::option::Option<bool>,
    expireTimer: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactDetails {
    fn default() -> &'a ContactDetails {
        <ContactDetails as ::protobuf::Message>::default_instance()
    }
}

impl ContactDetails {
    pub fn new() -> ContactDetails {
        ::std::default::Default::default()
    }

    // optional string number = 1;


    pub fn get_number(&self) -> &str {
        match self.number.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::std::string::String) {
        self.number = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_number(&mut self) -> &mut ::std::string::String {
        if self.number.is_none() {
            self.number.set_default();
        }
        self.number.as_mut().unwrap()
    }

    // Take field
    pub fn take_number(&mut self) -> ::std::string::String {
        self.number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uuid = 9;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.ContactDetails.Avatar avatar = 3;


    pub fn get_avatar(&self) -> &ContactDetails_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <ContactDetails_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ContactDetails_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ContactDetails_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> ContactDetails_Avatar {
        self.avatar.take().unwrap_or_else(|| ContactDetails_Avatar::new())
    }

    // optional string color = 4;


    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        self.color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.Verified verified = 5;


    pub fn get_verified(&self) -> &Verified {
        self.verified.as_ref().unwrap_or_else(|| <Verified as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verified(&mut self) {
        self.verified.clear();
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: Verified) {
        self.verified = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verified(&mut self) -> &mut Verified {
        if self.verified.is_none() {
            self.verified.set_default();
        }
        self.verified.as_mut().unwrap()
    }

    // Take field
    pub fn take_verified(&mut self) -> Verified {
        self.verified.take().unwrap_or_else(|| Verified::new())
    }

    // optional bytes profileKey = 6;


    pub fn get_profileKey(&self) -> &[u8] {
        match self.profileKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    pub fn has_profileKey(&self) -> bool {
        self.profileKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.profileKey.is_none() {
            self.profileKey.set_default();
        }
        self.profileKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        self.profileKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool blocked = 7;


    pub fn get_blocked(&self) -> bool {
        self.blocked.unwrap_or(false)
    }
    pub fn clear_blocked(&mut self) {
        self.blocked = ::std::option::Option::None;
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: bool) {
        self.blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 8;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContactDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verified {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.number)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verified)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocked = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.number.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.verified.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.blocked {
            my_size += 2;
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.number.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.verified.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.blocked {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactDetails {
        ContactDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "number",
                |m: &ContactDetails| { &m.number },
                |m: &mut ContactDetails| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &ContactDetails| { &m.uuid },
                |m: &mut ContactDetails| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ContactDetails| { &m.name },
                |m: &mut ContactDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContactDetails_Avatar>>(
                "avatar",
                |m: &ContactDetails| { &m.avatar },
                |m: &mut ContactDetails| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &ContactDetails| { &m.color },
                |m: &mut ContactDetails| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Verified>>(
                "verified",
                |m: &ContactDetails| { &m.verified },
                |m: &mut ContactDetails| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &ContactDetails| { &m.profileKey },
                |m: &mut ContactDetails| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blocked",
                |m: &ContactDetails| { &m.blocked },
                |m: &mut ContactDetails| { &mut m.blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &ContactDetails| { &m.expireTimer },
                |m: &mut ContactDetails| { &mut m.expireTimer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContactDetails>(
                "ContactDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContactDetails {
        static instance: ::protobuf::rt::LazyV2<ContactDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContactDetails::new)
    }
}

impl ::protobuf::Clear for ContactDetails {
    fn clear(&mut self) {
        self.number.clear();
        self.uuid.clear();
        self.name.clear();
        self.avatar.clear();
        self.color.clear();
        self.verified.clear();
        self.profileKey.clear();
        self.blocked = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContactDetails_Avatar {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    length: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactDetails_Avatar {
    fn default() -> &'a ContactDetails_Avatar {
        <ContactDetails_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl ContactDetails_Avatar {
    pub fn new() -> ContactDetails_Avatar {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 length = 2;


    pub fn get_length(&self) -> u32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContactDetails_Avatar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactDetails_Avatar {
        ContactDetails_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &ContactDetails_Avatar| { &m.contentType },
                |m: &mut ContactDetails_Avatar| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length",
                |m: &ContactDetails_Avatar| { &m.length },
                |m: &mut ContactDetails_Avatar| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContactDetails_Avatar>(
                "ContactDetails.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContactDetails_Avatar {
        static instance: ::protobuf::rt::LazyV2<ContactDetails_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContactDetails_Avatar::new)
    }
}

impl ::protobuf::Clear for ContactDetails_Avatar {
    fn clear(&mut self) {
        self.contentType.clear();
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactDetails_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactDetails_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails {
    // message fields
    id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub membersE164: ::protobuf::RepeatedField<::std::string::String>,
    pub members: ::protobuf::RepeatedField<GroupDetails_Member>,
    pub avatar: ::protobuf::SingularPtrField<GroupDetails_Avatar>,
    active: ::std::option::Option<bool>,
    expireTimer: ::std::option::Option<u32>,
    color: ::protobuf::SingularField<::std::string::String>,
    blocked: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails {
    fn default() -> &'a GroupDetails {
        <GroupDetails as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails {
    pub fn new() -> GroupDetails {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string membersE164 = 3;


    pub fn get_membersE164(&self) -> &[::std::string::String] {
        &self.membersE164
    }
    pub fn clear_membersE164(&mut self) {
        self.membersE164.clear();
    }

    // Param is passed by value, moved
    pub fn set_membersE164(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.membersE164 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_membersE164(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.membersE164
    }

    // Take field
    pub fn take_membersE164(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.membersE164, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupDetails.Member members = 9;


    pub fn get_members(&self) -> &[GroupDetails_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<GroupDetails_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<GroupDetails_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<GroupDetails_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.GroupDetails.Avatar avatar = 4;


    pub fn get_avatar(&self) -> &GroupDetails_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <GroupDetails_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: GroupDetails_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut GroupDetails_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> GroupDetails_Avatar {
        self.avatar.take().unwrap_or_else(|| GroupDetails_Avatar::new())
    }

    // optional bool active = 5;


    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(true)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 6;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }

    // optional string color = 7;


    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        self.color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blocked = 8;


    pub fn get_blocked(&self) -> bool {
        self.blocked.unwrap_or(false)
    }
    pub fn clear_blocked(&mut self) {
        self.blocked = ::std::option::Option::None;
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: bool) {
        self.blocked = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GroupDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.membersE164)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.membersE164 {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.active {
            my_size += 2;
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.blocked {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.membersE164 {
            os.write_string(3, &v)?;
        };
        for v in &self.members {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.active {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.blocked {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails {
        GroupDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &GroupDetails| { &m.id },
                |m: &mut GroupDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GroupDetails| { &m.name },
                |m: &mut GroupDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "membersE164",
                |m: &GroupDetails| { &m.membersE164 },
                |m: &mut GroupDetails| { &mut m.membersE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupDetails_Member>>(
                "members",
                |m: &GroupDetails| { &m.members },
                |m: &mut GroupDetails| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupDetails_Avatar>>(
                "avatar",
                |m: &GroupDetails| { &m.avatar },
                |m: &mut GroupDetails| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &GroupDetails| { &m.active },
                |m: &mut GroupDetails| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &GroupDetails| { &m.expireTimer },
                |m: &mut GroupDetails| { &mut m.expireTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &GroupDetails| { &m.color },
                |m: &mut GroupDetails| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blocked",
                |m: &GroupDetails| { &m.blocked },
                |m: &mut GroupDetails| { &mut m.blocked },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails>(
                "GroupDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails {
        static instance: ::protobuf::rt::LazyV2<GroupDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails::new)
    }
}

impl ::protobuf::Clear for GroupDetails {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.membersE164.clear();
        self.members.clear();
        self.avatar.clear();
        self.active = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.color.clear();
        self.blocked = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails_Avatar {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    length: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails_Avatar {
    fn default() -> &'a GroupDetails_Avatar {
        <GroupDetails_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails_Avatar {
    pub fn new() -> GroupDetails_Avatar {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 length = 2;


    pub fn get_length(&self) -> u32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GroupDetails_Avatar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails_Avatar {
        GroupDetails_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &GroupDetails_Avatar| { &m.contentType },
                |m: &mut GroupDetails_Avatar| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length",
                |m: &GroupDetails_Avatar| { &m.length },
                |m: &mut GroupDetails_Avatar| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails_Avatar>(
                "GroupDetails.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails_Avatar {
        static instance: ::protobuf::rt::LazyV2<GroupDetails_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails_Avatar::new)
    }
}

impl ::protobuf::Clear for GroupDetails_Avatar {
    fn clear(&mut self) {
        self.contentType.clear();
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails_Member {
    // message fields
    uuid: ::protobuf::SingularField<::std::string::String>,
    e164: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails_Member {
    fn default() -> &'a GroupDetails_Member {
        <GroupDetails_Member as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails_Member {
    pub fn new() -> GroupDetails_Member {
        ::std::default::Default::default()
    }

    // optional string uuid = 1;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string e164 = 2;


    pub fn get_e164(&self) -> &str {
        match self.e164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_e164(&mut self) {
        self.e164.clear();
    }

    pub fn has_e164(&self) -> bool {
        self.e164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e164(&mut self, v: ::std::string::String) {
        self.e164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e164(&mut self) -> &mut ::std::string::String {
        if self.e164.is_none() {
            self.e164.set_default();
        }
        self.e164.as_mut().unwrap()
    }

    // Take field
    pub fn take_e164(&mut self) -> ::std::string::String {
        self.e164.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupDetails_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.e164)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.e164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.e164.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails_Member {
        GroupDetails_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &GroupDetails_Member| { &m.uuid },
                |m: &mut GroupDetails_Member| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "e164",
                |m: &GroupDetails_Member| { &m.e164 },
                |m: &mut GroupDetails_Member| { &mut m.e164 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails_Member>(
                "GroupDetails.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails_Member {
        static instance: ::protobuf::rt::LazyV2<GroupDetails_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails_Member::new)
    }
}

impl ::protobuf::Clear for GroupDetails_Member {
    fn clear(&mut self) {
        self.uuid.clear();
        self.e164.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13signalservice.proto\x12\rsignalservice\"\xe6\x03\n\x08Envelope\x12\
    2\n\x04type\x18\x01\x20\x01(\x0e2\x1c.signalservice.Envelope.TypeR\x04ty\
    peB\0\x12\x20\n\nsourceE164\x18\x02\x20\x01(\tR\nsourceE164B\0\x12\x20\n\
    \nsourceUuid\x18\x0b\x20\x01(\tR\nsourceUuidB\0\x12$\n\x0csourceDevice\
    \x18\x07\x20\x01(\rR\x0csourceDeviceB\0\x12\x16\n\x05relay\x18\x03\x20\
    \x01(\tR\x05relayB\0\x12\x1e\n\ttimestamp\x18\x05\x20\x01(\x04R\ttimesta\
    mpB\0\x12&\n\rlegacyMessage\x18\x06\x20\x01(\x0cR\rlegacyMessageB\0\x12\
    \x1a\n\x07content\x18\x08\x20\x01(\x0cR\x07contentB\0\x12\x20\n\nserverG\
    uid\x18\t\x20\x01(\tR\nserverGuidB\0\x12*\n\x0fserverTimestamp\x18\n\x20\
    \x01(\x04R\x0fserverTimestampB\0\"p\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\x0e\n\nCIPHERTEXT\x10\x01\x12\x10\n\x0cKEY_EXCHANGE\x10\x02\x12\x11\
    \n\rPREKEY_BUNDLE\x10\x03\x12\x0b\n\x07RECEIPT\x10\x05\x12\x17\n\x13UNID\
    ENTIFIED_SENDER\x10\x06\x1a\0:\0\"\x9a\x03\n\x07Content\x12>\n\x0bdataMe\
    ssage\x18\x01\x20\x01(\x0b2\x1a.signalservice.DataMessageR\x0bdataMessag\
    eB\0\x12>\n\x0bsyncMessage\x18\x02\x20\x01(\x0b2\x1a.signalservice.SyncM\
    essageR\x0bsyncMessageB\0\x12>\n\x0bcallMessage\x18\x03\x20\x01(\x0b2\
    \x1a.signalservice.CallMessageR\x0bcallMessageB\0\x12>\n\x0bnullMessage\
    \x18\x04\x20\x01(\x0b2\x1a.signalservice.NullMessageR\x0bnullMessageB\0\
    \x12G\n\x0ereceiptMessage\x18\x05\x20\x01(\x0b2\x1d.signalservice.Receip\
    tMessageR\x0ereceiptMessageB\0\x12D\n\rtypingMessage\x18\x06\x20\x01(\
    \x0b2\x1c.signalservice.TypingMessageR\rtypingMessageB\0:\0\"\xf4\x04\n\
    \x0bCallMessage\x128\n\x05offer\x18\x01\x20\x01(\x0b2\x20.signalservice.\
    CallMessage.OfferR\x05offerB\0\x12;\n\x06answer\x18\x02\x20\x01(\x0b2!.s\
    ignalservice.CallMessage.AnswerR\x06answerB\0\x12D\n\ticeUpdate\x18\x03\
    \x20\x03(\x0b2$.signalservice.CallMessage.IceUpdateR\ticeUpdateB\0\x12;\
    \n\x06hangup\x18\x04\x20\x01(\x0b2!.signalservice.CallMessage.HangupR\
    \x06hangupB\0\x125\n\x04busy\x18\x05\x20\x01(\x0b2\x1f.signalservice.Cal\
    lMessage.BusyR\x04busyB\0\x1a?\n\x05Offer\x12\x10\n\x02id\x18\x01\x20\
    \x01(\x04R\x02idB\0\x12\"\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescri\
    ptionB\0:\0\x1a@\n\x06Answer\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02id\
    B\0\x12\"\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescriptionB\0:\0\x1au\
    \n\tIceUpdate\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\x12\x18\n\
    \x06sdpMid\x18\x02\x20\x01(\tR\x06sdpMidB\0\x12&\n\rsdpMLineIndex\x18\
    \x03\x20\x01(\rR\rsdpMLineIndexB\0\x12\x12\n\x03sdp\x18\x04\x20\x01(\tR\
    \x03sdpB\0:\0\x1a\x1a\n\x04Busy\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\
    \x02idB\0:\0\x1a\x1c\n\x06Hangup\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\
    \x02idB\0:\0:\0\"\xb7\x16\n\x0bDataMessage\x12\x14\n\x04body\x18\x01\x20\
    \x01(\tR\x04bodyB\0\x12D\n\x0battachments\x18\x02\x20\x03(\x0b2\x20.sign\
    alservice.AttachmentPointerR\x0battachmentsB\0\x123\n\x05group\x18\x03\
    \x20\x01(\x0b2\x1b.signalservice.GroupContextR\x05groupB\0\x12\x16\n\x05\
    flags\x18\x04\x20\x01(\rR\x05flagsB\0\x12\"\n\x0bexpireTimer\x18\x05\x20\
    \x01(\rR\x0bexpireTimerB\0\x12\x20\n\nprofileKey\x18\x06\x20\x01(\x0cR\n\
    profileKeyB\0\x12\x1e\n\ttimestamp\x18\x07\x20\x01(\x04R\ttimestampB\0\
    \x128\n\x05quote\x18\x08\x20\x01(\x0b2\x20.signalservice.DataMessage.Quo\
    teR\x05quoteB\0\x12>\n\x07contact\x18\t\x20\x03(\x0b2\".signalservice.Da\
    taMessage.ContactR\x07contactB\0\x12>\n\x07preview\x18\n\x20\x03(\x0b2\"\
    .signalservice.DataMessage.PreviewR\x07previewB\0\x12>\n\x07sticker\x18\
    \x0b\x20\x01(\x0b2\".signalservice.DataMessage.StickerR\x07stickerB\0\
    \x12:\n\x17requiredProtocolVersion\x18\x0c\x20\x01(\rR\x17requiredProtoc\
    olVersionB\0\x12\x20\n\nisViewOnce\x18\x0e\x20\x01(\x08R\nisViewOnceB\0\
    \x1a\xe7\x02\n\x05Quote\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\
    \x12\x20\n\nauthorE164\x18\x02\x20\x01(\tR\nauthorE164B\0\x12\x20\n\naut\
    horUuid\x18\x05\x20\x01(\tR\nauthorUuidB\0\x12\x14\n\x04text\x18\x03\x20\
    \x01(\tR\x04textB\0\x12U\n\x0battachments\x18\x04\x20\x03(\x0b21.signals\
    ervice.DataMessage.Quote.QuotedAttachmentR\x0battachmentsB\0\x1a\x98\x01\
    \n\x10QuotedAttachment\x12\"\n\x0bcontentType\x18\x01\x20\x01(\tR\x0bcon\
    tentTypeB\0\x12\x1c\n\x08fileName\x18\x02\x20\x01(\tR\x08fileNameB\0\x12\
    @\n\tthumbnail\x18\x03\x20\x01(\x0b2\x20.signalservice.AttachmentPointer\
    R\tthumbnailB\0:\0:\0\x1a\x8b\x0b\n\x07Contact\x12=\n\x04name\x18\x01\
    \x20\x01(\x0b2'.signalservice.DataMessage.Contact.NameR\x04nameB\0\x12B\
    \n\x06number\x18\x03\x20\x03(\x0b2(.signalservice.DataMessage.Contact.Ph\
    oneR\x06numberB\0\x12@\n\x05email\x18\x04\x20\x03(\x0b2(.signalservice.D\
    ataMessage.Contact.EmailR\x05emailB\0\x12L\n\x07address\x18\x05\x20\x03(\
    \x0b20.signalservice.DataMessage.Contact.PostalAddressR\x07addressB\0\
    \x12C\n\x06avatar\x18\x06\x20\x01(\x0b2).signalservice.DataMessage.Conta\
    ct.AvatarR\x06avatarB\0\x12$\n\x0corganization\x18\x07\x20\x01(\tR\x0cor\
    ganizationB\0\x1a\xc4\x01\n\x04Name\x12\x1e\n\tgivenName\x18\x01\x20\x01\
    (\tR\tgivenNameB\0\x12\x20\n\nfamilyName\x18\x02\x20\x01(\tR\nfamilyName\
    B\0\x12\x18\n\x06prefix\x18\x03\x20\x01(\tR\x06prefixB\0\x12\x18\n\x06su\
    ffix\x18\x04\x20\x01(\tR\x06suffixB\0\x12\x20\n\nmiddleName\x18\x05\x20\
    \x01(\tR\nmiddleNameB\0\x12\"\n\x0bdisplayName\x18\x06\x20\x01(\tR\x0bdi\
    splayNameB\0:\0\x1a\xb4\x01\n\x05Phone\x12\x16\n\x05value\x18\x01\x20\
    \x01(\tR\x05valueB\0\x12C\n\x04type\x18\x02\x20\x01(\x0e2-.signalservice\
    .DataMessage.Contact.Phone.TypeR\x04typeB\0\x12\x16\n\x05label\x18\x03\
    \x20\x01(\tR\x05labelB\0\"4\n\x04Type\x12\x08\n\x04HOME\x10\x01\x12\n\n\
    \x06MOBILE\x10\x02\x12\x08\n\x04WORK\x10\x03\x12\n\n\x06CUSTOM\x10\x04\
    \x1a\0:\0\x1a\xb4\x01\n\x05Email\x12\x16\n\x05value\x18\x01\x20\x01(\tR\
    \x05valueB\0\x12C\n\x04type\x18\x02\x20\x01(\x0e2-.signalservice.DataMes\
    sage.Contact.Email.TypeR\x04typeB\0\x12\x16\n\x05label\x18\x03\x20\x01(\
    \tR\x05labelB\0\"4\n\x04Type\x12\x08\n\x04HOME\x10\x01\x12\n\n\x06MOBILE\
    \x10\x02\x12\x08\n\x04WORK\x10\x03\x12\n\n\x06CUSTOM\x10\x04\x1a\0:\0\
    \x1a\xe2\x02\n\rPostalAddress\x12K\n\x04type\x18\x01\x20\x01(\x0e25.sign\
    alservice.DataMessage.Contact.PostalAddress.TypeR\x04typeB\0\x12\x16\n\
    \x05label\x18\x02\x20\x01(\tR\x05labelB\0\x12\x18\n\x06street\x18\x03\
    \x20\x01(\tR\x06streetB\0\x12\x16\n\x05pobox\x18\x04\x20\x01(\tR\x05pobo\
    xB\0\x12$\n\x0cneighborhood\x18\x05\x20\x01(\tR\x0cneighborhoodB\0\x12\
    \x14\n\x04city\x18\x06\x20\x01(\tR\x04cityB\0\x12\x18\n\x06region\x18\
    \x07\x20\x01(\tR\x06regionB\0\x12\x1c\n\x08postcode\x18\x08\x20\x01(\tR\
    \x08postcodeB\0\x12\x1a\n\x07country\x18\t\x20\x01(\tR\x07countryB\0\"(\
    \n\x04Type\x12\x08\n\x04HOME\x10\x01\x12\x08\n\x04WORK\x10\x02\x12\n\n\
    \x06CUSTOM\x10\x03\x1a\0:\0\x1af\n\x06Avatar\x12:\n\x06avatar\x18\x01\
    \x20\x01(\x0b2\x20.signalservice.AttachmentPointerR\x06avatarB\0\x12\x1e\
    \n\tisProfile\x18\x02\x20\x01(\x08R\tisProfileB\0:\0:\0\x1aq\n\x07Previe\
    w\x12\x12\n\x03url\x18\x01\x20\x01(\tR\x03urlB\0\x12\x16\n\x05title\x18\
    \x02\x20\x01(\tR\x05titleB\0\x128\n\x05image\x18\x03\x20\x01(\x0b2\x20.s\
    ignalservice.AttachmentPointerR\x05imageB\0:\0\x1a\x99\x01\n\x07Sticker\
    \x12\x18\n\x06packId\x18\x01\x20\x01(\x0cR\x06packIdB\0\x12\x1a\n\x07pac\
    kKey\x18\x02\x20\x01(\x0cR\x07packKeyB\0\x12\x1e\n\tstickerId\x18\x03\
    \x20\x01(\rR\tstickerIdB\0\x126\n\x04data\x18\x04\x20\x01(\x0b2\x20.sign\
    alservice.AttachmentPointerR\x04dataB\0:\0\"O\n\x05Flags\x12\x0f\n\x0bEN\
    D_SESSION\x10\x01\x12\x1b\n\x17EXPIRATION_TIMER_UPDATE\x10\x02\x12\x16\n\
    \x12PROFILE_KEY_UPDATE\x10\x04\x1a\0\"g\n\x0fProtocolVersion\x12\x0b\n\
    \x07INITIAL\x10\0\x12\x12\n\x0eMESSAGE_TIMERS\x10\x01\x12\r\n\tVIEW_ONCE\
    \x10\x02\x12\x13\n\x0fVIEW_ONCE_VIDEO\x10\x03\x12\x0b\n\x07CURRENT\x10\
    \x03\x1a\x02\x10\x01:\0\"+\n\x0bNullMessage\x12\x1a\n\x07padding\x18\x01\
    \x20\x01(\x0cR\x07paddingB\0:\0\"\x8e\x01\n\x0eReceiptMessage\x128\n\x04\
    type\x18\x01\x20\x01(\x0e2\".signalservice.ReceiptMessage.TypeR\x04typeB\
    \0\x12\x1e\n\ttimestamp\x18\x02\x20\x03(\x04R\ttimestampB\0\"\x20\n\x04T\
    ype\x12\x0c\n\x08DELIVERY\x10\0\x12\x08\n\x04READ\x10\x01\x1a\0:\0\"\xb2\
    \x01\n\rTypingMessage\x12\x1e\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimest\
    ampB\0\x12=\n\x06action\x18\x02\x20\x01(\x0e2#.signalservice.TypingMessa\
    ge.ActionR\x06actionB\0\x12\x1a\n\x07groupId\x18\x03\x20\x01(\x0cR\x07gr\
    oupIdB\0\"$\n\x06Action\x12\x0b\n\x07STARTED\x10\0\x12\x0b\n\x07STOPPED\
    \x10\x01\x1a\0:\0\"\x99\x02\n\x08Verified\x12*\n\x0fdestinationE164\x18\
    \x01\x20\x01(\tR\x0fdestinationE164B\0\x12*\n\x0fdestinationUuid\x18\x05\
    \x20\x01(\tR\x0fdestinationUuidB\0\x12\"\n\x0bidentityKey\x18\x02\x20\
    \x01(\x0cR\x0bidentityKeyB\0\x125\n\x05state\x18\x03\x20\x01(\x0e2\x1d.s\
    ignalservice.Verified.StateR\x05stateB\0\x12\"\n\x0bnullMessage\x18\x04\
    \x20\x01(\x0cR\x0bnullMessageB\0\"4\n\x05State\x12\x0b\n\x07DEFAULT\x10\
    \0\x12\x0c\n\x08VERIFIED\x10\x01\x12\x0e\n\nUNVERIFIED\x10\x02\x1a\0:\0\
    \"\xd2\x14\n\x0bSyncMessage\x125\n\x04sent\x18\x01\x20\x01(\x0b2\x1f.sig\
    nalservice.SyncMessage.SentR\x04sentB\0\x12A\n\x08contacts\x18\x02\x20\
    \x01(\x0b2#.signalservice.SyncMessage.ContactsR\x08contactsB\0\x12;\n\
    \x06groups\x18\x03\x20\x01(\x0b2!.signalservice.SyncMessage.GroupsR\x06g\
    roupsB\0\x12>\n\x07request\x18\x04\x20\x01(\x0b2\".signalservice.SyncMes\
    sage.RequestR\x07requestB\0\x125\n\x04read\x18\x05\x20\x03(\x0b2\x1f.sig\
    nalservice.SyncMessage.ReadR\x04readB\0\x12>\n\x07blocked\x18\x06\x20\
    \x01(\x0b2\".signalservice.SyncMessage.BlockedR\x07blockedB\0\x125\n\x08\
    verified\x18\x07\x20\x01(\x0b2\x17.signalservice.VerifiedR\x08verifiedB\
    \0\x12P\n\rconfiguration\x18\t\x20\x01(\x0b2(.signalservice.SyncMessage.\
    ConfigurationR\rconfigurationB\0\x12\x1a\n\x07padding\x18\x08\x20\x01(\
    \x0cR\x07paddingB\0\x12e\n\x14stickerPackOperation\x18\n\x20\x03(\x0b2/.\
    signalservice.SyncMessage.StickerPackOperationR\x14stickerPackOperationB\
    \0\x12M\n\x0cviewOnceOpen\x18\x0b\x20\x01(\x0b2'.signalservice.SyncMessa\
    ge.ViewOnceOpenR\x0cviewOnceOpenB\0\x12J\n\x0bfetchLatest\x18\x0c\x20\
    \x01(\x0b2&.signalservice.SyncMessage.FetchLatestR\x0bfetchLatestB\0\x1a\
    \xba\x04\n\x04Sent\x12*\n\x0fdestinationE164\x18\x01\x20\x01(\tR\x0fdest\
    inationE164B\0\x12*\n\x0fdestinationUuid\x18\x07\x20\x01(\tR\x0fdestinat\
    ionUuidB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0\x126\
    \n\x07message\x18\x03\x20\x01(\x0b2\x1a.signalservice.DataMessageR\x07me\
    ssageB\0\x12<\n\x18expirationStartTimestamp\x18\x04\x20\x01(\x04R\x18exp\
    irationStartTimestampB\0\x12l\n\x12unidentifiedStatus\x18\x05\x20\x03(\
    \x0b2:.signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatusR\x12uni\
    dentifiedStatusB\0\x125\n\x11isRecipientUpdate\x18\x06\x20\x01(\x08:\x05\
    falseR\x11isRecipientUpdateB\0\x1a\x9c\x01\n\x1aUnidentifiedDeliveryStat\
    us\x12*\n\x0fdestinationE164\x18\x01\x20\x01(\tR\x0fdestinationE164B\0\
    \x12*\n\x0fdestinationUuid\x18\x03\x20\x01(\tR\x0fdestinationUuidB\0\x12\
    $\n\x0cunidentified\x18\x02\x20\x01(\x08R\x0cunidentifiedB\0:\0:\0\x1ai\
    \n\x08Contacts\x126\n\x04blob\x18\x01\x20\x01(\x0b2\x20.signalservice.At\
    tachmentPointerR\x04blobB\0\x12#\n\x08complete\x18\x02\x20\x01(\x08:\x05\
    falseR\x08completeB\0:\0\x1aB\n\x06Groups\x126\n\x04blob\x18\x01\x20\x01\
    (\x0b2\x20.signalservice.AttachmentPointerR\x04blobB\0:\0\x1a]\n\x07Bloc\
    ked\x12\x1a\n\x07numbers\x18\x01\x20\x03(\tR\x07numbersB\0\x12\x16\n\x05\
    uuids\x18\x03\x20\x03(\tR\x05uuidsB\0\x12\x1c\n\x08groupIds\x18\x02\x20\
    \x03(\x0cR\x08groupIdsB\0:\0\x1a\x9b\x01\n\x07Request\x12=\n\x04type\x18\
    \x01\x20\x01(\x0e2'.signalservice.SyncMessage.Request.TypeR\x04typeB\0\"\
    O\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0c\n\x08CONTACTS\x10\x01\x12\
    \n\n\x06GROUPS\x10\x02\x12\x0b\n\x07BLOCKED\x10\x03\x12\x11\n\rCONFIGURA\
    TION\x10\x04\x1a\0:\0\x1al\n\x04Read\x12\x20\n\nsenderE164\x18\x01\x20\
    \x01(\tR\nsenderE164B\0\x12\x20\n\nsenderUuid\x18\x03\x20\x01(\tR\nsende\
    rUuidB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0:\0\x1a\
    \x89\x02\n\rConfiguration\x12$\n\x0creadReceipts\x18\x01\x20\x01(\x08R\
    \x0creadReceiptsB\0\x12H\n\x1eunidentifiedDeliveryIndicators\x18\x02\x20\
    \x01(\x08R\x1eunidentifiedDeliveryIndicatorsB\0\x12,\n\x10typingIndicato\
    rs\x18\x03\x20\x01(\x08R\x10typingIndicatorsB\0\x12$\n\x0clinkPreviews\
    \x18\x04\x20\x01(\x08R\x0clinkPreviewsB\0\x122\n\x13provisioningVersion\
    \x18\x05\x20\x01(\rR\x13provisioningVersionB\0:\0\x1a\xbd\x01\n\x14Stick\
    erPackOperation\x12\x18\n\x06packId\x18\x01\x20\x01(\x0cR\x06packIdB\0\
    \x12\x1a\n\x07packKey\x18\x02\x20\x01(\x0cR\x07packKeyB\0\x12J\n\x04type\
    \x18\x03\x20\x01(\x0e24.signalservice.SyncMessage.StickerPackOperation.T\
    ypeR\x04typeB\0\"!\n\x04Type\x12\x0b\n\x07INSTALL\x10\0\x12\n\n\x06REMOV\
    E\x10\x01\x1a\0:\0\x1at\n\x0cViewOnceOpen\x12\x20\n\nsenderE164\x18\x01\
    \x20\x01(\tR\nsenderE164B\0\x12\x20\n\nsenderUuid\x18\x03\x20\x01(\tR\ns\
    enderUuidB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0:\0\
    \x1a\x92\x01\n\x0bFetchLatest\x12A\n\x04type\x18\x01\x20\x01(\x0e2+.sign\
    alservice.SyncMessage.FetchLatest.TypeR\x04typeB\0\">\n\x04Type\x12\x0b\
    \n\x07UNKNOWN\x10\0\x12\x11\n\rLOCAL_PROFILE\x10\x01\x12\x14\n\x10STORAG\
    E_MANIFEST\x10\x02\x1a\0:\0:\0\"\xef\x02\n\x11AttachmentPointer\x12\x10\
    \n\x02id\x18\x01\x20\x01(\x06R\x02idB\0\x12\"\n\x0bcontentType\x18\x02\
    \x20\x01(\tR\x0bcontentTypeB\0\x12\x12\n\x03key\x18\x03\x20\x01(\x0cR\
    \x03keyB\0\x12\x14\n\x04size\x18\x04\x20\x01(\rR\x04sizeB\0\x12\x1e\n\tt\
    humbnail\x18\x05\x20\x01(\x0cR\tthumbnailB\0\x12\x18\n\x06digest\x18\x06\
    \x20\x01(\x0cR\x06digestB\0\x12\x1c\n\x08fileName\x18\x07\x20\x01(\tR\
    \x08fileNameB\0\x12\x16\n\x05flags\x18\x08\x20\x01(\rR\x05flagsB\0\x12\
    \x16\n\x05width\x18\t\x20\x01(\rR\x05widthB\0\x12\x18\n\x06height\x18\n\
    \x20\x01(\rR\x06heightB\0\x12\x1a\n\x07caption\x18\x0b\x20\x01(\tR\x07ca\
    ptionB\0\x12\x1c\n\x08blurHash\x18\x0c\x20\x01(\tR\x08blurHashB\0\"\x1c\
    \n\x05Flags\x12\x11\n\rVOICE_MESSAGE\x10\x01\x1a\0:\0\"\x94\x03\n\x0cGro\
    upContext\x12\x10\n\x02id\x18\x01\x20\x01(\x0cR\x02idB\0\x126\n\x04type\
    \x18\x02\x20\x01(\x0e2\x20.signalservice.GroupContext.TypeR\x04typeB\0\
    \x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\"\n\x0bmembersE164\
    \x18\x04\x20\x03(\tR\x0bmembersE164B\0\x12>\n\x07members\x18\x06\x20\x03\
    (\x0b2\".signalservice.GroupContext.MemberR\x07membersB\0\x12:\n\x06avat\
    ar\x18\x05\x20\x01(\x0b2\x20.signalservice.AttachmentPointerR\x06avatarB\
    \0\x1a6\n\x06Member\x12\x14\n\x04uuid\x18\x01\x20\x01(\tR\x04uuidB\0\x12\
    \x14\n\x04e164\x18\x02\x20\x01(\tR\x04e164B\0:\0\"J\n\x04Type\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\n\n\x06UPDATE\x10\x01\x12\x0b\n\x07DELIVER\x10\x02\
    \x12\x08\n\x04QUIT\x10\x03\x12\x10\n\x0cREQUEST_INFO\x10\x04\x1a\0:\0\"\
    \x93\x03\n\x0eContactDetails\x12\x18\n\x06number\x18\x01\x20\x01(\tR\x06\
    numberB\0\x12\x14\n\x04uuid\x18\t\x20\x01(\tR\x04uuidB\0\x12\x14\n\x04na\
    me\x18\x02\x20\x01(\tR\x04nameB\0\x12>\n\x06avatar\x18\x03\x20\x01(\x0b2\
    $.signalservice.ContactDetails.AvatarR\x06avatarB\0\x12\x16\n\x05color\
    \x18\x04\x20\x01(\tR\x05colorB\0\x125\n\x08verified\x18\x05\x20\x01(\x0b\
    2\x17.signalservice.VerifiedR\x08verifiedB\0\x12\x20\n\nprofileKey\x18\
    \x06\x20\x01(\x0cR\nprofileKeyB\0\x12\x1a\n\x07blocked\x18\x07\x20\x01(\
    \x08R\x07blockedB\0\x12\"\n\x0bexpireTimer\x18\x08\x20\x01(\rR\x0bexpire\
    TimerB\0\x1aH\n\x06Avatar\x12\"\n\x0bcontentType\x18\x01\x20\x01(\tR\x0b\
    contentTypeB\0\x12\x18\n\x06length\x18\x02\x20\x01(\rR\x06lengthB\0:\0:\
    \0\"\xd4\x03\n\x0cGroupDetails\x12\x10\n\x02id\x18\x01\x20\x01(\x0cR\x02\
    idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12\"\n\x0bmember\
    sE164\x18\x03\x20\x03(\tR\x0bmembersE164B\0\x12>\n\x07members\x18\t\x20\
    \x03(\x0b2\".signalservice.GroupDetails.MemberR\x07membersB\0\x12<\n\x06\
    avatar\x18\x04\x20\x01(\x0b2\".signalservice.GroupDetails.AvatarR\x06ava\
    tarB\0\x12\x1e\n\x06active\x18\x05\x20\x01(\x08:\x04trueR\x06activeB\0\
    \x12\"\n\x0bexpireTimer\x18\x06\x20\x01(\rR\x0bexpireTimerB\0\x12\x16\n\
    \x05color\x18\x07\x20\x01(\tR\x05colorB\0\x12\x1a\n\x07blocked\x18\x08\
    \x20\x01(\x08R\x07blockedB\0\x1aH\n\x06Avatar\x12\"\n\x0bcontentType\x18\
    \x01\x20\x01(\tR\x0bcontentTypeB\0\x12\x18\n\x06length\x18\x02\x20\x01(\
    \rR\x06lengthB\0:\0\x1a6\n\x06Member\x12\x14\n\x04uuid\x18\x01\x20\x01(\
    \tR\x04uuidB\0\x12\x14\n\x04e164\x18\x02\x20\x01(\tR\x04e164B\0:\0:\0B\0\
    b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
