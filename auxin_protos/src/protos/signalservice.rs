// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `signalservice.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Envelope {
    // message fields
    field_type: ::std::option::Option<Envelope_Type>,
    sourceE164: ::protobuf::SingularField<::std::string::String>,
    sourceUuid: ::protobuf::SingularField<::std::string::String>,
    sourceDevice: ::std::option::Option<u32>,
    relay: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    legacyMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    serverGuid: ::protobuf::SingularField<::std::string::String>,
    serverTimestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Envelope {
    fn default() -> &'a Envelope {
        <Envelope as ::protobuf::Message>::default_instance()
    }
}

impl Envelope {
    pub fn new() -> Envelope {
        ::std::default::Default::default()
    }

    // optional .signalservice.Envelope.Type type = 1;


    pub fn get_field_type(&self) -> Envelope_Type {
        self.field_type.unwrap_or(Envelope_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Envelope_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string sourceE164 = 2;


    pub fn get_sourceE164(&self) -> &str {
        match self.sourceE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sourceE164(&mut self) {
        self.sourceE164.clear();
    }

    pub fn has_sourceE164(&self) -> bool {
        self.sourceE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceE164(&mut self, v: ::std::string::String) {
        self.sourceE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceE164(&mut self) -> &mut ::std::string::String {
        if self.sourceE164.is_none() {
            self.sourceE164.set_default();
        }
        self.sourceE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceE164(&mut self) -> ::std::string::String {
        self.sourceE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sourceUuid = 11;


    pub fn get_sourceUuid(&self) -> &str {
        match self.sourceUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sourceUuid(&mut self) {
        self.sourceUuid.clear();
    }

    pub fn has_sourceUuid(&self) -> bool {
        self.sourceUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceUuid(&mut self, v: ::std::string::String) {
        self.sourceUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceUuid(&mut self) -> &mut ::std::string::String {
        if self.sourceUuid.is_none() {
            self.sourceUuid.set_default();
        }
        self.sourceUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceUuid(&mut self) -> ::std::string::String {
        self.sourceUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 sourceDevice = 7;


    pub fn get_sourceDevice(&self) -> u32 {
        self.sourceDevice.unwrap_or(0)
    }
    pub fn clear_sourceDevice(&mut self) {
        self.sourceDevice = ::std::option::Option::None;
    }

    pub fn has_sourceDevice(&self) -> bool {
        self.sourceDevice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceDevice(&mut self, v: u32) {
        self.sourceDevice = ::std::option::Option::Some(v);
    }

    // optional string relay = 3;


    pub fn get_relay(&self) -> &str {
        match self.relay.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_relay(&mut self) {
        self.relay.clear();
    }

    pub fn has_relay(&self) -> bool {
        self.relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay(&mut self, v: ::std::string::String) {
        self.relay = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay(&mut self) -> &mut ::std::string::String {
        if self.relay.is_none() {
            self.relay.set_default();
        }
        self.relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay(&mut self) -> ::std::string::String {
        self.relay.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 5;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bytes legacyMessage = 6;


    pub fn get_legacyMessage(&self) -> &[u8] {
        match self.legacyMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_legacyMessage(&mut self) {
        self.legacyMessage.clear();
    }

    pub fn has_legacyMessage(&self) -> bool {
        self.legacyMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacyMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacyMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacyMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacyMessage.is_none() {
            self.legacyMessage.set_default();
        }
        self.legacyMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacyMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.legacyMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes content = 8;


    pub fn get_content(&self) -> &[u8] {
        match self.content.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        self.content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string serverGuid = 9;


    pub fn get_serverGuid(&self) -> &str {
        match self.serverGuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverGuid(&mut self) {
        self.serverGuid.clear();
    }

    pub fn has_serverGuid(&self) -> bool {
        self.serverGuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverGuid(&mut self, v: ::std::string::String) {
        self.serverGuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverGuid(&mut self) -> &mut ::std::string::String {
        if self.serverGuid.is_none() {
            self.serverGuid.set_default();
        }
        self.serverGuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverGuid(&mut self) -> ::std::string::String {
        self.serverGuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 serverTimestamp = 10;


    pub fn get_serverTimestamp(&self) -> u64 {
        self.serverTimestamp.unwrap_or(0)
    }
    pub fn clear_serverTimestamp(&mut self) {
        self.serverTimestamp = ::std::option::Option::None;
    }

    pub fn has_serverTimestamp(&self) -> bool {
        self.serverTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverTimestamp(&mut self, v: u64) {
        self.serverTimestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Envelope {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceE164)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceUuid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sourceDevice = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relay)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.legacyMessage)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.content)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverGuid)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverTimestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.sourceE164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sourceUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.sourceDevice {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.relay.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.legacyMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.serverGuid.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.serverTimestamp {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.sourceE164.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sourceUuid.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.sourceDevice {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.relay.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.legacyMessage.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.serverGuid.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.serverTimestamp {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Envelope {
        Envelope::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Envelope_Type>>(
                "type",
                |m: &Envelope| { &m.field_type },
                |m: &mut Envelope| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceE164",
                |m: &Envelope| { &m.sourceE164 },
                |m: &mut Envelope| { &mut m.sourceE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceUuid",
                |m: &Envelope| { &m.sourceUuid },
                |m: &mut Envelope| { &mut m.sourceUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sourceDevice",
                |m: &Envelope| { &m.sourceDevice },
                |m: &mut Envelope| { &mut m.sourceDevice },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relay",
                |m: &Envelope| { &m.relay },
                |m: &mut Envelope| { &mut m.relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Envelope| { &m.timestamp },
                |m: &mut Envelope| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "legacyMessage",
                |m: &Envelope| { &m.legacyMessage },
                |m: &mut Envelope| { &mut m.legacyMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &Envelope| { &m.content },
                |m: &mut Envelope| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverGuid",
                |m: &Envelope| { &m.serverGuid },
                |m: &mut Envelope| { &mut m.serverGuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "serverTimestamp",
                |m: &Envelope| { &m.serverTimestamp },
                |m: &mut Envelope| { &mut m.serverTimestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Envelope>(
                "Envelope",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Envelope {
        static instance: ::protobuf::rt::LazyV2<Envelope> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Envelope::new)
    }
}

impl ::protobuf::Clear for Envelope {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.sourceE164.clear();
        self.sourceUuid.clear();
        self.sourceDevice = ::std::option::Option::None;
        self.relay.clear();
        self.timestamp = ::std::option::Option::None;
        self.legacyMessage.clear();
        self.content.clear();
        self.serverGuid.clear();
        self.serverTimestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Envelope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Envelope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Envelope_Type {
    UNKNOWN = 0,
    CIPHERTEXT = 1,
    KEY_EXCHANGE = 2,
    PREKEY_BUNDLE = 3,
    RECEIPT = 5,
    UNIDENTIFIED_SENDER = 6,
    PLAINTEXT_CONTENT = 8,
}

impl ::protobuf::ProtobufEnum for Envelope_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Envelope_Type> {
        match value {
            0 => ::std::option::Option::Some(Envelope_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Envelope_Type::CIPHERTEXT),
            2 => ::std::option::Option::Some(Envelope_Type::KEY_EXCHANGE),
            3 => ::std::option::Option::Some(Envelope_Type::PREKEY_BUNDLE),
            5 => ::std::option::Option::Some(Envelope_Type::RECEIPT),
            6 => ::std::option::Option::Some(Envelope_Type::UNIDENTIFIED_SENDER),
            8 => ::std::option::Option::Some(Envelope_Type::PLAINTEXT_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Envelope_Type] = &[
            Envelope_Type::UNKNOWN,
            Envelope_Type::CIPHERTEXT,
            Envelope_Type::KEY_EXCHANGE,
            Envelope_Type::PREKEY_BUNDLE,
            Envelope_Type::RECEIPT,
            Envelope_Type::UNIDENTIFIED_SENDER,
            Envelope_Type::PLAINTEXT_CONTENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Envelope_Type>("Envelope.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Envelope_Type {
}

impl ::std::default::Default for Envelope_Type {
    fn default() -> Self {
        Envelope_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Envelope_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Content {
    // message fields
    pub dataMessage: ::protobuf::SingularPtrField<DataMessage>,
    pub syncMessage: ::protobuf::SingularPtrField<SyncMessage>,
    pub callMessage: ::protobuf::SingularPtrField<CallMessage>,
    pub nullMessage: ::protobuf::SingularPtrField<NullMessage>,
    pub receiptMessage: ::protobuf::SingularPtrField<ReceiptMessage>,
    pub typingMessage: ::protobuf::SingularPtrField<TypingMessage>,
    senderKeyDistributionMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    decryptionErrorMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Content {
    fn default() -> &'a Content {
        <Content as ::protobuf::Message>::default_instance()
    }
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage dataMessage = 1;


    pub fn get_dataMessage(&self) -> &DataMessage {
        self.dataMessage.as_ref().unwrap_or_else(|| <DataMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataMessage(&mut self) {
        self.dataMessage.clear();
    }

    pub fn has_dataMessage(&self) -> bool {
        self.dataMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataMessage(&mut self, v: DataMessage) {
        self.dataMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataMessage(&mut self) -> &mut DataMessage {
        if self.dataMessage.is_none() {
            self.dataMessage.set_default();
        }
        self.dataMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataMessage(&mut self) -> DataMessage {
        self.dataMessage.take().unwrap_or_else(|| DataMessage::new())
    }

    // optional .signalservice.SyncMessage syncMessage = 2;


    pub fn get_syncMessage(&self) -> &SyncMessage {
        self.syncMessage.as_ref().unwrap_or_else(|| <SyncMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncMessage(&mut self) {
        self.syncMessage.clear();
    }

    pub fn has_syncMessage(&self) -> bool {
        self.syncMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncMessage(&mut self, v: SyncMessage) {
        self.syncMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncMessage(&mut self) -> &mut SyncMessage {
        if self.syncMessage.is_none() {
            self.syncMessage.set_default();
        }
        self.syncMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncMessage(&mut self) -> SyncMessage {
        self.syncMessage.take().unwrap_or_else(|| SyncMessage::new())
    }

    // optional .signalservice.CallMessage callMessage = 3;


    pub fn get_callMessage(&self) -> &CallMessage {
        self.callMessage.as_ref().unwrap_or_else(|| <CallMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_callMessage(&mut self) {
        self.callMessage.clear();
    }

    pub fn has_callMessage(&self) -> bool {
        self.callMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callMessage(&mut self, v: CallMessage) {
        self.callMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callMessage(&mut self) -> &mut CallMessage {
        if self.callMessage.is_none() {
            self.callMessage.set_default();
        }
        self.callMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_callMessage(&mut self) -> CallMessage {
        self.callMessage.take().unwrap_or_else(|| CallMessage::new())
    }

    // optional .signalservice.NullMessage nullMessage = 4;


    pub fn get_nullMessage(&self) -> &NullMessage {
        self.nullMessage.as_ref().unwrap_or_else(|| <NullMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nullMessage(&mut self) {
        self.nullMessage.clear();
    }

    pub fn has_nullMessage(&self) -> bool {
        self.nullMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nullMessage(&mut self, v: NullMessage) {
        self.nullMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nullMessage(&mut self) -> &mut NullMessage {
        if self.nullMessage.is_none() {
            self.nullMessage.set_default();
        }
        self.nullMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_nullMessage(&mut self) -> NullMessage {
        self.nullMessage.take().unwrap_or_else(|| NullMessage::new())
    }

    // optional .signalservice.ReceiptMessage receiptMessage = 5;


    pub fn get_receiptMessage(&self) -> &ReceiptMessage {
        self.receiptMessage.as_ref().unwrap_or_else(|| <ReceiptMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_receiptMessage(&mut self) {
        self.receiptMessage.clear();
    }

    pub fn has_receiptMessage(&self) -> bool {
        self.receiptMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiptMessage(&mut self, v: ReceiptMessage) {
        self.receiptMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptMessage(&mut self) -> &mut ReceiptMessage {
        if self.receiptMessage.is_none() {
            self.receiptMessage.set_default();
        }
        self.receiptMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiptMessage(&mut self) -> ReceiptMessage {
        self.receiptMessage.take().unwrap_or_else(|| ReceiptMessage::new())
    }

    // optional .signalservice.TypingMessage typingMessage = 6;


    pub fn get_typingMessage(&self) -> &TypingMessage {
        self.typingMessage.as_ref().unwrap_or_else(|| <TypingMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typingMessage(&mut self) {
        self.typingMessage.clear();
    }

    pub fn has_typingMessage(&self) -> bool {
        self.typingMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typingMessage(&mut self, v: TypingMessage) {
        self.typingMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typingMessage(&mut self) -> &mut TypingMessage {
        if self.typingMessage.is_none() {
            self.typingMessage.set_default();
        }
        self.typingMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_typingMessage(&mut self) -> TypingMessage {
        self.typingMessage.take().unwrap_or_else(|| TypingMessage::new())
    }

    // optional bytes senderKeyDistributionMessage = 7;


    pub fn get_senderKeyDistributionMessage(&self) -> &[u8] {
        match self.senderKeyDistributionMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_senderKeyDistributionMessage(&mut self) {
        self.senderKeyDistributionMessage.clear();
    }

    pub fn has_senderKeyDistributionMessage(&self) -> bool {
        self.senderKeyDistributionMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderKeyDistributionMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.senderKeyDistributionMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderKeyDistributionMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.senderKeyDistributionMessage.is_none() {
            self.senderKeyDistributionMessage.set_default();
        }
        self.senderKeyDistributionMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderKeyDistributionMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.senderKeyDistributionMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decryptionErrorMessage = 8;


    pub fn get_decryptionErrorMessage(&self) -> &[u8] {
        match self.decryptionErrorMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_decryptionErrorMessage(&mut self) {
        self.decryptionErrorMessage.clear();
    }

    pub fn has_decryptionErrorMessage(&self) -> bool {
        self.decryptionErrorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decryptionErrorMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.decryptionErrorMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decryptionErrorMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decryptionErrorMessage.is_none() {
            self.decryptionErrorMessage.set_default();
        }
        self.decryptionErrorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_decryptionErrorMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.decryptionErrorMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Content {
    fn is_initialized(&self) -> bool {
        for v in &self.dataMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.callMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nullMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receiptMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.typingMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataMessage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncMessage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.callMessage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nullMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.receiptMessage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typingMessage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.senderKeyDistributionMessage)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.decryptionErrorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.callMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.receiptMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.typingMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.senderKeyDistributionMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.decryptionErrorMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataMessage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncMessage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.callMessage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.receiptMessage.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.typingMessage.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.senderKeyDistributionMessage.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.decryptionErrorMessage.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Content {
        Content::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage>>(
                "dataMessage",
                |m: &Content| { &m.dataMessage },
                |m: &mut Content| { &mut m.dataMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage>>(
                "syncMessage",
                |m: &Content| { &m.syncMessage },
                |m: &mut Content| { &mut m.syncMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage>>(
                "callMessage",
                |m: &Content| { &m.callMessage },
                |m: &mut Content| { &mut m.callMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NullMessage>>(
                "nullMessage",
                |m: &Content| { &m.nullMessage },
                |m: &mut Content| { &mut m.nullMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiptMessage>>(
                "receiptMessage",
                |m: &Content| { &m.receiptMessage },
                |m: &mut Content| { &mut m.receiptMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypingMessage>>(
                "typingMessage",
                |m: &Content| { &m.typingMessage },
                |m: &mut Content| { &mut m.typingMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "senderKeyDistributionMessage",
                |m: &Content| { &m.senderKeyDistributionMessage },
                |m: &mut Content| { &mut m.senderKeyDistributionMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "decryptionErrorMessage",
                |m: &Content| { &m.decryptionErrorMessage },
                |m: &mut Content| { &mut m.decryptionErrorMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Content>(
                "Content",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Content {
        static instance: ::protobuf::rt::LazyV2<Content> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Content::new)
    }
}

impl ::protobuf::Clear for Content {
    fn clear(&mut self) {
        self.dataMessage.clear();
        self.syncMessage.clear();
        self.callMessage.clear();
        self.nullMessage.clear();
        self.receiptMessage.clear();
        self.typingMessage.clear();
        self.senderKeyDistributionMessage.clear();
        self.decryptionErrorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage {
    // message fields
    pub offer: ::protobuf::SingularPtrField<CallMessage_Offer>,
    pub answer: ::protobuf::SingularPtrField<CallMessage_Answer>,
    pub iceUpdate: ::protobuf::RepeatedField<CallMessage_IceUpdate>,
    pub legacyHangup: ::protobuf::SingularPtrField<CallMessage_Hangup>,
    pub busy: ::protobuf::SingularPtrField<CallMessage_Busy>,
    pub hangup: ::protobuf::SingularPtrField<CallMessage_Hangup>,
    multiRing: ::std::option::Option<bool>,
    destinationDeviceId: ::std::option::Option<u32>,
    pub opaque: ::protobuf::SingularPtrField<CallMessage_Opaque>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage {
    fn default() -> &'a CallMessage {
        <CallMessage as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage {
    pub fn new() -> CallMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.CallMessage.Offer offer = 1;


    pub fn get_offer(&self) -> &CallMessage_Offer {
        self.offer.as_ref().unwrap_or_else(|| <CallMessage_Offer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_offer(&mut self) {
        self.offer.clear();
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: CallMessage_Offer) {
        self.offer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut CallMessage_Offer {
        if self.offer.is_none() {
            self.offer.set_default();
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> CallMessage_Offer {
        self.offer.take().unwrap_or_else(|| CallMessage_Offer::new())
    }

    // optional .signalservice.CallMessage.Answer answer = 2;


    pub fn get_answer(&self) -> &CallMessage_Answer {
        self.answer.as_ref().unwrap_or_else(|| <CallMessage_Answer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: CallMessage_Answer) {
        self.answer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut CallMessage_Answer {
        if self.answer.is_none() {
            self.answer.set_default();
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> CallMessage_Answer {
        self.answer.take().unwrap_or_else(|| CallMessage_Answer::new())
    }

    // repeated .signalservice.CallMessage.IceUpdate iceUpdate = 3;


    pub fn get_iceUpdate(&self) -> &[CallMessage_IceUpdate] {
        &self.iceUpdate
    }
    pub fn clear_iceUpdate(&mut self) {
        self.iceUpdate.clear();
    }

    // Param is passed by value, moved
    pub fn set_iceUpdate(&mut self, v: ::protobuf::RepeatedField<CallMessage_IceUpdate>) {
        self.iceUpdate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_iceUpdate(&mut self) -> &mut ::protobuf::RepeatedField<CallMessage_IceUpdate> {
        &mut self.iceUpdate
    }

    // Take field
    pub fn take_iceUpdate(&mut self) -> ::protobuf::RepeatedField<CallMessage_IceUpdate> {
        ::std::mem::replace(&mut self.iceUpdate, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.CallMessage.Hangup legacyHangup = 4;


    pub fn get_legacyHangup(&self) -> &CallMessage_Hangup {
        self.legacyHangup.as_ref().unwrap_or_else(|| <CallMessage_Hangup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_legacyHangup(&mut self) {
        self.legacyHangup.clear();
    }

    pub fn has_legacyHangup(&self) -> bool {
        self.legacyHangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacyHangup(&mut self, v: CallMessage_Hangup) {
        self.legacyHangup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacyHangup(&mut self) -> &mut CallMessage_Hangup {
        if self.legacyHangup.is_none() {
            self.legacyHangup.set_default();
        }
        self.legacyHangup.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacyHangup(&mut self) -> CallMessage_Hangup {
        self.legacyHangup.take().unwrap_or_else(|| CallMessage_Hangup::new())
    }

    // optional .signalservice.CallMessage.Busy busy = 5;


    pub fn get_busy(&self) -> &CallMessage_Busy {
        self.busy.as_ref().unwrap_or_else(|| <CallMessage_Busy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_busy(&mut self) {
        self.busy.clear();
    }

    pub fn has_busy(&self) -> bool {
        self.busy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy(&mut self, v: CallMessage_Busy) {
        self.busy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_busy(&mut self) -> &mut CallMessage_Busy {
        if self.busy.is_none() {
            self.busy.set_default();
        }
        self.busy.as_mut().unwrap()
    }

    // Take field
    pub fn take_busy(&mut self) -> CallMessage_Busy {
        self.busy.take().unwrap_or_else(|| CallMessage_Busy::new())
    }

    // optional .signalservice.CallMessage.Hangup hangup = 7;


    pub fn get_hangup(&self) -> &CallMessage_Hangup {
        self.hangup.as_ref().unwrap_or_else(|| <CallMessage_Hangup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hangup(&mut self) {
        self.hangup.clear();
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: CallMessage_Hangup) {
        self.hangup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hangup(&mut self) -> &mut CallMessage_Hangup {
        if self.hangup.is_none() {
            self.hangup.set_default();
        }
        self.hangup.as_mut().unwrap()
    }

    // Take field
    pub fn take_hangup(&mut self) -> CallMessage_Hangup {
        self.hangup.take().unwrap_or_else(|| CallMessage_Hangup::new())
    }

    // optional bool multiRing = 8;


    pub fn get_multiRing(&self) -> bool {
        self.multiRing.unwrap_or(false)
    }
    pub fn clear_multiRing(&mut self) {
        self.multiRing = ::std::option::Option::None;
    }

    pub fn has_multiRing(&self) -> bool {
        self.multiRing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiRing(&mut self, v: bool) {
        self.multiRing = ::std::option::Option::Some(v);
    }

    // optional uint32 destinationDeviceId = 9;


    pub fn get_destinationDeviceId(&self) -> u32 {
        self.destinationDeviceId.unwrap_or(0)
    }
    pub fn clear_destinationDeviceId(&mut self) {
        self.destinationDeviceId = ::std::option::Option::None;
    }

    pub fn has_destinationDeviceId(&self) -> bool {
        self.destinationDeviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationDeviceId(&mut self, v: u32) {
        self.destinationDeviceId = ::std::option::Option::Some(v);
    }

    // optional .signalservice.CallMessage.Opaque opaque = 10;


    pub fn get_opaque(&self) -> &CallMessage_Opaque {
        self.opaque.as_ref().unwrap_or_else(|| <CallMessage_Opaque as ::protobuf::Message>::default_instance())
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: CallMessage_Opaque) {
        self.opaque = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut CallMessage_Opaque {
        if self.opaque.is_none() {
            self.opaque.set_default();
        }
        self.opaque.as_mut().unwrap()
    }

    // Take field
    pub fn take_opaque(&mut self) -> CallMessage_Opaque {
        self.opaque.take().unwrap_or_else(|| CallMessage_Opaque::new())
    }
}

impl ::protobuf::Message for CallMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.answer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iceUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.legacyHangup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.busy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hangup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opaque {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.answer)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.iceUpdate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.legacyHangup)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.busy)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hangup)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiRing = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.destinationDeviceId = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.opaque)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.answer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.iceUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.legacyHangup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.busy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hangup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.multiRing {
            my_size += 2;
        }
        if let Some(v) = self.destinationDeviceId {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.opaque.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.answer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.iceUpdate {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.legacyHangup.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.busy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hangup.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.multiRing {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.destinationDeviceId {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.opaque.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage {
        CallMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Offer>>(
                "offer",
                |m: &CallMessage| { &m.offer },
                |m: &mut CallMessage| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Answer>>(
                "answer",
                |m: &CallMessage| { &m.answer },
                |m: &mut CallMessage| { &mut m.answer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_IceUpdate>>(
                "iceUpdate",
                |m: &CallMessage| { &m.iceUpdate },
                |m: &mut CallMessage| { &mut m.iceUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Hangup>>(
                "legacyHangup",
                |m: &CallMessage| { &m.legacyHangup },
                |m: &mut CallMessage| { &mut m.legacyHangup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Busy>>(
                "busy",
                |m: &CallMessage| { &m.busy },
                |m: &mut CallMessage| { &mut m.busy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Hangup>>(
                "hangup",
                |m: &CallMessage| { &m.hangup },
                |m: &mut CallMessage| { &mut m.hangup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "multiRing",
                |m: &CallMessage| { &m.multiRing },
                |m: &mut CallMessage| { &mut m.multiRing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "destinationDeviceId",
                |m: &CallMessage| { &m.destinationDeviceId },
                |m: &mut CallMessage| { &mut m.destinationDeviceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CallMessage_Opaque>>(
                "opaque",
                |m: &CallMessage| { &m.opaque },
                |m: &mut CallMessage| { &mut m.opaque },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage>(
                "CallMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage {
        static instance: ::protobuf::rt::LazyV2<CallMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage::new)
    }
}

impl ::protobuf::Clear for CallMessage {
    fn clear(&mut self) {
        self.offer.clear();
        self.answer.clear();
        self.iceUpdate.clear();
        self.legacyHangup.clear();
        self.busy.clear();
        self.hangup.clear();
        self.multiRing = ::std::option::Option::None;
        self.destinationDeviceId = ::std::option::Option::None;
        self.opaque.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Offer {
    // message fields
    id: ::std::option::Option<u64>,
    sdp: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<CallMessage_Offer_Type>,
    opaque: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Offer {
    fn default() -> &'a CallMessage_Offer {
        <CallMessage_Offer as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Offer {
    pub fn new() -> CallMessage_Offer {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string sdp = 2;


    pub fn get_sdp(&self) -> &str {
        match self.sdp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    pub fn has_sdp(&self) -> bool {
        self.sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        if self.sdp.is_none() {
            self.sdp.set_default();
        }
        self.sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        self.sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.CallMessage.Offer.Type type = 3;


    pub fn get_field_type(&self) -> CallMessage_Offer_Type {
        self.field_type.unwrap_or(CallMessage_Offer_Type::OFFER_AUDIO_CALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CallMessage_Offer_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes opaque = 4;


    pub fn get_opaque(&self) -> &[u8] {
        match self.opaque.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.opaque.is_none() {
            self.opaque.set_default();
        }
        self.opaque.as_mut().unwrap()
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        self.opaque.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CallMessage_Offer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.opaque.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.sdp.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.opaque.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Offer {
        CallMessage_Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Offer| { &m.id },
                |m: &mut CallMessage_Offer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &CallMessage_Offer| { &m.sdp },
                |m: &mut CallMessage_Offer| { &mut m.sdp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CallMessage_Offer_Type>>(
                "type",
                |m: &CallMessage_Offer| { &m.field_type },
                |m: &mut CallMessage_Offer| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "opaque",
                |m: &CallMessage_Offer| { &m.opaque },
                |m: &mut CallMessage_Offer| { &mut m.opaque },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Offer>(
                "CallMessage.Offer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Offer {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Offer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Offer::new)
    }
}

impl ::protobuf::Clear for CallMessage_Offer {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.sdp.clear();
        self.field_type = ::std::option::Option::None;
        self.opaque.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CallMessage_Offer_Type {
    OFFER_AUDIO_CALL = 0,
    OFFER_VIDEO_CALL = 1,
}

impl ::protobuf::ProtobufEnum for CallMessage_Offer_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CallMessage_Offer_Type> {
        match value {
            0 => ::std::option::Option::Some(CallMessage_Offer_Type::OFFER_AUDIO_CALL),
            1 => ::std::option::Option::Some(CallMessage_Offer_Type::OFFER_VIDEO_CALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CallMessage_Offer_Type] = &[
            CallMessage_Offer_Type::OFFER_AUDIO_CALL,
            CallMessage_Offer_Type::OFFER_VIDEO_CALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CallMessage_Offer_Type>("CallMessage.Offer.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CallMessage_Offer_Type {
}

impl ::std::default::Default for CallMessage_Offer_Type {
    fn default() -> Self {
        CallMessage_Offer_Type::OFFER_AUDIO_CALL
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Offer_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Answer {
    // message fields
    id: ::std::option::Option<u64>,
    sdp: ::protobuf::SingularField<::std::string::String>,
    opaque: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Answer {
    fn default() -> &'a CallMessage_Answer {
        <CallMessage_Answer as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Answer {
    pub fn new() -> CallMessage_Answer {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string sdp = 2;


    pub fn get_sdp(&self) -> &str {
        match self.sdp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    pub fn has_sdp(&self) -> bool {
        self.sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        if self.sdp.is_none() {
            self.sdp.set_default();
        }
        self.sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        self.sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes opaque = 3;


    pub fn get_opaque(&self) -> &[u8] {
        match self.opaque.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.opaque.is_none() {
            self.opaque.set_default();
        }
        self.opaque.as_mut().unwrap()
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        self.opaque.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CallMessage_Answer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.opaque.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.sdp.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.opaque.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Answer {
        CallMessage_Answer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Answer| { &m.id },
                |m: &mut CallMessage_Answer| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &CallMessage_Answer| { &m.sdp },
                |m: &mut CallMessage_Answer| { &mut m.sdp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "opaque",
                |m: &CallMessage_Answer| { &m.opaque },
                |m: &mut CallMessage_Answer| { &mut m.opaque },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Answer>(
                "CallMessage.Answer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Answer {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Answer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Answer::new)
    }
}

impl ::protobuf::Clear for CallMessage_Answer {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.sdp.clear();
        self.opaque.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Answer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Answer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_IceUpdate {
    // message fields
    id: ::std::option::Option<u64>,
    mid: ::protobuf::SingularField<::std::string::String>,
    line: ::std::option::Option<u32>,
    sdp: ::protobuf::SingularField<::std::string::String>,
    opaque: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_IceUpdate {
    fn default() -> &'a CallMessage_IceUpdate {
        <CallMessage_IceUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_IceUpdate {
    pub fn new() -> CallMessage_IceUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string mid = 2;


    pub fn get_mid(&self) -> &str {
        match self.mid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mid(&mut self) {
        self.mid.clear();
    }

    pub fn has_mid(&self) -> bool {
        self.mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mid(&mut self, v: ::std::string::String) {
        self.mid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid(&mut self) -> &mut ::std::string::String {
        if self.mid.is_none() {
            self.mid.set_default();
        }
        self.mid.as_mut().unwrap()
    }

    // Take field
    pub fn take_mid(&mut self) -> ::std::string::String {
        self.mid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 line = 3;


    pub fn get_line(&self) -> u32 {
        self.line.unwrap_or(0)
    }
    pub fn clear_line(&mut self) {
        self.line = ::std::option::Option::None;
    }

    pub fn has_line(&self) -> bool {
        self.line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: u32) {
        self.line = ::std::option::Option::Some(v);
    }

    // optional string sdp = 4;


    pub fn get_sdp(&self) -> &str {
        match self.sdp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    pub fn has_sdp(&self) -> bool {
        self.sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        if self.sdp.is_none() {
            self.sdp.set_default();
        }
        self.sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        self.sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes opaque = 5;


    pub fn get_opaque(&self) -> &[u8] {
        match self.opaque.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.opaque.is_none() {
            self.opaque.set_default();
        }
        self.opaque.as_mut().unwrap()
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        self.opaque.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CallMessage_IceUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.line = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.line {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.opaque.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.mid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.line {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sdp.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.opaque.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_IceUpdate {
        CallMessage_IceUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_IceUpdate| { &m.id },
                |m: &mut CallMessage_IceUpdate| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mid",
                |m: &CallMessage_IceUpdate| { &m.mid },
                |m: &mut CallMessage_IceUpdate| { &mut m.mid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "line",
                |m: &CallMessage_IceUpdate| { &m.line },
                |m: &mut CallMessage_IceUpdate| { &mut m.line },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &CallMessage_IceUpdate| { &m.sdp },
                |m: &mut CallMessage_IceUpdate| { &mut m.sdp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "opaque",
                |m: &CallMessage_IceUpdate| { &m.opaque },
                |m: &mut CallMessage_IceUpdate| { &mut m.opaque },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_IceUpdate>(
                "CallMessage.IceUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_IceUpdate {
        static instance: ::protobuf::rt::LazyV2<CallMessage_IceUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_IceUpdate::new)
    }
}

impl ::protobuf::Clear for CallMessage_IceUpdate {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.mid.clear();
        self.line = ::std::option::Option::None;
        self.sdp.clear();
        self.opaque.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_IceUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_IceUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Busy {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Busy {
    fn default() -> &'a CallMessage_Busy {
        <CallMessage_Busy as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Busy {
    pub fn new() -> CallMessage_Busy {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CallMessage_Busy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Busy {
        CallMessage_Busy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Busy| { &m.id },
                |m: &mut CallMessage_Busy| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Busy>(
                "CallMessage.Busy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Busy {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Busy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Busy::new)
    }
}

impl ::protobuf::Clear for CallMessage_Busy {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Busy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Busy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Hangup {
    // message fields
    id: ::std::option::Option<u64>,
    field_type: ::std::option::Option<CallMessage_Hangup_Type>,
    deviceId: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Hangup {
    fn default() -> &'a CallMessage_Hangup {
        <CallMessage_Hangup as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Hangup {
    pub fn new() -> CallMessage_Hangup {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .signalservice.CallMessage.Hangup.Type type = 2;


    pub fn get_field_type(&self) -> CallMessage_Hangup_Type {
        self.field_type.unwrap_or(CallMessage_Hangup_Type::HANGUP_NORMAL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CallMessage_Hangup_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 deviceId = 3;


    pub fn get_deviceId(&self) -> u32 {
        self.deviceId.unwrap_or(0)
    }
    pub fn clear_deviceId(&mut self) {
        self.deviceId = ::std::option::Option::None;
    }

    pub fn has_deviceId(&self) -> bool {
        self.deviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceId(&mut self, v: u32) {
        self.deviceId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CallMessage_Hangup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deviceId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.deviceId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.deviceId {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Hangup {
        CallMessage_Hangup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CallMessage_Hangup| { &m.id },
                |m: &mut CallMessage_Hangup| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CallMessage_Hangup_Type>>(
                "type",
                |m: &CallMessage_Hangup| { &m.field_type },
                |m: &mut CallMessage_Hangup| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deviceId",
                |m: &CallMessage_Hangup| { &m.deviceId },
                |m: &mut CallMessage_Hangup| { &mut m.deviceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Hangup>(
                "CallMessage.Hangup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Hangup {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Hangup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Hangup::new)
    }
}

impl ::protobuf::Clear for CallMessage_Hangup {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.deviceId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Hangup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Hangup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CallMessage_Hangup_Type {
    HANGUP_NORMAL = 0,
    HANGUP_ACCEPTED = 1,
    HANGUP_DECLINED = 2,
    HANGUP_BUSY = 3,
    HANGUP_NEED_PERMISSION = 4,
}

impl ::protobuf::ProtobufEnum for CallMessage_Hangup_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CallMessage_Hangup_Type> {
        match value {
            0 => ::std::option::Option::Some(CallMessage_Hangup_Type::HANGUP_NORMAL),
            1 => ::std::option::Option::Some(CallMessage_Hangup_Type::HANGUP_ACCEPTED),
            2 => ::std::option::Option::Some(CallMessage_Hangup_Type::HANGUP_DECLINED),
            3 => ::std::option::Option::Some(CallMessage_Hangup_Type::HANGUP_BUSY),
            4 => ::std::option::Option::Some(CallMessage_Hangup_Type::HANGUP_NEED_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CallMessage_Hangup_Type] = &[
            CallMessage_Hangup_Type::HANGUP_NORMAL,
            CallMessage_Hangup_Type::HANGUP_ACCEPTED,
            CallMessage_Hangup_Type::HANGUP_DECLINED,
            CallMessage_Hangup_Type::HANGUP_BUSY,
            CallMessage_Hangup_Type::HANGUP_NEED_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CallMessage_Hangup_Type>("CallMessage.Hangup.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CallMessage_Hangup_Type {
}

impl ::std::default::Default for CallMessage_Hangup_Type {
    fn default() -> Self {
        CallMessage_Hangup_Type::HANGUP_NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Hangup_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CallMessage_Opaque {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallMessage_Opaque {
    fn default() -> &'a CallMessage_Opaque {
        <CallMessage_Opaque as ::protobuf::Message>::default_instance()
    }
}

impl CallMessage_Opaque {
    pub fn new() -> CallMessage_Opaque {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CallMessage_Opaque {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallMessage_Opaque {
        CallMessage_Opaque::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CallMessage_Opaque| { &m.data },
                |m: &mut CallMessage_Opaque| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CallMessage_Opaque>(
                "CallMessage.Opaque",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CallMessage_Opaque {
        static instance: ::protobuf::rt::LazyV2<CallMessage_Opaque> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CallMessage_Opaque::new)
    }
}

impl ::protobuf::Clear for CallMessage_Opaque {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallMessage_Opaque {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallMessage_Opaque {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage {
    // message fields
    body: ::protobuf::SingularField<::std::string::String>,
    pub attachments: ::protobuf::RepeatedField<AttachmentPointer>,
    pub group: ::protobuf::SingularPtrField<GroupContext>,
    pub groupV2: ::protobuf::SingularPtrField<GroupContextV2>,
    flags: ::std::option::Option<u32>,
    expireTimer: ::std::option::Option<u32>,
    profileKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timestamp: ::std::option::Option<u64>,
    pub quote: ::protobuf::SingularPtrField<DataMessage_Quote>,
    pub contact: ::protobuf::RepeatedField<DataMessage_Contact>,
    pub preview: ::protobuf::RepeatedField<DataMessage_Preview>,
    pub sticker: ::protobuf::SingularPtrField<DataMessage_Sticker>,
    requiredProtocolVersion: ::std::option::Option<u32>,
    isViewOnce: ::std::option::Option<bool>,
    pub reaction: ::protobuf::SingularPtrField<DataMessage_Reaction>,
    pub delete: ::protobuf::SingularPtrField<DataMessage_Delete>,
    pub bodyRanges: ::protobuf::RepeatedField<DataMessage_BodyRange>,
    pub groupCallUpdate: ::protobuf::SingularPtrField<DataMessage_GroupCallUpdate>,
    pub payment: ::protobuf::SingularPtrField<DataMessage_Payment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage {
    fn default() -> &'a DataMessage {
        <DataMessage as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage {
    pub fn new() -> DataMessage {
        ::std::default::Default::default()
    }

    // optional string body = 1;


    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .signalservice.AttachmentPointer attachments = 2;


    pub fn get_attachments(&self) -> &[AttachmentPointer] {
        &self.attachments
    }
    pub fn clear_attachments(&mut self) {
        self.attachments.clear();
    }

    // Param is passed by value, moved
    pub fn set_attachments(&mut self, v: ::protobuf::RepeatedField<AttachmentPointer>) {
        self.attachments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attachments(&mut self) -> &mut ::protobuf::RepeatedField<AttachmentPointer> {
        &mut self.attachments
    }

    // Take field
    pub fn take_attachments(&mut self) -> ::protobuf::RepeatedField<AttachmentPointer> {
        ::std::mem::replace(&mut self.attachments, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.GroupContext group = 3;


    pub fn get_group(&self) -> &GroupContext {
        self.group.as_ref().unwrap_or_else(|| <GroupContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: GroupContext) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut GroupContext {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> GroupContext {
        self.group.take().unwrap_or_else(|| GroupContext::new())
    }

    // optional .signalservice.GroupContextV2 groupV2 = 15;


    pub fn get_groupV2(&self) -> &GroupContextV2 {
        self.groupV2.as_ref().unwrap_or_else(|| <GroupContextV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groupV2(&mut self) {
        self.groupV2.clear();
    }

    pub fn has_groupV2(&self) -> bool {
        self.groupV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupV2(&mut self, v: GroupContextV2) {
        self.groupV2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupV2(&mut self) -> &mut GroupContextV2 {
        if self.groupV2.is_none() {
            self.groupV2.set_default();
        }
        self.groupV2.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupV2(&mut self) -> GroupContextV2 {
        self.groupV2.take().unwrap_or_else(|| GroupContextV2::new())
    }

    // optional uint32 flags = 4;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 5;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }

    // optional bytes profileKey = 6;


    pub fn get_profileKey(&self) -> &[u8] {
        match self.profileKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    pub fn has_profileKey(&self) -> bool {
        self.profileKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.profileKey.is_none() {
            self.profileKey.set_default();
        }
        self.profileKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        self.profileKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 timestamp = 7;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.DataMessage.Quote quote = 8;


    pub fn get_quote(&self) -> &DataMessage_Quote {
        self.quote.as_ref().unwrap_or_else(|| <DataMessage_Quote as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: DataMessage_Quote) {
        self.quote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut DataMessage_Quote {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> DataMessage_Quote {
        self.quote.take().unwrap_or_else(|| DataMessage_Quote::new())
    }

    // repeated .signalservice.DataMessage.Contact contact = 9;


    pub fn get_contact(&self) -> &[DataMessage_Contact] {
        &self.contact
    }
    pub fn clear_contact(&mut self) {
        self.contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact>) {
        self.contact = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contact(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact> {
        &mut self.contact
    }

    // Take field
    pub fn take_contact(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact> {
        ::std::mem::replace(&mut self.contact, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Preview preview = 10;


    pub fn get_preview(&self) -> &[DataMessage_Preview] {
        &self.preview
    }
    pub fn clear_preview(&mut self) {
        self.preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_preview(&mut self, v: ::protobuf::RepeatedField<DataMessage_Preview>) {
        self.preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preview(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Preview> {
        &mut self.preview
    }

    // Take field
    pub fn take_preview(&mut self) -> ::protobuf::RepeatedField<DataMessage_Preview> {
        ::std::mem::replace(&mut self.preview, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.DataMessage.Sticker sticker = 11;


    pub fn get_sticker(&self) -> &DataMessage_Sticker {
        self.sticker.as_ref().unwrap_or_else(|| <DataMessage_Sticker as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sticker(&mut self) {
        self.sticker.clear();
    }

    pub fn has_sticker(&self) -> bool {
        self.sticker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker(&mut self, v: DataMessage_Sticker) {
        self.sticker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sticker(&mut self) -> &mut DataMessage_Sticker {
        if self.sticker.is_none() {
            self.sticker.set_default();
        }
        self.sticker.as_mut().unwrap()
    }

    // Take field
    pub fn take_sticker(&mut self) -> DataMessage_Sticker {
        self.sticker.take().unwrap_or_else(|| DataMessage_Sticker::new())
    }

    // optional uint32 requiredProtocolVersion = 12;


    pub fn get_requiredProtocolVersion(&self) -> u32 {
        self.requiredProtocolVersion.unwrap_or(0)
    }
    pub fn clear_requiredProtocolVersion(&mut self) {
        self.requiredProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_requiredProtocolVersion(&self) -> bool {
        self.requiredProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requiredProtocolVersion(&mut self, v: u32) {
        self.requiredProtocolVersion = ::std::option::Option::Some(v);
    }

    // optional bool isViewOnce = 14;


    pub fn get_isViewOnce(&self) -> bool {
        self.isViewOnce.unwrap_or(false)
    }
    pub fn clear_isViewOnce(&mut self) {
        self.isViewOnce = ::std::option::Option::None;
    }

    pub fn has_isViewOnce(&self) -> bool {
        self.isViewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isViewOnce(&mut self, v: bool) {
        self.isViewOnce = ::std::option::Option::Some(v);
    }

    // optional .signalservice.DataMessage.Reaction reaction = 16;


    pub fn get_reaction(&self) -> &DataMessage_Reaction {
        self.reaction.as_ref().unwrap_or_else(|| <DataMessage_Reaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reaction(&mut self) {
        self.reaction.clear();
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: DataMessage_Reaction) {
        self.reaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut DataMessage_Reaction {
        if self.reaction.is_none() {
            self.reaction.set_default();
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> DataMessage_Reaction {
        self.reaction.take().unwrap_or_else(|| DataMessage_Reaction::new())
    }

    // optional .signalservice.DataMessage.Delete delete = 17;


    pub fn get_delete(&self) -> &DataMessage_Delete {
        self.delete.as_ref().unwrap_or_else(|| <DataMessage_Delete as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delete(&mut self) {
        self.delete.clear();
    }

    pub fn has_delete(&self) -> bool {
        self.delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete(&mut self, v: DataMessage_Delete) {
        self.delete = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delete(&mut self) -> &mut DataMessage_Delete {
        if self.delete.is_none() {
            self.delete.set_default();
        }
        self.delete.as_mut().unwrap()
    }

    // Take field
    pub fn take_delete(&mut self) -> DataMessage_Delete {
        self.delete.take().unwrap_or_else(|| DataMessage_Delete::new())
    }

    // repeated .signalservice.DataMessage.BodyRange bodyRanges = 18;


    pub fn get_bodyRanges(&self) -> &[DataMessage_BodyRange] {
        &self.bodyRanges
    }
    pub fn clear_bodyRanges(&mut self) {
        self.bodyRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_bodyRanges(&mut self, v: ::protobuf::RepeatedField<DataMessage_BodyRange>) {
        self.bodyRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bodyRanges(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_BodyRange> {
        &mut self.bodyRanges
    }

    // Take field
    pub fn take_bodyRanges(&mut self) -> ::protobuf::RepeatedField<DataMessage_BodyRange> {
        ::std::mem::replace(&mut self.bodyRanges, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.DataMessage.GroupCallUpdate groupCallUpdate = 19;


    pub fn get_groupCallUpdate(&self) -> &DataMessage_GroupCallUpdate {
        self.groupCallUpdate.as_ref().unwrap_or_else(|| <DataMessage_GroupCallUpdate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groupCallUpdate(&mut self) {
        self.groupCallUpdate.clear();
    }

    pub fn has_groupCallUpdate(&self) -> bool {
        self.groupCallUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupCallUpdate(&mut self, v: DataMessage_GroupCallUpdate) {
        self.groupCallUpdate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupCallUpdate(&mut self) -> &mut DataMessage_GroupCallUpdate {
        if self.groupCallUpdate.is_none() {
            self.groupCallUpdate.set_default();
        }
        self.groupCallUpdate.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupCallUpdate(&mut self) -> DataMessage_GroupCallUpdate {
        self.groupCallUpdate.take().unwrap_or_else(|| DataMessage_GroupCallUpdate::new())
    }

    // optional .signalservice.DataMessage.Payment payment = 20;


    pub fn get_payment(&self) -> &DataMessage_Payment {
        self.payment.as_ref().unwrap_or_else(|| <DataMessage_Payment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_payment(&mut self) {
        self.payment.clear();
    }

    pub fn has_payment(&self) -> bool {
        self.payment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment(&mut self, v: DataMessage_Payment) {
        self.payment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment(&mut self) -> &mut DataMessage_Payment {
        if self.payment.is_none() {
            self.payment.set_default();
        }
        self.payment.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment(&mut self) -> DataMessage_Payment {
        self.payment.take().unwrap_or_else(|| DataMessage_Payment::new())
    }
}

impl ::protobuf::Message for DataMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.attachments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupV2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quote {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contact {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sticker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delete {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bodyRanges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupCallUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attachments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupV2)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contact)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preview)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sticker)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requiredProtocolVersion = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isViewOnce = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reaction)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delete)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bodyRanges)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupCallUpdate)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.groupV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.contact {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sticker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requiredProtocolVersion {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isViewOnce {
            my_size += 2;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delete.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bodyRanges {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.groupCallUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.attachments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.groupV2.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(7, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.contact {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preview {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sticker.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.requiredProtocolVersion {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.isViewOnce {
            os.write_bool(14, v)?;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delete.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bodyRanges {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.groupCallUpdate.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payment.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage {
        DataMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &DataMessage| { &m.body },
                |m: &mut DataMessage| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "attachments",
                |m: &DataMessage| { &m.attachments },
                |m: &mut DataMessage| { &mut m.attachments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupContext>>(
                "group",
                |m: &DataMessage| { &m.group },
                |m: &mut DataMessage| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupContextV2>>(
                "groupV2",
                |m: &DataMessage| { &m.groupV2 },
                |m: &mut DataMessage| { &mut m.groupV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &DataMessage| { &m.flags },
                |m: &mut DataMessage| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &DataMessage| { &m.expireTimer },
                |m: &mut DataMessage| { &mut m.expireTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &DataMessage| { &m.profileKey },
                |m: &mut DataMessage| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &DataMessage| { &m.timestamp },
                |m: &mut DataMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Quote>>(
                "quote",
                |m: &DataMessage| { &m.quote },
                |m: &mut DataMessage| { &mut m.quote },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact>>(
                "contact",
                |m: &DataMessage| { &m.contact },
                |m: &mut DataMessage| { &mut m.contact },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Preview>>(
                "preview",
                |m: &DataMessage| { &m.preview },
                |m: &mut DataMessage| { &mut m.preview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Sticker>>(
                "sticker",
                |m: &DataMessage| { &m.sticker },
                |m: &mut DataMessage| { &mut m.sticker },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "requiredProtocolVersion",
                |m: &DataMessage| { &m.requiredProtocolVersion },
                |m: &mut DataMessage| { &mut m.requiredProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isViewOnce",
                |m: &DataMessage| { &m.isViewOnce },
                |m: &mut DataMessage| { &mut m.isViewOnce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Reaction>>(
                "reaction",
                |m: &DataMessage| { &m.reaction },
                |m: &mut DataMessage| { &mut m.reaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Delete>>(
                "delete",
                |m: &DataMessage| { &m.delete },
                |m: &mut DataMessage| { &mut m.delete },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_BodyRange>>(
                "bodyRanges",
                |m: &DataMessage| { &m.bodyRanges },
                |m: &mut DataMessage| { &mut m.bodyRanges },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_GroupCallUpdate>>(
                "groupCallUpdate",
                |m: &DataMessage| { &m.groupCallUpdate },
                |m: &mut DataMessage| { &mut m.groupCallUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Payment>>(
                "payment",
                |m: &DataMessage| { &m.payment },
                |m: &mut DataMessage| { &mut m.payment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage>(
                "DataMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage {
        static instance: ::protobuf::rt::LazyV2<DataMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage::new)
    }
}

impl ::protobuf::Clear for DataMessage {
    fn clear(&mut self) {
        self.body.clear();
        self.attachments.clear();
        self.group.clear();
        self.groupV2.clear();
        self.flags = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.profileKey.clear();
        self.timestamp = ::std::option::Option::None;
        self.quote.clear();
        self.contact.clear();
        self.preview.clear();
        self.sticker.clear();
        self.requiredProtocolVersion = ::std::option::Option::None;
        self.isViewOnce = ::std::option::Option::None;
        self.reaction.clear();
        self.delete.clear();
        self.bodyRanges.clear();
        self.groupCallUpdate.clear();
        self.payment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_BodyRange {
    // message fields
    start: ::std::option::Option<i32>,
    length: ::std::option::Option<i32>,
    // message oneof groups
    pub associatedValue: ::std::option::Option<DataMessage_BodyRange_oneof_associatedValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_BodyRange {
    fn default() -> &'a DataMessage_BodyRange {
        <DataMessage_BodyRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_BodyRange_oneof_associatedValue {
    mentionUuid(::std::string::String),
}

impl DataMessage_BodyRange {
    pub fn new() -> DataMessage_BodyRange {
        ::std::default::Default::default()
    }

    // optional int32 start = 1;


    pub fn get_start(&self) -> i32 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional string mentionUuid = 3;


    pub fn get_mentionUuid(&self) -> &str {
        match self.associatedValue {
            ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_mentionUuid(&mut self) {
        self.associatedValue = ::std::option::Option::None;
    }

    pub fn has_mentionUuid(&self) -> bool {
        match self.associatedValue {
            ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mentionUuid(&mut self, v: ::std::string::String) {
        self.associatedValue = ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mentionUuid(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(_)) = self.associatedValue {
        } else {
            self.associatedValue = ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(::std::string::String::new()));
        }
        match self.associatedValue {
            ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mentionUuid(&mut self) -> ::std::string::String {
        if self.has_mentionUuid() {
            match self.associatedValue.take() {
                ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for DataMessage_BodyRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.associatedValue = ::std::option::Option::Some(DataMessage_BodyRange_oneof_associatedValue::mentionUuid(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.associatedValue {
            match v {
                &DataMessage_BodyRange_oneof_associatedValue::mentionUuid(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.associatedValue {
            match v {
                &DataMessage_BodyRange_oneof_associatedValue::mentionUuid(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_BodyRange {
        DataMessage_BodyRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start",
                |m: &DataMessage_BodyRange| { &m.start },
                |m: &mut DataMessage_BodyRange| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length",
                |m: &DataMessage_BodyRange| { &m.length },
                |m: &mut DataMessage_BodyRange| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "mentionUuid",
                DataMessage_BodyRange::has_mentionUuid,
                DataMessage_BodyRange::get_mentionUuid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_BodyRange>(
                "DataMessage.BodyRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_BodyRange {
        static instance: ::protobuf::rt::LazyV2<DataMessage_BodyRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_BodyRange::new)
    }
}

impl ::protobuf::Clear for DataMessage_BodyRange {
    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.associatedValue = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_BodyRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_BodyRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Quote {
    // message fields
    id: ::std::option::Option<u64>,
    authorE164: ::protobuf::SingularField<::std::string::String>,
    authorUuid: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    pub attachments: ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment>,
    pub bodyRanges: ::protobuf::RepeatedField<DataMessage_BodyRange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Quote {
    fn default() -> &'a DataMessage_Quote {
        <DataMessage_Quote as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Quote {
    pub fn new() -> DataMessage_Quote {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string authorE164 = 2;


    pub fn get_authorE164(&self) -> &str {
        match self.authorE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_authorE164(&mut self) {
        self.authorE164.clear();
    }

    pub fn has_authorE164(&self) -> bool {
        self.authorE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorE164(&mut self, v: ::std::string::String) {
        self.authorE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorE164(&mut self) -> &mut ::std::string::String {
        if self.authorE164.is_none() {
            self.authorE164.set_default();
        }
        self.authorE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorE164(&mut self) -> ::std::string::String {
        self.authorE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string authorUuid = 5;


    pub fn get_authorUuid(&self) -> &str {
        match self.authorUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_authorUuid(&mut self) {
        self.authorUuid.clear();
    }

    pub fn has_authorUuid(&self) -> bool {
        self.authorUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorUuid(&mut self, v: ::std::string::String) {
        self.authorUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorUuid(&mut self) -> &mut ::std::string::String {
        if self.authorUuid.is_none() {
            self.authorUuid.set_default();
        }
        self.authorUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorUuid(&mut self) -> ::std::string::String {
        self.authorUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 3;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .signalservice.DataMessage.Quote.QuotedAttachment attachments = 4;


    pub fn get_attachments(&self) -> &[DataMessage_Quote_QuotedAttachment] {
        &self.attachments
    }
    pub fn clear_attachments(&mut self) {
        self.attachments.clear();
    }

    // Param is passed by value, moved
    pub fn set_attachments(&mut self, v: ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment>) {
        self.attachments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attachments(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment> {
        &mut self.attachments
    }

    // Take field
    pub fn take_attachments(&mut self) -> ::protobuf::RepeatedField<DataMessage_Quote_QuotedAttachment> {
        ::std::mem::replace(&mut self.attachments, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.BodyRange bodyRanges = 6;


    pub fn get_bodyRanges(&self) -> &[DataMessage_BodyRange] {
        &self.bodyRanges
    }
    pub fn clear_bodyRanges(&mut self) {
        self.bodyRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_bodyRanges(&mut self, v: ::protobuf::RepeatedField<DataMessage_BodyRange>) {
        self.bodyRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bodyRanges(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_BodyRange> {
        &mut self.bodyRanges
    }

    // Take field
    pub fn take_bodyRanges(&mut self) -> ::protobuf::RepeatedField<DataMessage_BodyRange> {
        ::std::mem::replace(&mut self.bodyRanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DataMessage_Quote {
    fn is_initialized(&self) -> bool {
        for v in &self.attachments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bodyRanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorE164)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorUuid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attachments)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bodyRanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.authorE164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.authorUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.bodyRanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.authorE164.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.authorUuid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.attachments {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.bodyRanges {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Quote {
        DataMessage_Quote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &DataMessage_Quote| { &m.id },
                |m: &mut DataMessage_Quote| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorE164",
                |m: &DataMessage_Quote| { &m.authorE164 },
                |m: &mut DataMessage_Quote| { &mut m.authorE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorUuid",
                |m: &DataMessage_Quote| { &m.authorUuid },
                |m: &mut DataMessage_Quote| { &mut m.authorUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &DataMessage_Quote| { &m.text },
                |m: &mut DataMessage_Quote| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Quote_QuotedAttachment>>(
                "attachments",
                |m: &DataMessage_Quote| { &m.attachments },
                |m: &mut DataMessage_Quote| { &mut m.attachments },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_BodyRange>>(
                "bodyRanges",
                |m: &DataMessage_Quote| { &m.bodyRanges },
                |m: &mut DataMessage_Quote| { &mut m.bodyRanges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Quote>(
                "DataMessage.Quote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Quote {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Quote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Quote::new)
    }
}

impl ::protobuf::Clear for DataMessage_Quote {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.authorE164.clear();
        self.authorUuid.clear();
        self.text.clear();
        self.attachments.clear();
        self.bodyRanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Quote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Quote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Quote_QuotedAttachment {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    fileName: ::protobuf::SingularField<::std::string::String>,
    pub thumbnail: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Quote_QuotedAttachment {
    fn default() -> &'a DataMessage_Quote_QuotedAttachment {
        <DataMessage_Quote_QuotedAttachment as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Quote_QuotedAttachment {
    pub fn new() -> DataMessage_Quote_QuotedAttachment {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fileName = 2;


    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fileName(&mut self) {
        self.fileName.clear();
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName.set_default();
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.AttachmentPointer thumbnail = 3;


    pub fn get_thumbnail(&self) -> &AttachmentPointer {
        self.thumbnail.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_thumbnail(&mut self) {
        self.thumbnail.clear();
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: AttachmentPointer) {
        self.thumbnail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut AttachmentPointer {
        if self.thumbnail.is_none() {
            self.thumbnail.set_default();
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> AttachmentPointer {
        self.thumbnail.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for DataMessage_Quote_QuotedAttachment {
    fn is_initialized(&self) -> bool {
        for v in &self.thumbnail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.thumbnail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fileName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Quote_QuotedAttachment {
        DataMessage_Quote_QuotedAttachment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.contentType },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fileName",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.fileName },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "thumbnail",
                |m: &DataMessage_Quote_QuotedAttachment| { &m.thumbnail },
                |m: &mut DataMessage_Quote_QuotedAttachment| { &mut m.thumbnail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Quote_QuotedAttachment>(
                "DataMessage.Quote.QuotedAttachment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Quote_QuotedAttachment {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Quote_QuotedAttachment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Quote_QuotedAttachment::new)
    }
}

impl ::protobuf::Clear for DataMessage_Quote_QuotedAttachment {
    fn clear(&mut self) {
        self.contentType.clear();
        self.fileName.clear();
        self.thumbnail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Quote_QuotedAttachment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Quote_QuotedAttachment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact {
    // message fields
    pub name: ::protobuf::SingularPtrField<DataMessage_Contact_Name>,
    pub number: ::protobuf::RepeatedField<DataMessage_Contact_Phone>,
    pub email: ::protobuf::RepeatedField<DataMessage_Contact_Email>,
    pub address: ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress>,
    pub avatar: ::protobuf::SingularPtrField<DataMessage_Contact_Avatar>,
    organization: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact {
    fn default() -> &'a DataMessage_Contact {
        <DataMessage_Contact as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact {
    pub fn new() -> DataMessage_Contact {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Contact.Name name = 1;


    pub fn get_name(&self) -> &DataMessage_Contact_Name {
        self.name.as_ref().unwrap_or_else(|| <DataMessage_Contact_Name as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: DataMessage_Contact_Name) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut DataMessage_Contact_Name {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> DataMessage_Contact_Name {
        self.name.take().unwrap_or_else(|| DataMessage_Contact_Name::new())
    }

    // repeated .signalservice.DataMessage.Contact.Phone number = 3;


    pub fn get_number(&self) -> &[DataMessage_Contact_Phone] {
        &self.number
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_Phone>) {
        self.number = v;
    }

    // Mutable pointer to the field.
    pub fn mut_number(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_Phone> {
        &mut self.number
    }

    // Take field
    pub fn take_number(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_Phone> {
        ::std::mem::replace(&mut self.number, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Contact.Email email = 4;


    pub fn get_email(&self) -> &[DataMessage_Contact_Email] {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_Email>) {
        self.email = v;
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_Email> {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_Email> {
        ::std::mem::replace(&mut self.email, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.DataMessage.Contact.PostalAddress address = 5;


    pub fn get_address(&self) -> &[DataMessage_Contact_PostalAddress] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::protobuf::RepeatedField<DataMessage_Contact_PostalAddress> {
        ::std::mem::replace(&mut self.address, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.DataMessage.Contact.Avatar avatar = 6;


    pub fn get_avatar(&self) -> &DataMessage_Contact_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <DataMessage_Contact_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: DataMessage_Contact_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut DataMessage_Contact_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> DataMessage_Contact_Avatar {
        self.avatar.take().unwrap_or_else(|| DataMessage_Contact_Avatar::new())
    }

    // optional string organization = 7;


    pub fn get_organization(&self) -> &str {
        match self.organization.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_organization(&mut self) {
        self.organization.clear();
    }

    pub fn has_organization(&self) -> bool {
        self.organization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_organization(&mut self, v: ::std::string::String) {
        self.organization = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organization(&mut self) -> &mut ::std::string::String {
        if self.organization.is_none() {
            self.organization.set_default();
        }
        self.organization.as_mut().unwrap()
    }

    // Take field
    pub fn take_organization(&mut self) -> ::std::string::String {
        self.organization.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.number {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.email {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.number)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.email)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.organization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.number {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.email {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.address {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.organization.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.number {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.email {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.address {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.organization.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact {
        DataMessage_Contact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Name>>(
                "name",
                |m: &DataMessage_Contact| { &m.name },
                |m: &mut DataMessage_Contact| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Phone>>(
                "number",
                |m: &DataMessage_Contact| { &m.number },
                |m: &mut DataMessage_Contact| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Email>>(
                "email",
                |m: &DataMessage_Contact| { &m.email },
                |m: &mut DataMessage_Contact| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_PostalAddress>>(
                "address",
                |m: &DataMessage_Contact| { &m.address },
                |m: &mut DataMessage_Contact| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage_Contact_Avatar>>(
                "avatar",
                |m: &DataMessage_Contact| { &m.avatar },
                |m: &mut DataMessage_Contact| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organization",
                |m: &DataMessage_Contact| { &m.organization },
                |m: &mut DataMessage_Contact| { &mut m.organization },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact>(
                "DataMessage.Contact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact {
    fn clear(&mut self) {
        self.name.clear();
        self.number.clear();
        self.email.clear();
        self.address.clear();
        self.avatar.clear();
        self.organization.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Name {
    // message fields
    givenName: ::protobuf::SingularField<::std::string::String>,
    familyName: ::protobuf::SingularField<::std::string::String>,
    prefix: ::protobuf::SingularField<::std::string::String>,
    suffix: ::protobuf::SingularField<::std::string::String>,
    middleName: ::protobuf::SingularField<::std::string::String>,
    displayName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Name {
    fn default() -> &'a DataMessage_Contact_Name {
        <DataMessage_Contact_Name as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Name {
    pub fn new() -> DataMessage_Contact_Name {
        ::std::default::Default::default()
    }

    // optional string givenName = 1;


    pub fn get_givenName(&self) -> &str {
        match self.givenName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_givenName(&mut self) {
        self.givenName.clear();
    }

    pub fn has_givenName(&self) -> bool {
        self.givenName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_givenName(&mut self, v: ::std::string::String) {
        self.givenName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_givenName(&mut self) -> &mut ::std::string::String {
        if self.givenName.is_none() {
            self.givenName.set_default();
        }
        self.givenName.as_mut().unwrap()
    }

    // Take field
    pub fn take_givenName(&mut self) -> ::std::string::String {
        self.givenName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string familyName = 2;


    pub fn get_familyName(&self) -> &str {
        match self.familyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_familyName(&mut self) {
        self.familyName.clear();
    }

    pub fn has_familyName(&self) -> bool {
        self.familyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_familyName(&mut self, v: ::std::string::String) {
        self.familyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_familyName(&mut self) -> &mut ::std::string::String {
        if self.familyName.is_none() {
            self.familyName.set_default();
        }
        self.familyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_familyName(&mut self) -> ::std::string::String {
        self.familyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string prefix = 3;


    pub fn get_prefix(&self) -> &str {
        match self.prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if self.prefix.is_none() {
            self.prefix.set_default();
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        self.prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string suffix = 4;


    pub fn get_suffix(&self) -> &str {
        match self.suffix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    pub fn has_suffix(&self) -> bool {
        self.suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        if self.suffix.is_none() {
            self.suffix.set_default();
        }
        self.suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        self.suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string middleName = 5;


    pub fn get_middleName(&self) -> &str {
        match self.middleName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_middleName(&mut self) {
        self.middleName.clear();
    }

    pub fn has_middleName(&self) -> bool {
        self.middleName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_middleName(&mut self, v: ::std::string::String) {
        self.middleName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_middleName(&mut self) -> &mut ::std::string::String {
        if self.middleName.is_none() {
            self.middleName.set_default();
        }
        self.middleName.as_mut().unwrap()
    }

    // Take field
    pub fn take_middleName(&mut self) -> ::std::string::String {
        self.middleName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string displayName = 6;


    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_displayName(&mut self) {
        self.displayName.clear();
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName.set_default();
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Name {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.givenName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.familyName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefix)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suffix)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.middleName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.givenName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.familyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.middleName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.givenName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.familyName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.prefix.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.suffix.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.middleName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.displayName.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Name {
        DataMessage_Contact_Name::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "givenName",
                |m: &DataMessage_Contact_Name| { &m.givenName },
                |m: &mut DataMessage_Contact_Name| { &mut m.givenName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "familyName",
                |m: &DataMessage_Contact_Name| { &m.familyName },
                |m: &mut DataMessage_Contact_Name| { &mut m.familyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &DataMessage_Contact_Name| { &m.prefix },
                |m: &mut DataMessage_Contact_Name| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suffix",
                |m: &DataMessage_Contact_Name| { &m.suffix },
                |m: &mut DataMessage_Contact_Name| { &mut m.suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "middleName",
                |m: &DataMessage_Contact_Name| { &m.middleName },
                |m: &mut DataMessage_Contact_Name| { &mut m.middleName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayName",
                |m: &DataMessage_Contact_Name| { &m.displayName },
                |m: &mut DataMessage_Contact_Name| { &mut m.displayName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Name>(
                "DataMessage.Contact.Name",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Name {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Name> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Name::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Name {
    fn clear(&mut self) {
        self.givenName.clear();
        self.familyName.clear();
        self.prefix.clear();
        self.suffix.clear();
        self.middleName.clear();
        self.displayName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Name {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Name {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Phone {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DataMessage_Contact_Phone_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Phone {
    fn default() -> &'a DataMessage_Contact_Phone {
        <DataMessage_Contact_Phone as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Phone {
    pub fn new() -> DataMessage_Contact_Phone {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.DataMessage.Contact.Phone.Type type = 2;


    pub fn get_field_type(&self) -> DataMessage_Contact_Phone_Type {
        self.field_type.unwrap_or(DataMessage_Contact_Phone_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_Phone_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 3;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Phone {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Phone {
        DataMessage_Contact_Phone::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &DataMessage_Contact_Phone| { &m.value },
                |m: &mut DataMessage_Contact_Phone| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_Phone_Type>>(
                "type",
                |m: &DataMessage_Contact_Phone| { &m.field_type },
                |m: &mut DataMessage_Contact_Phone| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_Phone| { &m.label },
                |m: &mut DataMessage_Contact_Phone| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Phone>(
                "DataMessage.Contact.Phone",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Phone {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Phone> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Phone::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Phone {
    fn clear(&mut self) {
        self.value.clear();
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Phone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Phone {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_Phone_Type {
    HOME = 1,
    MOBILE = 2,
    WORK = 3,
    CUSTOM = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_Phone_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_Phone_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::MOBILE),
            3 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::WORK),
            4 => ::std::option::Option::Some(DataMessage_Contact_Phone_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_Phone_Type] = &[
            DataMessage_Contact_Phone_Type::HOME,
            DataMessage_Contact_Phone_Type::MOBILE,
            DataMessage_Contact_Phone_Type::WORK,
            DataMessage_Contact_Phone_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_Phone_Type>("DataMessage.Contact.Phone.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_Phone_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_Phone_Type {
    fn default() -> Self {
        DataMessage_Contact_Phone_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Phone_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Email {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DataMessage_Contact_Email_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Email {
    fn default() -> &'a DataMessage_Contact_Email {
        <DataMessage_Contact_Email as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Email {
    pub fn new() -> DataMessage_Contact_Email {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.DataMessage.Contact.Email.Type type = 2;


    pub fn get_field_type(&self) -> DataMessage_Contact_Email_Type {
        self.field_type.unwrap_or(DataMessage_Contact_Email_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_Email_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 3;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_Email {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Email {
        DataMessage_Contact_Email::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &DataMessage_Contact_Email| { &m.value },
                |m: &mut DataMessage_Contact_Email| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_Email_Type>>(
                "type",
                |m: &DataMessage_Contact_Email| { &m.field_type },
                |m: &mut DataMessage_Contact_Email| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_Email| { &m.label },
                |m: &mut DataMessage_Contact_Email| { &mut m.label },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Email>(
                "DataMessage.Contact.Email",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Email {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Email> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Email::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Email {
    fn clear(&mut self) {
        self.value.clear();
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Email {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Email {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_Email_Type {
    HOME = 1,
    MOBILE = 2,
    WORK = 3,
    CUSTOM = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_Email_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_Email_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::MOBILE),
            3 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::WORK),
            4 => ::std::option::Option::Some(DataMessage_Contact_Email_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_Email_Type] = &[
            DataMessage_Contact_Email_Type::HOME,
            DataMessage_Contact_Email_Type::MOBILE,
            DataMessage_Contact_Email_Type::WORK,
            DataMessage_Contact_Email_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_Email_Type>("DataMessage.Contact.Email.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_Email_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_Email_Type {
    fn default() -> Self {
        DataMessage_Contact_Email_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Email_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_PostalAddress {
    // message fields
    field_type: ::std::option::Option<DataMessage_Contact_PostalAddress_Type>,
    label: ::protobuf::SingularField<::std::string::String>,
    street: ::protobuf::SingularField<::std::string::String>,
    pobox: ::protobuf::SingularField<::std::string::String>,
    neighborhood: ::protobuf::SingularField<::std::string::String>,
    city: ::protobuf::SingularField<::std::string::String>,
    region: ::protobuf::SingularField<::std::string::String>,
    postcode: ::protobuf::SingularField<::std::string::String>,
    country: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_PostalAddress {
    fn default() -> &'a DataMessage_Contact_PostalAddress {
        <DataMessage_Contact_PostalAddress as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_PostalAddress {
    pub fn new() -> DataMessage_Contact_PostalAddress {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Contact.PostalAddress.Type type = 1;


    pub fn get_field_type(&self) -> DataMessage_Contact_PostalAddress_Type {
        self.field_type.unwrap_or(DataMessage_Contact_PostalAddress_Type::HOME)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataMessage_Contact_PostalAddress_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string label = 2;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string street = 3;


    pub fn get_street(&self) -> &str {
        match self.street.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_street(&mut self) {
        self.street.clear();
    }

    pub fn has_street(&self) -> bool {
        self.street.is_some()
    }

    // Param is passed by value, moved
    pub fn set_street(&mut self, v: ::std::string::String) {
        self.street = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_street(&mut self) -> &mut ::std::string::String {
        if self.street.is_none() {
            self.street.set_default();
        }
        self.street.as_mut().unwrap()
    }

    // Take field
    pub fn take_street(&mut self) -> ::std::string::String {
        self.street.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pobox = 4;


    pub fn get_pobox(&self) -> &str {
        match self.pobox.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pobox(&mut self) {
        self.pobox.clear();
    }

    pub fn has_pobox(&self) -> bool {
        self.pobox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pobox(&mut self, v: ::std::string::String) {
        self.pobox = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pobox(&mut self) -> &mut ::std::string::String {
        if self.pobox.is_none() {
            self.pobox.set_default();
        }
        self.pobox.as_mut().unwrap()
    }

    // Take field
    pub fn take_pobox(&mut self) -> ::std::string::String {
        self.pobox.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string neighborhood = 5;


    pub fn get_neighborhood(&self) -> &str {
        match self.neighborhood.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_neighborhood(&mut self) {
        self.neighborhood.clear();
    }

    pub fn has_neighborhood(&self) -> bool {
        self.neighborhood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neighborhood(&mut self, v: ::std::string::String) {
        self.neighborhood = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighborhood(&mut self) -> &mut ::std::string::String {
        if self.neighborhood.is_none() {
            self.neighborhood.set_default();
        }
        self.neighborhood.as_mut().unwrap()
    }

    // Take field
    pub fn take_neighborhood(&mut self) -> ::std::string::String {
        self.neighborhood.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 6;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city.set_default();
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 7;


    pub fn get_region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;


    pub fn get_postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_postcode(&mut self) {
        self.postcode.clear();
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode.set_default();
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country = 9;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Contact_PostalAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.street)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pobox)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.neighborhood)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.region)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postcode)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.street.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pobox.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.neighborhood.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.postcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.street.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pobox.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.neighborhood.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.region.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.postcode.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_PostalAddress {
        DataMessage_Contact_PostalAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataMessage_Contact_PostalAddress_Type>>(
                "type",
                |m: &DataMessage_Contact_PostalAddress| { &m.field_type },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &DataMessage_Contact_PostalAddress| { &m.label },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "street",
                |m: &DataMessage_Contact_PostalAddress| { &m.street },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.street },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pobox",
                |m: &DataMessage_Contact_PostalAddress| { &m.pobox },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.pobox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "neighborhood",
                |m: &DataMessage_Contact_PostalAddress| { &m.neighborhood },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.neighborhood },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &DataMessage_Contact_PostalAddress| { &m.city },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "region",
                |m: &DataMessage_Contact_PostalAddress| { &m.region },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postcode",
                |m: &DataMessage_Contact_PostalAddress| { &m.postcode },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.postcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &DataMessage_Contact_PostalAddress| { &m.country },
                |m: &mut DataMessage_Contact_PostalAddress| { &mut m.country },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_PostalAddress>(
                "DataMessage.Contact.PostalAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_PostalAddress {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_PostalAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_PostalAddress::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_PostalAddress {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.label.clear();
        self.street.clear();
        self.pobox.clear();
        self.neighborhood.clear();
        self.city.clear();
        self.region.clear();
        self.postcode.clear();
        self.country.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_PostalAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_PostalAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Contact_PostalAddress_Type {
    HOME = 1,
    WORK = 2,
    CUSTOM = 3,
}

impl ::protobuf::ProtobufEnum for DataMessage_Contact_PostalAddress_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Contact_PostalAddress_Type> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::HOME),
            2 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::WORK),
            3 => ::std::option::Option::Some(DataMessage_Contact_PostalAddress_Type::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Contact_PostalAddress_Type] = &[
            DataMessage_Contact_PostalAddress_Type::HOME,
            DataMessage_Contact_PostalAddress_Type::WORK,
            DataMessage_Contact_PostalAddress_Type::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Contact_PostalAddress_Type>("DataMessage.Contact.PostalAddress.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Contact_PostalAddress_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Contact_PostalAddress_Type {
    fn default() -> Self {
        DataMessage_Contact_PostalAddress_Type::HOME
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_PostalAddress_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Contact_Avatar {
    // message fields
    pub avatar: ::protobuf::SingularPtrField<AttachmentPointer>,
    isProfile: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Contact_Avatar {
    fn default() -> &'a DataMessage_Contact_Avatar {
        <DataMessage_Contact_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Contact_Avatar {
    pub fn new() -> DataMessage_Contact_Avatar {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer avatar = 1;


    pub fn get_avatar(&self) -> &AttachmentPointer {
        self.avatar.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: AttachmentPointer) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut AttachmentPointer {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> AttachmentPointer {
        self.avatar.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional bool isProfile = 2;


    pub fn get_isProfile(&self) -> bool {
        self.isProfile.unwrap_or(false)
    }
    pub fn clear_isProfile(&mut self) {
        self.isProfile = ::std::option::Option::None;
    }

    pub fn has_isProfile(&self) -> bool {
        self.isProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isProfile(&mut self, v: bool) {
        self.isProfile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Contact_Avatar {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isProfile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isProfile {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isProfile {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Contact_Avatar {
        DataMessage_Contact_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "avatar",
                |m: &DataMessage_Contact_Avatar| { &m.avatar },
                |m: &mut DataMessage_Contact_Avatar| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isProfile",
                |m: &DataMessage_Contact_Avatar| { &m.isProfile },
                |m: &mut DataMessage_Contact_Avatar| { &mut m.isProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Contact_Avatar>(
                "DataMessage.Contact.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Contact_Avatar {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Contact_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Contact_Avatar::new)
    }
}

impl ::protobuf::Clear for DataMessage_Contact_Avatar {
    fn clear(&mut self) {
        self.avatar.clear();
        self.isProfile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Contact_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Contact_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Preview {
    // message fields
    url: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<AttachmentPointer>,
    description: ::protobuf::SingularField<::std::string::String>,
    date: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Preview {
    fn default() -> &'a DataMessage_Preview {
        <DataMessage_Preview as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Preview {
    pub fn new() -> DataMessage_Preview {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.AttachmentPointer image = 3;


    pub fn get_image(&self) -> &AttachmentPointer {
        self.image.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: AttachmentPointer) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut AttachmentPointer {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> AttachmentPointer {
        self.image.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional string description = 4;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 date = 5;


    pub fn get_date(&self) -> u64 {
        self.date.unwrap_or(0)
    }
    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u64) {
        self.date = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Preview {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.date {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.date {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Preview {
        DataMessage_Preview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &DataMessage_Preview| { &m.url },
                |m: &mut DataMessage_Preview| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DataMessage_Preview| { &m.title },
                |m: &mut DataMessage_Preview| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "image",
                |m: &DataMessage_Preview| { &m.image },
                |m: &mut DataMessage_Preview| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &DataMessage_Preview| { &m.description },
                |m: &mut DataMessage_Preview| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "date",
                |m: &DataMessage_Preview| { &m.date },
                |m: &mut DataMessage_Preview| { &mut m.date },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Preview>(
                "DataMessage.Preview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Preview {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Preview> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Preview::new)
    }
}

impl ::protobuf::Clear for DataMessage_Preview {
    fn clear(&mut self) {
        self.url.clear();
        self.title.clear();
        self.image.clear();
        self.description.clear();
        self.date = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Preview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Preview {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Sticker {
    // message fields
    packId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    packKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    stickerId: ::std::option::Option<u32>,
    pub data: ::protobuf::SingularPtrField<AttachmentPointer>,
    emoji: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Sticker {
    fn default() -> &'a DataMessage_Sticker {
        <DataMessage_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Sticker {
    pub fn new() -> DataMessage_Sticker {
        ::std::default::Default::default()
    }

    // optional bytes packId = 1;


    pub fn get_packId(&self) -> &[u8] {
        match self.packId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packId(&mut self) {
        self.packId.clear();
    }

    pub fn has_packId(&self) -> bool {
        self.packId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packId(&mut self, v: ::std::vec::Vec<u8>) {
        self.packId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packId.is_none() {
            self.packId.set_default();
        }
        self.packId.as_mut().unwrap()
    }

    // Take field
    pub fn take_packId(&mut self) -> ::std::vec::Vec<u8> {
        self.packId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes packKey = 2;


    pub fn get_packKey(&self) -> &[u8] {
        match self.packKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packKey(&mut self) {
        self.packKey.clear();
    }

    pub fn has_packKey(&self) -> bool {
        self.packKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.packKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packKey.is_none() {
            self.packKey.set_default();
        }
        self.packKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_packKey(&mut self) -> ::std::vec::Vec<u8> {
        self.packKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 stickerId = 3;


    pub fn get_stickerId(&self) -> u32 {
        self.stickerId.unwrap_or(0)
    }
    pub fn clear_stickerId(&mut self) {
        self.stickerId = ::std::option::Option::None;
    }

    pub fn has_stickerId(&self) -> bool {
        self.stickerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerId(&mut self, v: u32) {
        self.stickerId = ::std::option::Option::Some(v);
    }

    // optional .signalservice.AttachmentPointer data = 4;


    pub fn get_data(&self) -> &AttachmentPointer {
        self.data.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: AttachmentPointer) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut AttachmentPointer {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> AttachmentPointer {
        self.data.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional string emoji = 5;


    pub fn get_emoji(&self) -> &str {
        match self.emoji.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_emoji(&mut self) {
        self.emoji.clear();
    }

    pub fn has_emoji(&self) -> bool {
        self.emoji.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoji(&mut self, v: ::std::string::String) {
        self.emoji = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoji(&mut self) -> &mut ::std::string::String {
        if self.emoji.is_none() {
            self.emoji.set_default();
        }
        self.emoji.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoji(&mut self) -> ::std::string::String {
        self.emoji.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Sticker {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packKey)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stickerId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.emoji)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.packKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.stickerId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.emoji.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packId.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.packKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.stickerId {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.emoji.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Sticker {
        DataMessage_Sticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packId",
                |m: &DataMessage_Sticker| { &m.packId },
                |m: &mut DataMessage_Sticker| { &mut m.packId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packKey",
                |m: &DataMessage_Sticker| { &m.packKey },
                |m: &mut DataMessage_Sticker| { &mut m.packKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stickerId",
                |m: &DataMessage_Sticker| { &m.stickerId },
                |m: &mut DataMessage_Sticker| { &mut m.stickerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "data",
                |m: &DataMessage_Sticker| { &m.data },
                |m: &mut DataMessage_Sticker| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emoji",
                |m: &DataMessage_Sticker| { &m.emoji },
                |m: &mut DataMessage_Sticker| { &mut m.emoji },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Sticker>(
                "DataMessage.Sticker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Sticker {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Sticker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Sticker::new)
    }
}

impl ::protobuf::Clear for DataMessage_Sticker {
    fn clear(&mut self) {
        self.packId.clear();
        self.packKey.clear();
        self.stickerId = ::std::option::Option::None;
        self.data.clear();
        self.emoji.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Reaction {
    // message fields
    emoji: ::protobuf::SingularField<::std::string::String>,
    remove: ::std::option::Option<bool>,
    targetAuthorUuid: ::protobuf::SingularField<::std::string::String>,
    targetSentTimestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Reaction {
    fn default() -> &'a DataMessage_Reaction {
        <DataMessage_Reaction as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Reaction {
    pub fn new() -> DataMessage_Reaction {
        ::std::default::Default::default()
    }

    // optional string emoji = 1;


    pub fn get_emoji(&self) -> &str {
        match self.emoji.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_emoji(&mut self) {
        self.emoji.clear();
    }

    pub fn has_emoji(&self) -> bool {
        self.emoji.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoji(&mut self, v: ::std::string::String) {
        self.emoji = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoji(&mut self) -> &mut ::std::string::String {
        if self.emoji.is_none() {
            self.emoji.set_default();
        }
        self.emoji.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoji(&mut self) -> ::std::string::String {
        self.emoji.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remove = 2;


    pub fn get_remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }
    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }

    // optional string targetAuthorUuid = 4;


    pub fn get_targetAuthorUuid(&self) -> &str {
        match self.targetAuthorUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetAuthorUuid(&mut self) {
        self.targetAuthorUuid.clear();
    }

    pub fn has_targetAuthorUuid(&self) -> bool {
        self.targetAuthorUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetAuthorUuid(&mut self, v: ::std::string::String) {
        self.targetAuthorUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAuthorUuid(&mut self) -> &mut ::std::string::String {
        if self.targetAuthorUuid.is_none() {
            self.targetAuthorUuid.set_default();
        }
        self.targetAuthorUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetAuthorUuid(&mut self) -> ::std::string::String {
        self.targetAuthorUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 targetSentTimestamp = 5;


    pub fn get_targetSentTimestamp(&self) -> u64 {
        self.targetSentTimestamp.unwrap_or(0)
    }
    pub fn clear_targetSentTimestamp(&mut self) {
        self.targetSentTimestamp = ::std::option::Option::None;
    }

    pub fn has_targetSentTimestamp(&self) -> bool {
        self.targetSentTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetSentTimestamp(&mut self, v: u64) {
        self.targetSentTimestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Reaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.emoji)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetAuthorUuid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.targetSentTimestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.emoji.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.remove {
            my_size += 2;
        }
        if let Some(ref v) = self.targetAuthorUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.targetSentTimestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.emoji.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.remove {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.targetAuthorUuid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.targetSentTimestamp {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Reaction {
        DataMessage_Reaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emoji",
                |m: &DataMessage_Reaction| { &m.emoji },
                |m: &mut DataMessage_Reaction| { &mut m.emoji },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remove",
                |m: &DataMessage_Reaction| { &m.remove },
                |m: &mut DataMessage_Reaction| { &mut m.remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAuthorUuid",
                |m: &DataMessage_Reaction| { &m.targetAuthorUuid },
                |m: &mut DataMessage_Reaction| { &mut m.targetAuthorUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "targetSentTimestamp",
                |m: &DataMessage_Reaction| { &m.targetSentTimestamp },
                |m: &mut DataMessage_Reaction| { &mut m.targetSentTimestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Reaction>(
                "DataMessage.Reaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Reaction {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Reaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Reaction::new)
    }
}

impl ::protobuf::Clear for DataMessage_Reaction {
    fn clear(&mut self) {
        self.emoji.clear();
        self.remove = ::std::option::Option::None;
        self.targetAuthorUuid.clear();
        self.targetSentTimestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Reaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Reaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Delete {
    // message fields
    targetSentTimestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Delete {
    fn default() -> &'a DataMessage_Delete {
        <DataMessage_Delete as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Delete {
    pub fn new() -> DataMessage_Delete {
        ::std::default::Default::default()
    }

    // optional uint64 targetSentTimestamp = 1;


    pub fn get_targetSentTimestamp(&self) -> u64 {
        self.targetSentTimestamp.unwrap_or(0)
    }
    pub fn clear_targetSentTimestamp(&mut self) {
        self.targetSentTimestamp = ::std::option::Option::None;
    }

    pub fn has_targetSentTimestamp(&self) -> bool {
        self.targetSentTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetSentTimestamp(&mut self, v: u64) {
        self.targetSentTimestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Delete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.targetSentTimestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.targetSentTimestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.targetSentTimestamp {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Delete {
        DataMessage_Delete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "targetSentTimestamp",
                |m: &DataMessage_Delete| { &m.targetSentTimestamp },
                |m: &mut DataMessage_Delete| { &mut m.targetSentTimestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Delete>(
                "DataMessage.Delete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Delete {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Delete> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Delete::new)
    }
}

impl ::protobuf::Clear for DataMessage_Delete {
    fn clear(&mut self) {
        self.targetSentTimestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Delete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Delete {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_GroupCallUpdate {
    // message fields
    eraId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_GroupCallUpdate {
    fn default() -> &'a DataMessage_GroupCallUpdate {
        <DataMessage_GroupCallUpdate as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_GroupCallUpdate {
    pub fn new() -> DataMessage_GroupCallUpdate {
        ::std::default::Default::default()
    }

    // optional string eraId = 1;


    pub fn get_eraId(&self) -> &str {
        match self.eraId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_eraId(&mut self) {
        self.eraId.clear();
    }

    pub fn has_eraId(&self) -> bool {
        self.eraId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eraId(&mut self, v: ::std::string::String) {
        self.eraId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eraId(&mut self) -> &mut ::std::string::String {
        if self.eraId.is_none() {
            self.eraId.set_default();
        }
        self.eraId.as_mut().unwrap()
    }

    // Take field
    pub fn take_eraId(&mut self) -> ::std::string::String {
        self.eraId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_GroupCallUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.eraId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eraId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eraId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_GroupCallUpdate {
        DataMessage_GroupCallUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "eraId",
                |m: &DataMessage_GroupCallUpdate| { &m.eraId },
                |m: &mut DataMessage_GroupCallUpdate| { &mut m.eraId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_GroupCallUpdate>(
                "DataMessage.GroupCallUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_GroupCallUpdate {
        static instance: ::protobuf::rt::LazyV2<DataMessage_GroupCallUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_GroupCallUpdate::new)
    }
}

impl ::protobuf::Clear for DataMessage_GroupCallUpdate {
    fn clear(&mut self) {
        self.eraId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_GroupCallUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_GroupCallUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment {
    // message oneof groups
    pub Item: ::std::option::Option<DataMessage_Payment_oneof_Item>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment {
    fn default() -> &'a DataMessage_Payment {
        <DataMessage_Payment as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Payment_oneof_Item {
    notification(DataMessage_Payment_Notification),
}

impl DataMessage_Payment {
    pub fn new() -> DataMessage_Payment {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Payment.Notification notification = 1;


    pub fn get_notification(&self) -> &DataMessage_Payment_Notification {
        match self.Item {
            ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(ref v)) => v,
            _ => <DataMessage_Payment_Notification as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_notification(&mut self) {
        self.Item = ::std::option::Option::None;
    }

    pub fn has_notification(&self) -> bool {
        match self.Item {
            ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: DataMessage_Payment_Notification) {
        self.Item = ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notification(&mut self) -> &mut DataMessage_Payment_Notification {
        if let ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(_)) = self.Item {
        } else {
            self.Item = ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(DataMessage_Payment_Notification::new()));
        }
        match self.Item {
            ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notification(&mut self) -> DataMessage_Payment_Notification {
        if self.has_notification() {
            match self.Item.take() {
                ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(v)) => v,
                _ => panic!(),
            }
        } else {
            DataMessage_Payment_Notification::new()
        }
    }
}

impl ::protobuf::Message for DataMessage_Payment {
    fn is_initialized(&self) -> bool {
        if let Some(DataMessage_Payment_oneof_Item::notification(ref v)) = self.Item {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Item = ::std::option::Option::Some(DataMessage_Payment_oneof_Item::notification(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Item {
            match v {
                &DataMessage_Payment_oneof_Item::notification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Item {
            match v {
                &DataMessage_Payment_oneof_Item::notification(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment {
        DataMessage_Payment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataMessage_Payment_Notification>(
                "notification",
                DataMessage_Payment::has_notification,
                DataMessage_Payment::get_notification,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment>(
                "DataMessage.Payment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment {
    fn clear(&mut self) {
        self.Item = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Address {
    // message oneof groups
    pub Address: ::std::option::Option<DataMessage_Payment_Address_oneof_Address>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Address {
    fn default() -> &'a DataMessage_Payment_Address {
        <DataMessage_Payment_Address as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Payment_Address_oneof_Address {
    mobileCoin(DataMessage_Payment_Address_MobileCoin),
}

impl DataMessage_Payment_Address {
    pub fn new() -> DataMessage_Payment_Address {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Payment.Address.MobileCoin mobileCoin = 1;


    pub fn get_mobileCoin(&self) -> &DataMessage_Payment_Address_MobileCoin {
        match self.Address {
            ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(ref v)) => v,
            _ => <DataMessage_Payment_Address_MobileCoin as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mobileCoin(&mut self) {
        self.Address = ::std::option::Option::None;
    }

    pub fn has_mobileCoin(&self) -> bool {
        match self.Address {
            ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mobileCoin(&mut self, v: DataMessage_Payment_Address_MobileCoin) {
        self.Address = ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mobileCoin(&mut self) -> &mut DataMessage_Payment_Address_MobileCoin {
        if let ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(_)) = self.Address {
        } else {
            self.Address = ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(DataMessage_Payment_Address_MobileCoin::new()));
        }
        match self.Address {
            ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mobileCoin(&mut self) -> DataMessage_Payment_Address_MobileCoin {
        if self.has_mobileCoin() {
            match self.Address.take() {
                ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(v)) => v,
                _ => panic!(),
            }
        } else {
            DataMessage_Payment_Address_MobileCoin::new()
        }
    }
}

impl ::protobuf::Message for DataMessage_Payment_Address {
    fn is_initialized(&self) -> bool {
        if let Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(ref v)) = self.Address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Address = ::std::option::Option::Some(DataMessage_Payment_Address_oneof_Address::mobileCoin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Address {
            match v {
                &DataMessage_Payment_Address_oneof_Address::mobileCoin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Address {
            match v {
                &DataMessage_Payment_Address_oneof_Address::mobileCoin(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Address {
        DataMessage_Payment_Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataMessage_Payment_Address_MobileCoin>(
                "mobileCoin",
                DataMessage_Payment_Address::has_mobileCoin,
                DataMessage_Payment_Address::get_mobileCoin,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Address>(
                "DataMessage.Payment.Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Address {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Address::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Address {
    fn clear(&mut self) {
        self.Address = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Address_MobileCoin {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Address_MobileCoin {
    fn default() -> &'a DataMessage_Payment_Address_MobileCoin {
        <DataMessage_Payment_Address_MobileCoin as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Payment_Address_MobileCoin {
    pub fn new() -> DataMessage_Payment_Address_MobileCoin {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataMessage_Payment_Address_MobileCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Address_MobileCoin {
        DataMessage_Payment_Address_MobileCoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &DataMessage_Payment_Address_MobileCoin| { &m.address },
                |m: &mut DataMessage_Payment_Address_MobileCoin| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Address_MobileCoin>(
                "DataMessage.Payment.Address.MobileCoin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Address_MobileCoin {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Address_MobileCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Address_MobileCoin::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Address_MobileCoin {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Address_MobileCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Address_MobileCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Amount {
    // message oneof groups
    pub Amount: ::std::option::Option<DataMessage_Payment_Amount_oneof_Amount>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Amount {
    fn default() -> &'a DataMessage_Payment_Amount {
        <DataMessage_Payment_Amount as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Payment_Amount_oneof_Amount {
    mobileCoin(DataMessage_Payment_Amount_MobileCoin),
}

impl DataMessage_Payment_Amount {
    pub fn new() -> DataMessage_Payment_Amount {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Payment.Amount.MobileCoin mobileCoin = 1;


    pub fn get_mobileCoin(&self) -> &DataMessage_Payment_Amount_MobileCoin {
        match self.Amount {
            ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(ref v)) => v,
            _ => <DataMessage_Payment_Amount_MobileCoin as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mobileCoin(&mut self) {
        self.Amount = ::std::option::Option::None;
    }

    pub fn has_mobileCoin(&self) -> bool {
        match self.Amount {
            ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mobileCoin(&mut self, v: DataMessage_Payment_Amount_MobileCoin) {
        self.Amount = ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mobileCoin(&mut self) -> &mut DataMessage_Payment_Amount_MobileCoin {
        if let ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(_)) = self.Amount {
        } else {
            self.Amount = ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(DataMessage_Payment_Amount_MobileCoin::new()));
        }
        match self.Amount {
            ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mobileCoin(&mut self) -> DataMessage_Payment_Amount_MobileCoin {
        if self.has_mobileCoin() {
            match self.Amount.take() {
                ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(v)) => v,
                _ => panic!(),
            }
        } else {
            DataMessage_Payment_Amount_MobileCoin::new()
        }
    }
}

impl ::protobuf::Message for DataMessage_Payment_Amount {
    fn is_initialized(&self) -> bool {
        if let Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(ref v)) = self.Amount {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Amount = ::std::option::Option::Some(DataMessage_Payment_Amount_oneof_Amount::mobileCoin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Amount {
            match v {
                &DataMessage_Payment_Amount_oneof_Amount::mobileCoin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Amount {
            match v {
                &DataMessage_Payment_Amount_oneof_Amount::mobileCoin(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Amount {
        DataMessage_Payment_Amount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataMessage_Payment_Amount_MobileCoin>(
                "mobileCoin",
                DataMessage_Payment_Amount::has_mobileCoin,
                DataMessage_Payment_Amount::get_mobileCoin,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Amount>(
                "DataMessage.Payment.Amount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Amount {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Amount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Amount::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Amount {
    fn clear(&mut self) {
        self.Amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Amount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Amount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Amount_MobileCoin {
    // message fields
    picoMob: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Amount_MobileCoin {
    fn default() -> &'a DataMessage_Payment_Amount_MobileCoin {
        <DataMessage_Payment_Amount_MobileCoin as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Payment_Amount_MobileCoin {
    pub fn new() -> DataMessage_Payment_Amount_MobileCoin {
        ::std::default::Default::default()
    }

    // optional uint64 picoMob = 1;


    pub fn get_picoMob(&self) -> u64 {
        self.picoMob.unwrap_or(0)
    }
    pub fn clear_picoMob(&mut self) {
        self.picoMob = ::std::option::Option::None;
    }

    pub fn has_picoMob(&self) -> bool {
        self.picoMob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picoMob(&mut self, v: u64) {
        self.picoMob = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataMessage_Payment_Amount_MobileCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.picoMob = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.picoMob {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.picoMob {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Amount_MobileCoin {
        DataMessage_Payment_Amount_MobileCoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "picoMob",
                |m: &DataMessage_Payment_Amount_MobileCoin| { &m.picoMob },
                |m: &mut DataMessage_Payment_Amount_MobileCoin| { &mut m.picoMob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Amount_MobileCoin>(
                "DataMessage.Payment.Amount.MobileCoin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Amount_MobileCoin {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Amount_MobileCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Amount_MobileCoin::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Amount_MobileCoin {
    fn clear(&mut self) {
        self.picoMob = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Amount_MobileCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Amount_MobileCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Notification {
    // message fields
    note: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub Transaction: ::std::option::Option<DataMessage_Payment_Notification_oneof_Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Notification {
    fn default() -> &'a DataMessage_Payment_Notification {
        <DataMessage_Payment_Notification as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Payment_Notification_oneof_Transaction {
    mobileCoin(DataMessage_Payment_Notification_MobileCoin),
}

impl DataMessage_Payment_Notification {
    pub fn new() -> DataMessage_Payment_Notification {
        ::std::default::Default::default()
    }

    // optional .signalservice.DataMessage.Payment.Notification.MobileCoin mobileCoin = 1;


    pub fn get_mobileCoin(&self) -> &DataMessage_Payment_Notification_MobileCoin {
        match self.Transaction {
            ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(ref v)) => v,
            _ => <DataMessage_Payment_Notification_MobileCoin as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mobileCoin(&mut self) {
        self.Transaction = ::std::option::Option::None;
    }

    pub fn has_mobileCoin(&self) -> bool {
        match self.Transaction {
            ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mobileCoin(&mut self, v: DataMessage_Payment_Notification_MobileCoin) {
        self.Transaction = ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mobileCoin(&mut self) -> &mut DataMessage_Payment_Notification_MobileCoin {
        if let ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(_)) = self.Transaction {
        } else {
            self.Transaction = ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(DataMessage_Payment_Notification_MobileCoin::new()));
        }
        match self.Transaction {
            ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mobileCoin(&mut self) -> DataMessage_Payment_Notification_MobileCoin {
        if self.has_mobileCoin() {
            match self.Transaction.take() {
                ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(v)) => v,
                _ => panic!(),
            }
        } else {
            DataMessage_Payment_Notification_MobileCoin::new()
        }
    }

    // optional string note = 2;


    pub fn get_note(&self) -> &str {
        match self.note.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        self.note.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataMessage_Payment_Notification {
    fn is_initialized(&self) -> bool {
        if let Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(ref v)) = self.Transaction {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Transaction = ::std::option::Option::Some(DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(is.read_message()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.note)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.Transaction {
            match v {
                &DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_string(2, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Transaction {
            match v {
                &DataMessage_Payment_Notification_oneof_Transaction::mobileCoin(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Notification {
        DataMessage_Payment_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataMessage_Payment_Notification_MobileCoin>(
                "mobileCoin",
                DataMessage_Payment_Notification::has_mobileCoin,
                DataMessage_Payment_Notification::get_mobileCoin,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "note",
                |m: &DataMessage_Payment_Notification| { &m.note },
                |m: &mut DataMessage_Payment_Notification| { &mut m.note },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Notification>(
                "DataMessage.Payment.Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Notification {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Notification::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Notification {
    fn clear(&mut self) {
        self.Transaction = ::std::option::Option::None;
        self.note.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessage_Payment_Notification_MobileCoin {
    // message fields
    receipt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessage_Payment_Notification_MobileCoin {
    fn default() -> &'a DataMessage_Payment_Notification_MobileCoin {
        <DataMessage_Payment_Notification_MobileCoin as ::protobuf::Message>::default_instance()
    }
}

impl DataMessage_Payment_Notification_MobileCoin {
    pub fn new() -> DataMessage_Payment_Notification_MobileCoin {
        ::std::default::Default::default()
    }

    // optional bytes receipt = 1;


    pub fn get_receipt(&self) -> &[u8] {
        match self.receipt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    pub fn has_receipt(&self) -> bool {
        self.receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.receipt.is_none() {
            self.receipt.set_default();
        }
        self.receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        self.receipt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataMessage_Payment_Notification_MobileCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.receipt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.receipt.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessage_Payment_Notification_MobileCoin {
        DataMessage_Payment_Notification_MobileCoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "receipt",
                |m: &DataMessage_Payment_Notification_MobileCoin| { &m.receipt },
                |m: &mut DataMessage_Payment_Notification_MobileCoin| { &mut m.receipt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessage_Payment_Notification_MobileCoin>(
                "DataMessage.Payment.Notification.MobileCoin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessage_Payment_Notification_MobileCoin {
        static instance: ::protobuf::rt::LazyV2<DataMessage_Payment_Notification_MobileCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessage_Payment_Notification_MobileCoin::new)
    }
}

impl ::protobuf::Clear for DataMessage_Payment_Notification_MobileCoin {
    fn clear(&mut self) {
        self.receipt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessage_Payment_Notification_MobileCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Payment_Notification_MobileCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_Flags {
    END_SESSION = 1,
    EXPIRATION_TIMER_UPDATE = 2,
    PROFILE_KEY_UPDATE = 4,
}

impl ::protobuf::ProtobufEnum for DataMessage_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_Flags> {
        match value {
            1 => ::std::option::Option::Some(DataMessage_Flags::END_SESSION),
            2 => ::std::option::Option::Some(DataMessage_Flags::EXPIRATION_TIMER_UPDATE),
            4 => ::std::option::Option::Some(DataMessage_Flags::PROFILE_KEY_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_Flags] = &[
            DataMessage_Flags::END_SESSION,
            DataMessage_Flags::EXPIRATION_TIMER_UPDATE,
            DataMessage_Flags::PROFILE_KEY_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_Flags>("DataMessage.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DataMessage_Flags {
    fn default() -> Self {
        DataMessage_Flags::END_SESSION
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Eq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataMessage_ProtocolVersion {
    INITIAL, // 0
    MESSAGE_TIMERS, // 1
    VIEW_ONCE, // 2
    VIEW_ONCE_VIDEO, // 3
    REACTIONS, // 4
    CDN_SELECTOR_ATTACHMENTS, // 5
    MENTIONS, // 6
    PAYMENTS, // 7
    CURRENT, // 7
}

impl ::std::cmp::PartialEq for DataMessage_ProtocolVersion {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::ProtobufEnum::value(self) == ::protobuf::ProtobufEnum::value(other)
    }
}

impl ::std::hash::Hash for DataMessage_ProtocolVersion {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::ProtobufEnum::value(self))
    }
}

impl ::protobuf::ProtobufEnum for DataMessage_ProtocolVersion {
    fn value(&self) -> i32 {
        match *self {
            DataMessage_ProtocolVersion::INITIAL => 0,
            DataMessage_ProtocolVersion::MESSAGE_TIMERS => 1,
            DataMessage_ProtocolVersion::VIEW_ONCE => 2,
            DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO => 3,
            DataMessage_ProtocolVersion::REACTIONS => 4,
            DataMessage_ProtocolVersion::CDN_SELECTOR_ATTACHMENTS => 5,
            DataMessage_ProtocolVersion::MENTIONS => 6,
            DataMessage_ProtocolVersion::PAYMENTS => 7,
            DataMessage_ProtocolVersion::CURRENT => 7,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataMessage_ProtocolVersion> {
        match value {
            0 => ::std::option::Option::Some(DataMessage_ProtocolVersion::INITIAL),
            1 => ::std::option::Option::Some(DataMessage_ProtocolVersion::MESSAGE_TIMERS),
            2 => ::std::option::Option::Some(DataMessage_ProtocolVersion::VIEW_ONCE),
            3 => ::std::option::Option::Some(DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO),
            4 => ::std::option::Option::Some(DataMessage_ProtocolVersion::REACTIONS),
            5 => ::std::option::Option::Some(DataMessage_ProtocolVersion::CDN_SELECTOR_ATTACHMENTS),
            6 => ::std::option::Option::Some(DataMessage_ProtocolVersion::MENTIONS),
            7 => ::std::option::Option::Some(DataMessage_ProtocolVersion::PAYMENTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataMessage_ProtocolVersion] = &[
            DataMessage_ProtocolVersion::INITIAL,
            DataMessage_ProtocolVersion::MESSAGE_TIMERS,
            DataMessage_ProtocolVersion::VIEW_ONCE,
            DataMessage_ProtocolVersion::VIEW_ONCE_VIDEO,
            DataMessage_ProtocolVersion::REACTIONS,
            DataMessage_ProtocolVersion::CDN_SELECTOR_ATTACHMENTS,
            DataMessage_ProtocolVersion::MENTIONS,
            DataMessage_ProtocolVersion::PAYMENTS,
            DataMessage_ProtocolVersion::CURRENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataMessage_ProtocolVersion>("DataMessage.ProtocolVersion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataMessage_ProtocolVersion {
}

impl ::std::default::Default for DataMessage_ProtocolVersion {
    fn default() -> Self {
        DataMessage_ProtocolVersion::INITIAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessage_ProtocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NullMessage {
    // message fields
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NullMessage {
    fn default() -> &'a NullMessage {
        <NullMessage as ::protobuf::Message>::default_instance()
    }
}

impl NullMessage {
    pub fn new() -> NullMessage {
        ::std::default::Default::default()
    }

    // optional bytes padding = 1;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NullMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NullMessage {
        NullMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &NullMessage| { &m.padding },
                |m: &mut NullMessage| { &mut m.padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NullMessage>(
                "NullMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NullMessage {
        static instance: ::protobuf::rt::LazyV2<NullMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NullMessage::new)
    }
}

impl ::protobuf::Clear for NullMessage {
    fn clear(&mut self) {
        self.padding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NullMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NullMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReceiptMessage {
    // message fields
    field_type: ::std::option::Option<ReceiptMessage_Type>,
    pub timestamp: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiptMessage {
    fn default() -> &'a ReceiptMessage {
        <ReceiptMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceiptMessage {
    pub fn new() -> ReceiptMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.ReceiptMessage.Type type = 1;


    pub fn get_field_type(&self) -> ReceiptMessage_Type {
        self.field_type.unwrap_or(ReceiptMessage_Type::DELIVERY)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ReceiptMessage_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> &[u64] {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::vec::Vec<u64>) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.timestamp, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReceiptMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.timestamp {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.timestamp {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiptMessage {
        ReceiptMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReceiptMessage_Type>>(
                "type",
                |m: &ReceiptMessage| { &m.field_type },
                |m: &mut ReceiptMessage| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ReceiptMessage| { &m.timestamp },
                |m: &mut ReceiptMessage| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiptMessage>(
                "ReceiptMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceiptMessage {
        static instance: ::protobuf::rt::LazyV2<ReceiptMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceiptMessage::new)
    }
}

impl ::protobuf::Clear for ReceiptMessage {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiptMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiptMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum ReceiptMessage_Type {
    DELIVERY = 0,
    READ = 1,
    VIEWED = 2,
}

impl ::protobuf::ProtobufEnum for ReceiptMessage_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReceiptMessage_Type> {
        match value {
            0 => ::std::option::Option::Some(ReceiptMessage_Type::DELIVERY),
            1 => ::std::option::Option::Some(ReceiptMessage_Type::READ),
            2 => ::std::option::Option::Some(ReceiptMessage_Type::VIEWED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReceiptMessage_Type] = &[
            ReceiptMessage_Type::DELIVERY,
            ReceiptMessage_Type::READ,
            ReceiptMessage_Type::VIEWED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReceiptMessage_Type>("ReceiptMessage.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReceiptMessage_Type {
}

impl ::std::default::Default for ReceiptMessage_Type {
    fn default() -> Self {
        ReceiptMessage_Type::DELIVERY
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiptMessage_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TypingMessage {
    // message fields
    timestamp: ::std::option::Option<u64>,
    action: ::std::option::Option<TypingMessage_Action>,
    groupId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypingMessage {
    fn default() -> &'a TypingMessage {
        <TypingMessage as ::protobuf::Message>::default_instance()
    }
}

impl TypingMessage {
    pub fn new() -> TypingMessage {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.TypingMessage.Action action = 2;


    pub fn get_action(&self) -> TypingMessage_Action {
        self.action.unwrap_or(TypingMessage_Action::STARTED)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: TypingMessage_Action) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional bytes groupId = 3;


    pub fn get_groupId(&self) -> &[u8] {
        match self.groupId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_groupId(&mut self) {
        self.groupId.clear();
    }

    pub fn has_groupId(&self) -> bool {
        self.groupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: ::std::vec::Vec<u8>) {
        self.groupId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.groupId.is_none() {
            self.groupId.set_default();
        }
        self.groupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupId(&mut self) -> ::std::vec::Vec<u8> {
        self.groupId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TypingMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.groupId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.groupId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.groupId.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypingMessage {
        TypingMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &TypingMessage| { &m.timestamp },
                |m: &mut TypingMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypingMessage_Action>>(
                "action",
                |m: &TypingMessage| { &m.action },
                |m: &mut TypingMessage| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupId",
                |m: &TypingMessage| { &m.groupId },
                |m: &mut TypingMessage| { &mut m.groupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TypingMessage>(
                "TypingMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TypingMessage {
        static instance: ::protobuf::rt::LazyV2<TypingMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypingMessage::new)
    }
}

impl ::protobuf::Clear for TypingMessage {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.groupId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypingMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum TypingMessage_Action {
    STARTED = 0,
    STOPPED = 1,
}

impl ::protobuf::ProtobufEnum for TypingMessage_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypingMessage_Action> {
        match value {
            0 => ::std::option::Option::Some(TypingMessage_Action::STARTED),
            1 => ::std::option::Option::Some(TypingMessage_Action::STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypingMessage_Action] = &[
            TypingMessage_Action::STARTED,
            TypingMessage_Action::STOPPED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TypingMessage_Action>("TypingMessage.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TypingMessage_Action {
}

impl ::std::default::Default for TypingMessage_Action {
    fn default() -> Self {
        TypingMessage_Action::STARTED
    }
}

impl ::protobuf::reflect::ProtobufValue for TypingMessage_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Verified {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    identityKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    state: ::std::option::Option<Verified_State>,
    nullMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Verified {
    fn default() -> &'a Verified {
        <Verified as ::protobuf::Message>::default_instance()
    }
}

impl Verified {
    pub fn new() -> Verified {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 5;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes identityKey = 2;


    pub fn get_identityKey(&self) -> &[u8] {
        match self.identityKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_identityKey(&mut self) {
        self.identityKey.clear();
    }

    pub fn has_identityKey(&self) -> bool {
        self.identityKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identityKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.identityKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identityKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identityKey.is_none() {
            self.identityKey.set_default();
        }
        self.identityKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_identityKey(&mut self) -> ::std::vec::Vec<u8> {
        self.identityKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.Verified.State state = 3;


    pub fn get_state(&self) -> Verified_State {
        self.state.unwrap_or(Verified_State::DEFAULT)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Verified_State) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional bytes nullMessage = 4;


    pub fn get_nullMessage(&self) -> &[u8] {
        match self.nullMessage.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nullMessage(&mut self) {
        self.nullMessage.clear();
    }

    pub fn has_nullMessage(&self) -> bool {
        self.nullMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nullMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.nullMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nullMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nullMessage.is_none() {
            self.nullMessage.set_default();
        }
        self.nullMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_nullMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.nullMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Verified {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.identityKey)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nullMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.identityKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.identityKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.nullMessage.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Verified {
        Verified::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &Verified| { &m.destinationE164 },
                |m: &mut Verified| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &Verified| { &m.destinationUuid },
                |m: &mut Verified| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "identityKey",
                |m: &Verified| { &m.identityKey },
                |m: &mut Verified| { &mut m.identityKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Verified_State>>(
                "state",
                |m: &Verified| { &m.state },
                |m: &mut Verified| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nullMessage",
                |m: &Verified| { &m.nullMessage },
                |m: &mut Verified| { &mut m.nullMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Verified>(
                "Verified",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Verified {
        static instance: ::protobuf::rt::LazyV2<Verified> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Verified::new)
    }
}

impl ::protobuf::Clear for Verified {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.identityKey.clear();
        self.state = ::std::option::Option::None;
        self.nullMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Verified {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Verified {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Verified_State {
    DEFAULT = 0,
    VERIFIED = 1,
    UNVERIFIED = 2,
}

impl ::protobuf::ProtobufEnum for Verified_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Verified_State> {
        match value {
            0 => ::std::option::Option::Some(Verified_State::DEFAULT),
            1 => ::std::option::Option::Some(Verified_State::VERIFIED),
            2 => ::std::option::Option::Some(Verified_State::UNVERIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Verified_State] = &[
            Verified_State::DEFAULT,
            Verified_State::VERIFIED,
            Verified_State::UNVERIFIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Verified_State>("Verified.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Verified_State {
}

impl ::std::default::Default for Verified_State {
    fn default() -> Self {
        Verified_State::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for Verified_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage {
    // message fields
    pub sent: ::protobuf::SingularPtrField<SyncMessage_Sent>,
    pub contacts: ::protobuf::SingularPtrField<SyncMessage_Contacts>,
    pub groups: ::protobuf::SingularPtrField<SyncMessage_Groups>,
    pub request: ::protobuf::SingularPtrField<SyncMessage_Request>,
    pub read: ::protobuf::RepeatedField<SyncMessage_Read>,
    pub blocked: ::protobuf::SingularPtrField<SyncMessage_Blocked>,
    pub verified: ::protobuf::SingularPtrField<Verified>,
    pub configuration: ::protobuf::SingularPtrField<SyncMessage_Configuration>,
    padding: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub stickerPackOperation: ::protobuf::RepeatedField<SyncMessage_StickerPackOperation>,
    pub viewOnceOpen: ::protobuf::SingularPtrField<SyncMessage_ViewOnceOpen>,
    pub fetchLatest: ::protobuf::SingularPtrField<SyncMessage_FetchLatest>,
    pub keys: ::protobuf::SingularPtrField<SyncMessage_Keys>,
    pub messageRequestResponse: ::protobuf::SingularPtrField<SyncMessage_MessageRequestResponse>,
    pub outgoingPayment: ::protobuf::SingularPtrField<SyncMessage_OutgoingPayment>,
    pub viewed: ::protobuf::RepeatedField<SyncMessage_Viewed>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage {
    fn default() -> &'a SyncMessage {
        <SyncMessage as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage {
    pub fn new() -> SyncMessage {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.Sent sent = 1;


    pub fn get_sent(&self) -> &SyncMessage_Sent {
        self.sent.as_ref().unwrap_or_else(|| <SyncMessage_Sent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sent(&mut self) {
        self.sent.clear();
    }

    pub fn has_sent(&self) -> bool {
        self.sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sent(&mut self, v: SyncMessage_Sent) {
        self.sent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sent(&mut self) -> &mut SyncMessage_Sent {
        if self.sent.is_none() {
            self.sent.set_default();
        }
        self.sent.as_mut().unwrap()
    }

    // Take field
    pub fn take_sent(&mut self) -> SyncMessage_Sent {
        self.sent.take().unwrap_or_else(|| SyncMessage_Sent::new())
    }

    // optional .signalservice.SyncMessage.Contacts contacts = 2;


    pub fn get_contacts(&self) -> &SyncMessage_Contacts {
        self.contacts.as_ref().unwrap_or_else(|| <SyncMessage_Contacts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    pub fn has_contacts(&self) -> bool {
        self.contacts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: SyncMessage_Contacts) {
        self.contacts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contacts(&mut self) -> &mut SyncMessage_Contacts {
        if self.contacts.is_none() {
            self.contacts.set_default();
        }
        self.contacts.as_mut().unwrap()
    }

    // Take field
    pub fn take_contacts(&mut self) -> SyncMessage_Contacts {
        self.contacts.take().unwrap_or_else(|| SyncMessage_Contacts::new())
    }

    // optional .signalservice.SyncMessage.Groups groups = 3;


    pub fn get_groups(&self) -> &SyncMessage_Groups {
        self.groups.as_ref().unwrap_or_else(|| <SyncMessage_Groups as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    pub fn has_groups(&self) -> bool {
        self.groups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: SyncMessage_Groups) {
        self.groups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groups(&mut self) -> &mut SyncMessage_Groups {
        if self.groups.is_none() {
            self.groups.set_default();
        }
        self.groups.as_mut().unwrap()
    }

    // Take field
    pub fn take_groups(&mut self) -> SyncMessage_Groups {
        self.groups.take().unwrap_or_else(|| SyncMessage_Groups::new())
    }

    // optional .signalservice.SyncMessage.Request request = 4;


    pub fn get_request(&self) -> &SyncMessage_Request {
        self.request.as_ref().unwrap_or_else(|| <SyncMessage_Request as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: SyncMessage_Request) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut SyncMessage_Request {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> SyncMessage_Request {
        self.request.take().unwrap_or_else(|| SyncMessage_Request::new())
    }

    // repeated .signalservice.SyncMessage.Read read = 5;


    pub fn get_read(&self) -> &[SyncMessage_Read] {
        &self.read
    }
    pub fn clear_read(&mut self) {
        self.read.clear();
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: ::protobuf::RepeatedField<SyncMessage_Read>) {
        self.read = v;
    }

    // Mutable pointer to the field.
    pub fn mut_read(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_Read> {
        &mut self.read
    }

    // Take field
    pub fn take_read(&mut self) -> ::protobuf::RepeatedField<SyncMessage_Read> {
        ::std::mem::replace(&mut self.read, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.SyncMessage.Blocked blocked = 6;


    pub fn get_blocked(&self) -> &SyncMessage_Blocked {
        self.blocked.as_ref().unwrap_or_else(|| <SyncMessage_Blocked as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blocked(&mut self) {
        self.blocked.clear();
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: SyncMessage_Blocked) {
        self.blocked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blocked(&mut self) -> &mut SyncMessage_Blocked {
        if self.blocked.is_none() {
            self.blocked.set_default();
        }
        self.blocked.as_mut().unwrap()
    }

    // Take field
    pub fn take_blocked(&mut self) -> SyncMessage_Blocked {
        self.blocked.take().unwrap_or_else(|| SyncMessage_Blocked::new())
    }

    // optional .signalservice.Verified verified = 7;


    pub fn get_verified(&self) -> &Verified {
        self.verified.as_ref().unwrap_or_else(|| <Verified as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verified(&mut self) {
        self.verified.clear();
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: Verified) {
        self.verified = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verified(&mut self) -> &mut Verified {
        if self.verified.is_none() {
            self.verified.set_default();
        }
        self.verified.as_mut().unwrap()
    }

    // Take field
    pub fn take_verified(&mut self) -> Verified {
        self.verified.take().unwrap_or_else(|| Verified::new())
    }

    // optional .signalservice.SyncMessage.Configuration configuration = 9;


    pub fn get_configuration(&self) -> &SyncMessage_Configuration {
        self.configuration.as_ref().unwrap_or_else(|| <SyncMessage_Configuration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configuration(&mut self) {
        self.configuration.clear();
    }

    pub fn has_configuration(&self) -> bool {
        self.configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration(&mut self, v: SyncMessage_Configuration) {
        self.configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration(&mut self) -> &mut SyncMessage_Configuration {
        if self.configuration.is_none() {
            self.configuration.set_default();
        }
        self.configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration(&mut self) -> SyncMessage_Configuration {
        self.configuration.take().unwrap_or_else(|| SyncMessage_Configuration::new())
    }

    // optional bytes padding = 8;


    pub fn get_padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_padding(&mut self) {
        self.padding.clear();
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding.set_default();
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .signalservice.SyncMessage.StickerPackOperation stickerPackOperation = 10;


    pub fn get_stickerPackOperation(&self) -> &[SyncMessage_StickerPackOperation] {
        &self.stickerPackOperation
    }
    pub fn clear_stickerPackOperation(&mut self) {
        self.stickerPackOperation.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickerPackOperation(&mut self, v: ::protobuf::RepeatedField<SyncMessage_StickerPackOperation>) {
        self.stickerPackOperation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickerPackOperation(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_StickerPackOperation> {
        &mut self.stickerPackOperation
    }

    // Take field
    pub fn take_stickerPackOperation(&mut self) -> ::protobuf::RepeatedField<SyncMessage_StickerPackOperation> {
        ::std::mem::replace(&mut self.stickerPackOperation, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.SyncMessage.ViewOnceOpen viewOnceOpen = 11;


    pub fn get_viewOnceOpen(&self) -> &SyncMessage_ViewOnceOpen {
        self.viewOnceOpen.as_ref().unwrap_or_else(|| <SyncMessage_ViewOnceOpen as ::protobuf::Message>::default_instance())
    }
    pub fn clear_viewOnceOpen(&mut self) {
        self.viewOnceOpen.clear();
    }

    pub fn has_viewOnceOpen(&self) -> bool {
        self.viewOnceOpen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnceOpen(&mut self, v: SyncMessage_ViewOnceOpen) {
        self.viewOnceOpen = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_viewOnceOpen(&mut self) -> &mut SyncMessage_ViewOnceOpen {
        if self.viewOnceOpen.is_none() {
            self.viewOnceOpen.set_default();
        }
        self.viewOnceOpen.as_mut().unwrap()
    }

    // Take field
    pub fn take_viewOnceOpen(&mut self) -> SyncMessage_ViewOnceOpen {
        self.viewOnceOpen.take().unwrap_or_else(|| SyncMessage_ViewOnceOpen::new())
    }

    // optional .signalservice.SyncMessage.FetchLatest fetchLatest = 12;


    pub fn get_fetchLatest(&self) -> &SyncMessage_FetchLatest {
        self.fetchLatest.as_ref().unwrap_or_else(|| <SyncMessage_FetchLatest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fetchLatest(&mut self) {
        self.fetchLatest.clear();
    }

    pub fn has_fetchLatest(&self) -> bool {
        self.fetchLatest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fetchLatest(&mut self, v: SyncMessage_FetchLatest) {
        self.fetchLatest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fetchLatest(&mut self) -> &mut SyncMessage_FetchLatest {
        if self.fetchLatest.is_none() {
            self.fetchLatest.set_default();
        }
        self.fetchLatest.as_mut().unwrap()
    }

    // Take field
    pub fn take_fetchLatest(&mut self) -> SyncMessage_FetchLatest {
        self.fetchLatest.take().unwrap_or_else(|| SyncMessage_FetchLatest::new())
    }

    // optional .signalservice.SyncMessage.Keys keys = 13;


    pub fn get_keys(&self) -> &SyncMessage_Keys {
        self.keys.as_ref().unwrap_or_else(|| <SyncMessage_Keys as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    pub fn has_keys(&self) -> bool {
        self.keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: SyncMessage_Keys) {
        self.keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keys(&mut self) -> &mut SyncMessage_Keys {
        if self.keys.is_none() {
            self.keys.set_default();
        }
        self.keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_keys(&mut self) -> SyncMessage_Keys {
        self.keys.take().unwrap_or_else(|| SyncMessage_Keys::new())
    }

    // optional .signalservice.SyncMessage.MessageRequestResponse messageRequestResponse = 14;


    pub fn get_messageRequestResponse(&self) -> &SyncMessage_MessageRequestResponse {
        self.messageRequestResponse.as_ref().unwrap_or_else(|| <SyncMessage_MessageRequestResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageRequestResponse(&mut self) {
        self.messageRequestResponse.clear();
    }

    pub fn has_messageRequestResponse(&self) -> bool {
        self.messageRequestResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageRequestResponse(&mut self, v: SyncMessage_MessageRequestResponse) {
        self.messageRequestResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageRequestResponse(&mut self) -> &mut SyncMessage_MessageRequestResponse {
        if self.messageRequestResponse.is_none() {
            self.messageRequestResponse.set_default();
        }
        self.messageRequestResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageRequestResponse(&mut self) -> SyncMessage_MessageRequestResponse {
        self.messageRequestResponse.take().unwrap_or_else(|| SyncMessage_MessageRequestResponse::new())
    }

    // optional .signalservice.SyncMessage.OutgoingPayment outgoingPayment = 15;


    pub fn get_outgoingPayment(&self) -> &SyncMessage_OutgoingPayment {
        self.outgoingPayment.as_ref().unwrap_or_else(|| <SyncMessage_OutgoingPayment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outgoingPayment(&mut self) {
        self.outgoingPayment.clear();
    }

    pub fn has_outgoingPayment(&self) -> bool {
        self.outgoingPayment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outgoingPayment(&mut self, v: SyncMessage_OutgoingPayment) {
        self.outgoingPayment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outgoingPayment(&mut self) -> &mut SyncMessage_OutgoingPayment {
        if self.outgoingPayment.is_none() {
            self.outgoingPayment.set_default();
        }
        self.outgoingPayment.as_mut().unwrap()
    }

    // Take field
    pub fn take_outgoingPayment(&mut self) -> SyncMessage_OutgoingPayment {
        self.outgoingPayment.take().unwrap_or_else(|| SyncMessage_OutgoingPayment::new())
    }

    // repeated .signalservice.SyncMessage.Viewed viewed = 16;


    pub fn get_viewed(&self) -> &[SyncMessage_Viewed] {
        &self.viewed
    }
    pub fn clear_viewed(&mut self) {
        self.viewed.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewed(&mut self, v: ::protobuf::RepeatedField<SyncMessage_Viewed>) {
        self.viewed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewed(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_Viewed> {
        &mut self.viewed
    }

    // Take field
    pub fn take_viewed(&mut self) -> ::protobuf::RepeatedField<SyncMessage_Viewed> {
        ::std::mem::replace(&mut self.viewed, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contacts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blocked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verified {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickerPackOperation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewOnceOpen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fetchLatest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.messageRequestResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outgoingPayment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contacts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groups)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.read)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blocked)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verified)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configuration)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.padding)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stickerPackOperation)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.viewOnceOpen)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fetchLatest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keys)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageRequestResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outgoingPayment)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.viewed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contacts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.groups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.read {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.blocked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.verified.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.stickerPackOperation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.viewOnceOpen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fetchLatest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.messageRequestResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.outgoingPayment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.viewed {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sent.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contacts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.groups.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.read {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.blocked.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.verified.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.padding.as_ref() {
            os.write_bytes(8, &v)?;
        }
        for v in &self.stickerPackOperation {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.viewOnceOpen.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fetchLatest.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.keys.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.messageRequestResponse.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.outgoingPayment.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.viewed {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage {
        SyncMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Sent>>(
                "sent",
                |m: &SyncMessage| { &m.sent },
                |m: &mut SyncMessage| { &mut m.sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Contacts>>(
                "contacts",
                |m: &SyncMessage| { &m.contacts },
                |m: &mut SyncMessage| { &mut m.contacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Groups>>(
                "groups",
                |m: &SyncMessage| { &m.groups },
                |m: &mut SyncMessage| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Request>>(
                "request",
                |m: &SyncMessage| { &m.request },
                |m: &mut SyncMessage| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Read>>(
                "read",
                |m: &SyncMessage| { &m.read },
                |m: &mut SyncMessage| { &mut m.read },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Blocked>>(
                "blocked",
                |m: &SyncMessage| { &m.blocked },
                |m: &mut SyncMessage| { &mut m.blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Verified>>(
                "verified",
                |m: &SyncMessage| { &m.verified },
                |m: &mut SyncMessage| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Configuration>>(
                "configuration",
                |m: &SyncMessage| { &m.configuration },
                |m: &mut SyncMessage| { &mut m.configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "padding",
                |m: &SyncMessage| { &m.padding },
                |m: &mut SyncMessage| { &mut m.padding },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_StickerPackOperation>>(
                "stickerPackOperation",
                |m: &SyncMessage| { &m.stickerPackOperation },
                |m: &mut SyncMessage| { &mut m.stickerPackOperation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_ViewOnceOpen>>(
                "viewOnceOpen",
                |m: &SyncMessage| { &m.viewOnceOpen },
                |m: &mut SyncMessage| { &mut m.viewOnceOpen },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_FetchLatest>>(
                "fetchLatest",
                |m: &SyncMessage| { &m.fetchLatest },
                |m: &mut SyncMessage| { &mut m.fetchLatest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Keys>>(
                "keys",
                |m: &SyncMessage| { &m.keys },
                |m: &mut SyncMessage| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_MessageRequestResponse>>(
                "messageRequestResponse",
                |m: &SyncMessage| { &m.messageRequestResponse },
                |m: &mut SyncMessage| { &mut m.messageRequestResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_OutgoingPayment>>(
                "outgoingPayment",
                |m: &SyncMessage| { &m.outgoingPayment },
                |m: &mut SyncMessage| { &mut m.outgoingPayment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Viewed>>(
                "viewed",
                |m: &SyncMessage| { &m.viewed },
                |m: &mut SyncMessage| { &mut m.viewed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage>(
                "SyncMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage {
        static instance: ::protobuf::rt::LazyV2<SyncMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage::new)
    }
}

impl ::protobuf::Clear for SyncMessage {
    fn clear(&mut self) {
        self.sent.clear();
        self.contacts.clear();
        self.groups.clear();
        self.request.clear();
        self.read.clear();
        self.blocked.clear();
        self.verified.clear();
        self.configuration.clear();
        self.padding.clear();
        self.stickerPackOperation.clear();
        self.viewOnceOpen.clear();
        self.fetchLatest.clear();
        self.keys.clear();
        self.messageRequestResponse.clear();
        self.outgoingPayment.clear();
        self.viewed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Sent {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    pub message: ::protobuf::SingularPtrField<DataMessage>,
    expirationStartTimestamp: ::std::option::Option<u64>,
    pub unidentifiedStatus: ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus>,
    isRecipientUpdate: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Sent {
    fn default() -> &'a SyncMessage_Sent {
        <SyncMessage_Sent as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Sent {
    pub fn new() -> SyncMessage_Sent {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 7;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .signalservice.DataMessage message = 3;


    pub fn get_message(&self) -> &DataMessage {
        self.message.as_ref().unwrap_or_else(|| <DataMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: DataMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut DataMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> DataMessage {
        self.message.take().unwrap_or_else(|| DataMessage::new())
    }

    // optional uint64 expirationStartTimestamp = 4;


    pub fn get_expirationStartTimestamp(&self) -> u64 {
        self.expirationStartTimestamp.unwrap_or(0)
    }
    pub fn clear_expirationStartTimestamp(&mut self) {
        self.expirationStartTimestamp = ::std::option::Option::None;
    }

    pub fn has_expirationStartTimestamp(&self) -> bool {
        self.expirationStartTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationStartTimestamp(&mut self, v: u64) {
        self.expirationStartTimestamp = ::std::option::Option::Some(v);
    }

    // repeated .signalservice.SyncMessage.Sent.UnidentifiedDeliveryStatus unidentifiedStatus = 5;


    pub fn get_unidentifiedStatus(&self) -> &[SyncMessage_Sent_UnidentifiedDeliveryStatus] {
        &self.unidentifiedStatus
    }
    pub fn clear_unidentifiedStatus(&mut self) {
        self.unidentifiedStatus.clear();
    }

    // Param is passed by value, moved
    pub fn set_unidentifiedStatus(&mut self, v: ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus>) {
        self.unidentifiedStatus = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unidentifiedStatus(&mut self) -> &mut ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus> {
        &mut self.unidentifiedStatus
    }

    // Take field
    pub fn take_unidentifiedStatus(&mut self) -> ::protobuf::RepeatedField<SyncMessage_Sent_UnidentifiedDeliveryStatus> {
        ::std::mem::replace(&mut self.unidentifiedStatus, ::protobuf::RepeatedField::new())
    }

    // optional bool isRecipientUpdate = 6;


    pub fn get_isRecipientUpdate(&self) -> bool {
        self.isRecipientUpdate.unwrap_or(false)
    }
    pub fn clear_isRecipientUpdate(&mut self) {
        self.isRecipientUpdate = ::std::option::Option::None;
    }

    pub fn has_isRecipientUpdate(&self) -> bool {
        self.isRecipientUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRecipientUpdate(&mut self, v: bool) {
        self.isRecipientUpdate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Sent {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unidentifiedStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expirationStartTimestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unidentifiedStatus)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRecipientUpdate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.expirationStartTimestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unidentifiedStatus {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.isRecipientUpdate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.expirationStartTimestamp {
            os.write_uint64(4, v)?;
        }
        for v in &self.unidentifiedStatus {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.isRecipientUpdate {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Sent {
        SyncMessage_Sent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &SyncMessage_Sent| { &m.destinationE164 },
                |m: &mut SyncMessage_Sent| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &SyncMessage_Sent| { &m.destinationUuid },
                |m: &mut SyncMessage_Sent| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_Sent| { &m.timestamp },
                |m: &mut SyncMessage_Sent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessage>>(
                "message",
                |m: &SyncMessage_Sent| { &m.message },
                |m: &mut SyncMessage_Sent| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expirationStartTimestamp",
                |m: &SyncMessage_Sent| { &m.expirationStartTimestamp },
                |m: &mut SyncMessage_Sent| { &mut m.expirationStartTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncMessage_Sent_UnidentifiedDeliveryStatus>>(
                "unidentifiedStatus",
                |m: &SyncMessage_Sent| { &m.unidentifiedStatus },
                |m: &mut SyncMessage_Sent| { &mut m.unidentifiedStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isRecipientUpdate",
                |m: &SyncMessage_Sent| { &m.isRecipientUpdate },
                |m: &mut SyncMessage_Sent| { &mut m.isRecipientUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Sent>(
                "SyncMessage.Sent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Sent {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Sent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Sent::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Sent {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.message.clear();
        self.expirationStartTimestamp = ::std::option::Option::None;
        self.unidentifiedStatus.clear();
        self.isRecipientUpdate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Sent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Sent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Sent_UnidentifiedDeliveryStatus {
    // message fields
    destinationE164: ::protobuf::SingularField<::std::string::String>,
    destinationUuid: ::protobuf::SingularField<::std::string::String>,
    unidentified: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn default() -> &'a SyncMessage_Sent_UnidentifiedDeliveryStatus {
        <SyncMessage_Sent_UnidentifiedDeliveryStatus as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Sent_UnidentifiedDeliveryStatus {
    pub fn new() -> SyncMessage_Sent_UnidentifiedDeliveryStatus {
        ::std::default::Default::default()
    }

    // optional string destinationE164 = 1;


    pub fn get_destinationE164(&self) -> &str {
        match self.destinationE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationE164(&mut self) {
        self.destinationE164.clear();
    }

    pub fn has_destinationE164(&self) -> bool {
        self.destinationE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationE164(&mut self, v: ::std::string::String) {
        self.destinationE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationE164(&mut self) -> &mut ::std::string::String {
        if self.destinationE164.is_none() {
            self.destinationE164.set_default();
        }
        self.destinationE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationE164(&mut self) -> ::std::string::String {
        self.destinationE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string destinationUuid = 3;


    pub fn get_destinationUuid(&self) -> &str {
        match self.destinationUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_destinationUuid(&mut self) {
        self.destinationUuid.clear();
    }

    pub fn has_destinationUuid(&self) -> bool {
        self.destinationUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationUuid(&mut self, v: ::std::string::String) {
        self.destinationUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationUuid(&mut self) -> &mut ::std::string::String {
        if self.destinationUuid.is_none() {
            self.destinationUuid.set_default();
        }
        self.destinationUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationUuid(&mut self) -> ::std::string::String {
        self.destinationUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unidentified = 2;


    pub fn get_unidentified(&self) -> bool {
        self.unidentified.unwrap_or(false)
    }
    pub fn clear_unidentified(&mut self) {
        self.unidentified = ::std::option::Option::None;
    }

    pub fn has_unidentified(&self) -> bool {
        self.unidentified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unidentified(&mut self, v: bool) {
        self.unidentified = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.destinationUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unidentified = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destinationE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unidentified {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destinationE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.destinationUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.unidentified {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Sent_UnidentifiedDeliveryStatus {
        SyncMessage_Sent_UnidentifiedDeliveryStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationE164",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.destinationE164 },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.destinationE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destinationUuid",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.destinationUuid },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.destinationUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unidentified",
                |m: &SyncMessage_Sent_UnidentifiedDeliveryStatus| { &m.unidentified },
                |m: &mut SyncMessage_Sent_UnidentifiedDeliveryStatus| { &mut m.unidentified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Sent_UnidentifiedDeliveryStatus>(
                "SyncMessage.Sent.UnidentifiedDeliveryStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Sent_UnidentifiedDeliveryStatus {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Sent_UnidentifiedDeliveryStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Sent_UnidentifiedDeliveryStatus::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn clear(&mut self) {
        self.destinationE164.clear();
        self.destinationUuid.clear();
        self.unidentified = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Sent_UnidentifiedDeliveryStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Contacts {
    // message fields
    pub blob: ::protobuf::SingularPtrField<AttachmentPointer>,
    complete: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Contacts {
    fn default() -> &'a SyncMessage_Contacts {
        <SyncMessage_Contacts as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Contacts {
    pub fn new() -> SyncMessage_Contacts {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer blob = 1;


    pub fn get_blob(&self) -> &AttachmentPointer {
        self.blob.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: AttachmentPointer) {
        self.blob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut AttachmentPointer {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> AttachmentPointer {
        self.blob.take().unwrap_or_else(|| AttachmentPointer::new())
    }

    // optional bool complete = 2;


    pub fn get_complete(&self) -> bool {
        self.complete.unwrap_or(false)
    }
    pub fn clear_complete(&mut self) {
        self.complete = ::std::option::Option::None;
    }

    pub fn has_complete(&self) -> bool {
        self.complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete(&mut self, v: bool) {
        self.complete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Contacts {
    fn is_initialized(&self) -> bool {
        for v in &self.blob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blob)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.complete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.complete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blob.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.complete {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Contacts {
        SyncMessage_Contacts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "blob",
                |m: &SyncMessage_Contacts| { &m.blob },
                |m: &mut SyncMessage_Contacts| { &mut m.blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "complete",
                |m: &SyncMessage_Contacts| { &m.complete },
                |m: &mut SyncMessage_Contacts| { &mut m.complete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Contacts>(
                "SyncMessage.Contacts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Contacts {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Contacts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Contacts::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Contacts {
    fn clear(&mut self) {
        self.blob.clear();
        self.complete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Contacts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Contacts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Groups {
    // message fields
    pub blob: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Groups {
    fn default() -> &'a SyncMessage_Groups {
        <SyncMessage_Groups as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Groups {
    pub fn new() -> SyncMessage_Groups {
        ::std::default::Default::default()
    }

    // optional .signalservice.AttachmentPointer blob = 1;


    pub fn get_blob(&self) -> &AttachmentPointer {
        self.blob.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: AttachmentPointer) {
        self.blob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut AttachmentPointer {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> AttachmentPointer {
        self.blob.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for SyncMessage_Groups {
    fn is_initialized(&self) -> bool {
        for v in &self.blob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blob.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Groups {
        SyncMessage_Groups::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "blob",
                |m: &SyncMessage_Groups| { &m.blob },
                |m: &mut SyncMessage_Groups| { &mut m.blob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Groups>(
                "SyncMessage.Groups",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Groups {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Groups> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Groups::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Groups {
    fn clear(&mut self) {
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Groups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Groups {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Blocked {
    // message fields
    pub numbers: ::protobuf::RepeatedField<::std::string::String>,
    pub uuids: ::protobuf::RepeatedField<::std::string::String>,
    pub groupIds: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Blocked {
    fn default() -> &'a SyncMessage_Blocked {
        <SyncMessage_Blocked as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Blocked {
    pub fn new() -> SyncMessage_Blocked {
        ::std::default::Default::default()
    }

    // repeated string numbers = 1;


    pub fn get_numbers(&self) -> &[::std::string::String] {
        &self.numbers
    }
    pub fn clear_numbers(&mut self) {
        self.numbers.clear();
    }

    // Param is passed by value, moved
    pub fn set_numbers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.numbers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numbers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.numbers
    }

    // Take field
    pub fn take_numbers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.numbers, ::protobuf::RepeatedField::new())
    }

    // repeated string uuids = 3;


    pub fn get_uuids(&self) -> &[::std::string::String] {
        &self.uuids
    }
    pub fn clear_uuids(&mut self) {
        self.uuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uuids
    }

    // Take field
    pub fn take_uuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uuids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes groupIds = 2;


    pub fn get_groupIds(&self) -> &[::std::vec::Vec<u8>] {
        &self.groupIds
    }
    pub fn clear_groupIds(&mut self) {
        self.groupIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_groupIds(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.groupIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groupIds(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.groupIds
    }

    // Take field
    pub fn take_groupIds(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.groupIds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncMessage_Blocked {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.numbers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uuids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.groupIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.numbers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.uuids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.groupIds {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.numbers {
            os.write_string(1, &v)?;
        };
        for v in &self.uuids {
            os.write_string(3, &v)?;
        };
        for v in &self.groupIds {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Blocked {
        SyncMessage_Blocked::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "numbers",
                |m: &SyncMessage_Blocked| { &m.numbers },
                |m: &mut SyncMessage_Blocked| { &mut m.numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuids",
                |m: &SyncMessage_Blocked| { &m.uuids },
                |m: &mut SyncMessage_Blocked| { &mut m.uuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupIds",
                |m: &SyncMessage_Blocked| { &m.groupIds },
                |m: &mut SyncMessage_Blocked| { &mut m.groupIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Blocked>(
                "SyncMessage.Blocked",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Blocked {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Blocked> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Blocked::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Blocked {
    fn clear(&mut self) {
        self.numbers.clear();
        self.uuids.clear();
        self.groupIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Blocked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Blocked {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Request {
    // message fields
    field_type: ::std::option::Option<SyncMessage_Request_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Request {
    fn default() -> &'a SyncMessage_Request {
        <SyncMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Request {
    pub fn new() -> SyncMessage_Request {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.Request.Type type = 1;


    pub fn get_field_type(&self) -> SyncMessage_Request_Type {
        self.field_type.unwrap_or(SyncMessage_Request_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_Request_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Request {
        SyncMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_Request_Type>>(
                "type",
                |m: &SyncMessage_Request| { &m.field_type },
                |m: &mut SyncMessage_Request| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Request>(
                "SyncMessage.Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Request {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Request::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Request {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_Request_Type {
    UNKNOWN = 0,
    CONTACTS = 1,
    GROUPS = 2,
    BLOCKED = 3,
    CONFIGURATION = 4,
    KEYS = 5,
}

impl ::protobuf::ProtobufEnum for SyncMessage_Request_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_Request_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_Request_Type::UNKNOWN),
            1 => ::std::option::Option::Some(SyncMessage_Request_Type::CONTACTS),
            2 => ::std::option::Option::Some(SyncMessage_Request_Type::GROUPS),
            3 => ::std::option::Option::Some(SyncMessage_Request_Type::BLOCKED),
            4 => ::std::option::Option::Some(SyncMessage_Request_Type::CONFIGURATION),
            5 => ::std::option::Option::Some(SyncMessage_Request_Type::KEYS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_Request_Type] = &[
            SyncMessage_Request_Type::UNKNOWN,
            SyncMessage_Request_Type::CONTACTS,
            SyncMessage_Request_Type::GROUPS,
            SyncMessage_Request_Type::BLOCKED,
            SyncMessage_Request_Type::CONFIGURATION,
            SyncMessage_Request_Type::KEYS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_Request_Type>("SyncMessage.Request.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_Request_Type {
}

impl ::std::default::Default for SyncMessage_Request_Type {
    fn default() -> Self {
        SyncMessage_Request_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Request_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Read {
    // message fields
    senderE164: ::protobuf::SingularField<::std::string::String>,
    senderUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Read {
    fn default() -> &'a SyncMessage_Read {
        <SyncMessage_Read as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Read {
    pub fn new() -> SyncMessage_Read {
        ::std::default::Default::default()
    }

    // optional string senderE164 = 1;


    pub fn get_senderE164(&self) -> &str {
        match self.senderE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderE164(&mut self) {
        self.senderE164.clear();
    }

    pub fn has_senderE164(&self) -> bool {
        self.senderE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderE164(&mut self, v: ::std::string::String) {
        self.senderE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderE164(&mut self) -> &mut ::std::string::String {
        if self.senderE164.is_none() {
            self.senderE164.set_default();
        }
        self.senderE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderE164(&mut self) -> ::std::string::String {
        self.senderE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string senderUuid = 3;


    pub fn get_senderUuid(&self) -> &str {
        match self.senderUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderUuid(&mut self) {
        self.senderUuid.clear();
    }

    pub fn has_senderUuid(&self) -> bool {
        self.senderUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderUuid(&mut self, v: ::std::string::String) {
        self.senderUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderUuid(&mut self) -> &mut ::std::string::String {
        if self.senderUuid.is_none() {
            self.senderUuid.set_default();
        }
        self.senderUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderUuid(&mut self) -> ::std::string::String {
        self.senderUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Read {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.senderE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.senderE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Read {
        SyncMessage_Read::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderE164",
                |m: &SyncMessage_Read| { &m.senderE164 },
                |m: &mut SyncMessage_Read| { &mut m.senderE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderUuid",
                |m: &SyncMessage_Read| { &m.senderUuid },
                |m: &mut SyncMessage_Read| { &mut m.senderUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_Read| { &m.timestamp },
                |m: &mut SyncMessage_Read| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Read>(
                "SyncMessage.Read",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Read {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Read> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Read::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Read {
    fn clear(&mut self) {
        self.senderE164.clear();
        self.senderUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Read {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Read {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Viewed {
    // message fields
    senderE164: ::protobuf::SingularField<::std::string::String>,
    senderUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Viewed {
    fn default() -> &'a SyncMessage_Viewed {
        <SyncMessage_Viewed as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Viewed {
    pub fn new() -> SyncMessage_Viewed {
        ::std::default::Default::default()
    }

    // optional string senderE164 = 1;


    pub fn get_senderE164(&self) -> &str {
        match self.senderE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderE164(&mut self) {
        self.senderE164.clear();
    }

    pub fn has_senderE164(&self) -> bool {
        self.senderE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderE164(&mut self, v: ::std::string::String) {
        self.senderE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderE164(&mut self) -> &mut ::std::string::String {
        if self.senderE164.is_none() {
            self.senderE164.set_default();
        }
        self.senderE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderE164(&mut self) -> ::std::string::String {
        self.senderE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string senderUuid = 3;


    pub fn get_senderUuid(&self) -> &str {
        match self.senderUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderUuid(&mut self) {
        self.senderUuid.clear();
    }

    pub fn has_senderUuid(&self) -> bool {
        self.senderUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderUuid(&mut self, v: ::std::string::String) {
        self.senderUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderUuid(&mut self) -> &mut ::std::string::String {
        if self.senderUuid.is_none() {
            self.senderUuid.set_default();
        }
        self.senderUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderUuid(&mut self) -> ::std::string::String {
        self.senderUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Viewed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.senderE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.senderE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Viewed {
        SyncMessage_Viewed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderE164",
                |m: &SyncMessage_Viewed| { &m.senderE164 },
                |m: &mut SyncMessage_Viewed| { &mut m.senderE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderUuid",
                |m: &SyncMessage_Viewed| { &m.senderUuid },
                |m: &mut SyncMessage_Viewed| { &mut m.senderUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_Viewed| { &m.timestamp },
                |m: &mut SyncMessage_Viewed| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Viewed>(
                "SyncMessage.Viewed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Viewed {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Viewed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Viewed::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Viewed {
    fn clear(&mut self) {
        self.senderE164.clear();
        self.senderUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Viewed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Viewed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Configuration {
    // message fields
    readReceipts: ::std::option::Option<bool>,
    unidentifiedDeliveryIndicators: ::std::option::Option<bool>,
    typingIndicators: ::std::option::Option<bool>,
    provisioningVersion: ::std::option::Option<u32>,
    linkPreviews: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Configuration {
    fn default() -> &'a SyncMessage_Configuration {
        <SyncMessage_Configuration as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Configuration {
    pub fn new() -> SyncMessage_Configuration {
        ::std::default::Default::default()
    }

    // optional bool readReceipts = 1;


    pub fn get_readReceipts(&self) -> bool {
        self.readReceipts.unwrap_or(false)
    }
    pub fn clear_readReceipts(&mut self) {
        self.readReceipts = ::std::option::Option::None;
    }

    pub fn has_readReceipts(&self) -> bool {
        self.readReceipts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readReceipts(&mut self, v: bool) {
        self.readReceipts = ::std::option::Option::Some(v);
    }

    // optional bool unidentifiedDeliveryIndicators = 2;


    pub fn get_unidentifiedDeliveryIndicators(&self) -> bool {
        self.unidentifiedDeliveryIndicators.unwrap_or(false)
    }
    pub fn clear_unidentifiedDeliveryIndicators(&mut self) {
        self.unidentifiedDeliveryIndicators = ::std::option::Option::None;
    }

    pub fn has_unidentifiedDeliveryIndicators(&self) -> bool {
        self.unidentifiedDeliveryIndicators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unidentifiedDeliveryIndicators(&mut self, v: bool) {
        self.unidentifiedDeliveryIndicators = ::std::option::Option::Some(v);
    }

    // optional bool typingIndicators = 3;


    pub fn get_typingIndicators(&self) -> bool {
        self.typingIndicators.unwrap_or(false)
    }
    pub fn clear_typingIndicators(&mut self) {
        self.typingIndicators = ::std::option::Option::None;
    }

    pub fn has_typingIndicators(&self) -> bool {
        self.typingIndicators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typingIndicators(&mut self, v: bool) {
        self.typingIndicators = ::std::option::Option::Some(v);
    }

    // optional uint32 provisioningVersion = 5;


    pub fn get_provisioningVersion(&self) -> u32 {
        self.provisioningVersion.unwrap_or(0)
    }
    pub fn clear_provisioningVersion(&mut self) {
        self.provisioningVersion = ::std::option::Option::None;
    }

    pub fn has_provisioningVersion(&self) -> bool {
        self.provisioningVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provisioningVersion(&mut self, v: u32) {
        self.provisioningVersion = ::std::option::Option::Some(v);
    }

    // optional bool linkPreviews = 6;


    pub fn get_linkPreviews(&self) -> bool {
        self.linkPreviews.unwrap_or(false)
    }
    pub fn clear_linkPreviews(&mut self) {
        self.linkPreviews = ::std::option::Option::None;
    }

    pub fn has_linkPreviews(&self) -> bool {
        self.linkPreviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linkPreviews(&mut self, v: bool) {
        self.linkPreviews = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_Configuration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readReceipts = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unidentifiedDeliveryIndicators = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.typingIndicators = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.provisioningVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.linkPreviews = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.readReceipts {
            my_size += 2;
        }
        if let Some(v) = self.unidentifiedDeliveryIndicators {
            my_size += 2;
        }
        if let Some(v) = self.typingIndicators {
            my_size += 2;
        }
        if let Some(v) = self.provisioningVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.linkPreviews {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.readReceipts {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.unidentifiedDeliveryIndicators {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.typingIndicators {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.provisioningVersion {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.linkPreviews {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Configuration {
        SyncMessage_Configuration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readReceipts",
                |m: &SyncMessage_Configuration| { &m.readReceipts },
                |m: &mut SyncMessage_Configuration| { &mut m.readReceipts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unidentifiedDeliveryIndicators",
                |m: &SyncMessage_Configuration| { &m.unidentifiedDeliveryIndicators },
                |m: &mut SyncMessage_Configuration| { &mut m.unidentifiedDeliveryIndicators },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "typingIndicators",
                |m: &SyncMessage_Configuration| { &m.typingIndicators },
                |m: &mut SyncMessage_Configuration| { &mut m.typingIndicators },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "provisioningVersion",
                |m: &SyncMessage_Configuration| { &m.provisioningVersion },
                |m: &mut SyncMessage_Configuration| { &mut m.provisioningVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "linkPreviews",
                |m: &SyncMessage_Configuration| { &m.linkPreviews },
                |m: &mut SyncMessage_Configuration| { &mut m.linkPreviews },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Configuration>(
                "SyncMessage.Configuration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Configuration {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Configuration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Configuration::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Configuration {
    fn clear(&mut self) {
        self.readReceipts = ::std::option::Option::None;
        self.unidentifiedDeliveryIndicators = ::std::option::Option::None;
        self.typingIndicators = ::std::option::Option::None;
        self.provisioningVersion = ::std::option::Option::None;
        self.linkPreviews = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Configuration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_StickerPackOperation {
    // message fields
    packId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    packKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<SyncMessage_StickerPackOperation_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_StickerPackOperation {
    fn default() -> &'a SyncMessage_StickerPackOperation {
        <SyncMessage_StickerPackOperation as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_StickerPackOperation {
    pub fn new() -> SyncMessage_StickerPackOperation {
        ::std::default::Default::default()
    }

    // optional bytes packId = 1;


    pub fn get_packId(&self) -> &[u8] {
        match self.packId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packId(&mut self) {
        self.packId.clear();
    }

    pub fn has_packId(&self) -> bool {
        self.packId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packId(&mut self, v: ::std::vec::Vec<u8>) {
        self.packId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packId.is_none() {
            self.packId.set_default();
        }
        self.packId.as_mut().unwrap()
    }

    // Take field
    pub fn take_packId(&mut self) -> ::std::vec::Vec<u8> {
        self.packId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes packKey = 2;


    pub fn get_packKey(&self) -> &[u8] {
        match self.packKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_packKey(&mut self) {
        self.packKey.clear();
    }

    pub fn has_packKey(&self) -> bool {
        self.packKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.packKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packKey.is_none() {
            self.packKey.set_default();
        }
        self.packKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_packKey(&mut self) -> ::std::vec::Vec<u8> {
        self.packKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.SyncMessage.StickerPackOperation.Type type = 3;


    pub fn get_field_type(&self) -> SyncMessage_StickerPackOperation_Type {
        self.field_type.unwrap_or(SyncMessage_StickerPackOperation_Type::INSTALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_StickerPackOperation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_StickerPackOperation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packKey)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.packKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packId.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.packKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_StickerPackOperation {
        SyncMessage_StickerPackOperation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packId",
                |m: &SyncMessage_StickerPackOperation| { &m.packId },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.packId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "packKey",
                |m: &SyncMessage_StickerPackOperation| { &m.packKey },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.packKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_StickerPackOperation_Type>>(
                "type",
                |m: &SyncMessage_StickerPackOperation| { &m.field_type },
                |m: &mut SyncMessage_StickerPackOperation| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_StickerPackOperation>(
                "SyncMessage.StickerPackOperation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_StickerPackOperation {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_StickerPackOperation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_StickerPackOperation::new)
    }
}

impl ::protobuf::Clear for SyncMessage_StickerPackOperation {
    fn clear(&mut self) {
        self.packId.clear();
        self.packKey.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_StickerPackOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_StickerPackOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_StickerPackOperation_Type {
    INSTALL = 0,
    REMOVE = 1,
}

impl ::protobuf::ProtobufEnum for SyncMessage_StickerPackOperation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_StickerPackOperation_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_StickerPackOperation_Type::INSTALL),
            1 => ::std::option::Option::Some(SyncMessage_StickerPackOperation_Type::REMOVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_StickerPackOperation_Type] = &[
            SyncMessage_StickerPackOperation_Type::INSTALL,
            SyncMessage_StickerPackOperation_Type::REMOVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_StickerPackOperation_Type>("SyncMessage.StickerPackOperation.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_StickerPackOperation_Type {
}

impl ::std::default::Default for SyncMessage_StickerPackOperation_Type {
    fn default() -> Self {
        SyncMessage_StickerPackOperation_Type::INSTALL
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_StickerPackOperation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_ViewOnceOpen {
    // message fields
    senderE164: ::protobuf::SingularField<::std::string::String>,
    senderUuid: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_ViewOnceOpen {
    fn default() -> &'a SyncMessage_ViewOnceOpen {
        <SyncMessage_ViewOnceOpen as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_ViewOnceOpen {
    pub fn new() -> SyncMessage_ViewOnceOpen {
        ::std::default::Default::default()
    }

    // optional string senderE164 = 1;


    pub fn get_senderE164(&self) -> &str {
        match self.senderE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderE164(&mut self) {
        self.senderE164.clear();
    }

    pub fn has_senderE164(&self) -> bool {
        self.senderE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderE164(&mut self, v: ::std::string::String) {
        self.senderE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderE164(&mut self) -> &mut ::std::string::String {
        if self.senderE164.is_none() {
            self.senderE164.set_default();
        }
        self.senderE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderE164(&mut self) -> ::std::string::String {
        self.senderE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string senderUuid = 3;


    pub fn get_senderUuid(&self) -> &str {
        match self.senderUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_senderUuid(&mut self) {
        self.senderUuid.clear();
    }

    pub fn has_senderUuid(&self) -> bool {
        self.senderUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderUuid(&mut self, v: ::std::string::String) {
        self.senderUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderUuid(&mut self) -> &mut ::std::string::String {
        if self.senderUuid.is_none() {
            self.senderUuid.set_default();
        }
        self.senderUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderUuid(&mut self) -> ::std::string::String {
        self.senderUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_ViewOnceOpen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderE164)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.senderUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.senderE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.senderE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.senderUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_ViewOnceOpen {
        SyncMessage_ViewOnceOpen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderE164",
                |m: &SyncMessage_ViewOnceOpen| { &m.senderE164 },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.senderE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "senderUuid",
                |m: &SyncMessage_ViewOnceOpen| { &m.senderUuid },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.senderUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &SyncMessage_ViewOnceOpen| { &m.timestamp },
                |m: &mut SyncMessage_ViewOnceOpen| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_ViewOnceOpen>(
                "SyncMessage.ViewOnceOpen",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_ViewOnceOpen {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_ViewOnceOpen> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_ViewOnceOpen::new)
    }
}

impl ::protobuf::Clear for SyncMessage_ViewOnceOpen {
    fn clear(&mut self) {
        self.senderE164.clear();
        self.senderUuid.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_ViewOnceOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_ViewOnceOpen {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_FetchLatest {
    // message fields
    field_type: ::std::option::Option<SyncMessage_FetchLatest_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_FetchLatest {
    fn default() -> &'a SyncMessage_FetchLatest {
        <SyncMessage_FetchLatest as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_FetchLatest {
    pub fn new() -> SyncMessage_FetchLatest {
        ::std::default::Default::default()
    }

    // optional .signalservice.SyncMessage.FetchLatest.Type type = 1;


    pub fn get_field_type(&self) -> SyncMessage_FetchLatest_Type {
        self.field_type.unwrap_or(SyncMessage_FetchLatest_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_FetchLatest_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_FetchLatest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_FetchLatest {
        SyncMessage_FetchLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_FetchLatest_Type>>(
                "type",
                |m: &SyncMessage_FetchLatest| { &m.field_type },
                |m: &mut SyncMessage_FetchLatest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_FetchLatest>(
                "SyncMessage.FetchLatest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_FetchLatest {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_FetchLatest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_FetchLatest::new)
    }
}

impl ::protobuf::Clear for SyncMessage_FetchLatest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_FetchLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_FetchLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_FetchLatest_Type {
    UNKNOWN = 0,
    LOCAL_PROFILE = 1,
    STORAGE_MANIFEST = 2,
}

impl ::protobuf::ProtobufEnum for SyncMessage_FetchLatest_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_FetchLatest_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::UNKNOWN),
            1 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::LOCAL_PROFILE),
            2 => ::std::option::Option::Some(SyncMessage_FetchLatest_Type::STORAGE_MANIFEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_FetchLatest_Type] = &[
            SyncMessage_FetchLatest_Type::UNKNOWN,
            SyncMessage_FetchLatest_Type::LOCAL_PROFILE,
            SyncMessage_FetchLatest_Type::STORAGE_MANIFEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_FetchLatest_Type>("SyncMessage.FetchLatest.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_FetchLatest_Type {
}

impl ::std::default::Default for SyncMessage_FetchLatest_Type {
    fn default() -> Self {
        SyncMessage_FetchLatest_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_FetchLatest_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_Keys {
    // message fields
    storageService: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_Keys {
    fn default() -> &'a SyncMessage_Keys {
        <SyncMessage_Keys as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_Keys {
    pub fn new() -> SyncMessage_Keys {
        ::std::default::Default::default()
    }

    // optional bytes storageService = 1;


    pub fn get_storageService(&self) -> &[u8] {
        match self.storageService.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_storageService(&mut self) {
        self.storageService.clear();
    }

    pub fn has_storageService(&self) -> bool {
        self.storageService.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageService(&mut self, v: ::std::vec::Vec<u8>) {
        self.storageService = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageService(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.storageService.is_none() {
            self.storageService.set_default();
        }
        self.storageService.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageService(&mut self) -> ::std::vec::Vec<u8> {
        self.storageService.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SyncMessage_Keys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.storageService)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageService.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageService.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_Keys {
        SyncMessage_Keys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "storageService",
                |m: &SyncMessage_Keys| { &m.storageService },
                |m: &mut SyncMessage_Keys| { &mut m.storageService },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_Keys>(
                "SyncMessage.Keys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_Keys {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_Keys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_Keys::new)
    }
}

impl ::protobuf::Clear for SyncMessage_Keys {
    fn clear(&mut self) {
        self.storageService.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_Keys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_Keys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_MessageRequestResponse {
    // message fields
    threadE164: ::protobuf::SingularField<::std::string::String>,
    threadUuid: ::protobuf::SingularField<::std::string::String>,
    groupId: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<SyncMessage_MessageRequestResponse_Type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_MessageRequestResponse {
    fn default() -> &'a SyncMessage_MessageRequestResponse {
        <SyncMessage_MessageRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_MessageRequestResponse {
    pub fn new() -> SyncMessage_MessageRequestResponse {
        ::std::default::Default::default()
    }

    // optional string threadE164 = 1;


    pub fn get_threadE164(&self) -> &str {
        match self.threadE164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_threadE164(&mut self) {
        self.threadE164.clear();
    }

    pub fn has_threadE164(&self) -> bool {
        self.threadE164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadE164(&mut self, v: ::std::string::String) {
        self.threadE164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_threadE164(&mut self) -> &mut ::std::string::String {
        if self.threadE164.is_none() {
            self.threadE164.set_default();
        }
        self.threadE164.as_mut().unwrap()
    }

    // Take field
    pub fn take_threadE164(&mut self) -> ::std::string::String {
        self.threadE164.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string threadUuid = 2;


    pub fn get_threadUuid(&self) -> &str {
        match self.threadUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_threadUuid(&mut self) {
        self.threadUuid.clear();
    }

    pub fn has_threadUuid(&self) -> bool {
        self.threadUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadUuid(&mut self, v: ::std::string::String) {
        self.threadUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_threadUuid(&mut self) -> &mut ::std::string::String {
        if self.threadUuid.is_none() {
            self.threadUuid.set_default();
        }
        self.threadUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_threadUuid(&mut self) -> ::std::string::String {
        self.threadUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes groupId = 3;


    pub fn get_groupId(&self) -> &[u8] {
        match self.groupId.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_groupId(&mut self) {
        self.groupId.clear();
    }

    pub fn has_groupId(&self) -> bool {
        self.groupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: ::std::vec::Vec<u8>) {
        self.groupId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.groupId.is_none() {
            self.groupId.set_default();
        }
        self.groupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupId(&mut self) -> ::std::vec::Vec<u8> {
        self.groupId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.SyncMessage.MessageRequestResponse.Type type = 4;


    pub fn get_field_type(&self) -> SyncMessage_MessageRequestResponse_Type {
        self.field_type.unwrap_or(SyncMessage_MessageRequestResponse_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SyncMessage_MessageRequestResponse_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SyncMessage_MessageRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.threadE164)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.threadUuid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.groupId)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.threadE164.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.threadUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.threadE164.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.threadUuid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupId.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_MessageRequestResponse {
        SyncMessage_MessageRequestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "threadE164",
                |m: &SyncMessage_MessageRequestResponse| { &m.threadE164 },
                |m: &mut SyncMessage_MessageRequestResponse| { &mut m.threadE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "threadUuid",
                |m: &SyncMessage_MessageRequestResponse| { &m.threadUuid },
                |m: &mut SyncMessage_MessageRequestResponse| { &mut m.threadUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupId",
                |m: &SyncMessage_MessageRequestResponse| { &m.groupId },
                |m: &mut SyncMessage_MessageRequestResponse| { &mut m.groupId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SyncMessage_MessageRequestResponse_Type>>(
                "type",
                |m: &SyncMessage_MessageRequestResponse| { &m.field_type },
                |m: &mut SyncMessage_MessageRequestResponse| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_MessageRequestResponse>(
                "SyncMessage.MessageRequestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_MessageRequestResponse {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_MessageRequestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_MessageRequestResponse::new)
    }
}

impl ::protobuf::Clear for SyncMessage_MessageRequestResponse {
    fn clear(&mut self) {
        self.threadE164.clear();
        self.threadUuid.clear();
        self.groupId.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_MessageRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_MessageRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_MessageRequestResponse_Type {
    UNKNOWN = 0,
    ACCEPT = 1,
    DELETE = 2,
    BLOCK = 3,
    BLOCK_AND_DELETE = 4,
}

impl ::protobuf::ProtobufEnum for SyncMessage_MessageRequestResponse_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SyncMessage_MessageRequestResponse_Type> {
        match value {
            0 => ::std::option::Option::Some(SyncMessage_MessageRequestResponse_Type::UNKNOWN),
            1 => ::std::option::Option::Some(SyncMessage_MessageRequestResponse_Type::ACCEPT),
            2 => ::std::option::Option::Some(SyncMessage_MessageRequestResponse_Type::DELETE),
            3 => ::std::option::Option::Some(SyncMessage_MessageRequestResponse_Type::BLOCK),
            4 => ::std::option::Option::Some(SyncMessage_MessageRequestResponse_Type::BLOCK_AND_DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SyncMessage_MessageRequestResponse_Type] = &[
            SyncMessage_MessageRequestResponse_Type::UNKNOWN,
            SyncMessage_MessageRequestResponse_Type::ACCEPT,
            SyncMessage_MessageRequestResponse_Type::DELETE,
            SyncMessage_MessageRequestResponse_Type::BLOCK,
            SyncMessage_MessageRequestResponse_Type::BLOCK_AND_DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SyncMessage_MessageRequestResponse_Type>("SyncMessage.MessageRequestResponse.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SyncMessage_MessageRequestResponse_Type {
}

impl ::std::default::Default for SyncMessage_MessageRequestResponse_Type {
    fn default() -> Self {
        SyncMessage_MessageRequestResponse_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_MessageRequestResponse_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_OutgoingPayment {
    // message fields
    recipientUuid: ::protobuf::SingularField<::std::string::String>,
    note: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub paymentDetail: ::std::option::Option<SyncMessage_OutgoingPayment_oneof_paymentDetail>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_OutgoingPayment {
    fn default() -> &'a SyncMessage_OutgoingPayment {
        <SyncMessage_OutgoingPayment as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum SyncMessage_OutgoingPayment_oneof_paymentDetail {
    mobileCoin(SyncMessage_OutgoingPayment_MobileCoin),
}

impl SyncMessage_OutgoingPayment {
    pub fn new() -> SyncMessage_OutgoingPayment {
        ::std::default::Default::default()
    }

    // optional string recipientUuid = 1;


    pub fn get_recipientUuid(&self) -> &str {
        match self.recipientUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_recipientUuid(&mut self) {
        self.recipientUuid.clear();
    }

    pub fn has_recipientUuid(&self) -> bool {
        self.recipientUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientUuid(&mut self, v: ::std::string::String) {
        self.recipientUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipientUuid(&mut self) -> &mut ::std::string::String {
        if self.recipientUuid.is_none() {
            self.recipientUuid.set_default();
        }
        self.recipientUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipientUuid(&mut self) -> ::std::string::String {
        self.recipientUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string note = 2;


    pub fn get_note(&self) -> &str {
        match self.note.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        self.note.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.SyncMessage.OutgoingPayment.MobileCoin mobileCoin = 3;


    pub fn get_mobileCoin(&self) -> &SyncMessage_OutgoingPayment_MobileCoin {
        match self.paymentDetail {
            ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(ref v)) => v,
            _ => <SyncMessage_OutgoingPayment_MobileCoin as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mobileCoin(&mut self) {
        self.paymentDetail = ::std::option::Option::None;
    }

    pub fn has_mobileCoin(&self) -> bool {
        match self.paymentDetail {
            ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mobileCoin(&mut self, v: SyncMessage_OutgoingPayment_MobileCoin) {
        self.paymentDetail = ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mobileCoin(&mut self) -> &mut SyncMessage_OutgoingPayment_MobileCoin {
        if let ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(_)) = self.paymentDetail {
        } else {
            self.paymentDetail = ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(SyncMessage_OutgoingPayment_MobileCoin::new()));
        }
        match self.paymentDetail {
            ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mobileCoin(&mut self) -> SyncMessage_OutgoingPayment_MobileCoin {
        if self.has_mobileCoin() {
            match self.paymentDetail.take() {
                ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncMessage_OutgoingPayment_MobileCoin::new()
        }
    }
}

impl ::protobuf::Message for SyncMessage_OutgoingPayment {
    fn is_initialized(&self) -> bool {
        if let Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(ref v)) = self.paymentDetail {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recipientUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.note)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.paymentDetail = ::std::option::Option::Some(SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recipientUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.note.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.paymentDetail {
            match v {
                &SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recipientUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.note.as_ref() {
            os.write_string(2, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.paymentDetail {
            match v {
                &SyncMessage_OutgoingPayment_oneof_paymentDetail::mobileCoin(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_OutgoingPayment {
        SyncMessage_OutgoingPayment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipientUuid",
                |m: &SyncMessage_OutgoingPayment| { &m.recipientUuid },
                |m: &mut SyncMessage_OutgoingPayment| { &mut m.recipientUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "note",
                |m: &SyncMessage_OutgoingPayment| { &m.note },
                |m: &mut SyncMessage_OutgoingPayment| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncMessage_OutgoingPayment_MobileCoin>(
                "mobileCoin",
                SyncMessage_OutgoingPayment::has_mobileCoin,
                SyncMessage_OutgoingPayment::get_mobileCoin,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_OutgoingPayment>(
                "SyncMessage.OutgoingPayment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_OutgoingPayment {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_OutgoingPayment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_OutgoingPayment::new)
    }
}

impl ::protobuf::Clear for SyncMessage_OutgoingPayment {
    fn clear(&mut self) {
        self.recipientUuid.clear();
        self.note.clear();
        self.paymentDetail = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_OutgoingPayment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_OutgoingPayment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SyncMessage_OutgoingPayment_MobileCoin {
    // message fields
    recipientAddress: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    amountPicoMob: ::std::option::Option<u64>,
    feePicoMob: ::std::option::Option<u64>,
    receipt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ledgerBlockTimestamp: ::std::option::Option<u64>,
    ledgerBlockIndex: ::std::option::Option<u64>,
    pub spentKeyImages: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub outputPublicKeys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncMessage_OutgoingPayment_MobileCoin {
    fn default() -> &'a SyncMessage_OutgoingPayment_MobileCoin {
        <SyncMessage_OutgoingPayment_MobileCoin as ::protobuf::Message>::default_instance()
    }
}

impl SyncMessage_OutgoingPayment_MobileCoin {
    pub fn new() -> SyncMessage_OutgoingPayment_MobileCoin {
        ::std::default::Default::default()
    }

    // optional bytes recipientAddress = 1;


    pub fn get_recipientAddress(&self) -> &[u8] {
        match self.recipientAddress.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_recipientAddress(&mut self) {
        self.recipientAddress.clear();
    }

    pub fn has_recipientAddress(&self) -> bool {
        self.recipientAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipientAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipientAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recipientAddress.is_none() {
            self.recipientAddress.set_default();
        }
        self.recipientAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipientAddress(&mut self) -> ::std::vec::Vec<u8> {
        self.recipientAddress.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 amountPicoMob = 2;


    pub fn get_amountPicoMob(&self) -> u64 {
        self.amountPicoMob.unwrap_or(0)
    }
    pub fn clear_amountPicoMob(&mut self) {
        self.amountPicoMob = ::std::option::Option::None;
    }

    pub fn has_amountPicoMob(&self) -> bool {
        self.amountPicoMob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amountPicoMob(&mut self, v: u64) {
        self.amountPicoMob = ::std::option::Option::Some(v);
    }

    // optional uint64 feePicoMob = 3;


    pub fn get_feePicoMob(&self) -> u64 {
        self.feePicoMob.unwrap_or(0)
    }
    pub fn clear_feePicoMob(&mut self) {
        self.feePicoMob = ::std::option::Option::None;
    }

    pub fn has_feePicoMob(&self) -> bool {
        self.feePicoMob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feePicoMob(&mut self, v: u64) {
        self.feePicoMob = ::std::option::Option::Some(v);
    }

    // optional bytes receipt = 4;


    pub fn get_receipt(&self) -> &[u8] {
        match self.receipt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    pub fn has_receipt(&self) -> bool {
        self.receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.receipt.is_none() {
            self.receipt.set_default();
        }
        self.receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        self.receipt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 ledgerBlockTimestamp = 5;


    pub fn get_ledgerBlockTimestamp(&self) -> u64 {
        self.ledgerBlockTimestamp.unwrap_or(0)
    }
    pub fn clear_ledgerBlockTimestamp(&mut self) {
        self.ledgerBlockTimestamp = ::std::option::Option::None;
    }

    pub fn has_ledgerBlockTimestamp(&self) -> bool {
        self.ledgerBlockTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerBlockTimestamp(&mut self, v: u64) {
        self.ledgerBlockTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 ledgerBlockIndex = 6;


    pub fn get_ledgerBlockIndex(&self) -> u64 {
        self.ledgerBlockIndex.unwrap_or(0)
    }
    pub fn clear_ledgerBlockIndex(&mut self) {
        self.ledgerBlockIndex = ::std::option::Option::None;
    }

    pub fn has_ledgerBlockIndex(&self) -> bool {
        self.ledgerBlockIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerBlockIndex(&mut self, v: u64) {
        self.ledgerBlockIndex = ::std::option::Option::Some(v);
    }

    // repeated bytes spentKeyImages = 7;


    pub fn get_spentKeyImages(&self) -> &[::std::vec::Vec<u8>] {
        &self.spentKeyImages
    }
    pub fn clear_spentKeyImages(&mut self) {
        self.spentKeyImages.clear();
    }

    // Param is passed by value, moved
    pub fn set_spentKeyImages(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.spentKeyImages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spentKeyImages(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.spentKeyImages
    }

    // Take field
    pub fn take_spentKeyImages(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.spentKeyImages, ::protobuf::RepeatedField::new())
    }

    // repeated bytes outputPublicKeys = 8;


    pub fn get_outputPublicKeys(&self) -> &[::std::vec::Vec<u8>] {
        &self.outputPublicKeys
    }
    pub fn clear_outputPublicKeys(&mut self) {
        self.outputPublicKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputPublicKeys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.outputPublicKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputPublicKeys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.outputPublicKeys
    }

    // Take field
    pub fn take_outputPublicKeys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.outputPublicKeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncMessage_OutgoingPayment_MobileCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.recipientAddress)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amountPicoMob = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.feePicoMob = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledgerBlockTimestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledgerBlockIndex = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.spentKeyImages)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.outputPublicKeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recipientAddress.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.amountPicoMob {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.feePicoMob {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.receipt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ledgerBlockTimestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ledgerBlockIndex {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.spentKeyImages {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        for value in &self.outputPublicKeys {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recipientAddress.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.amountPicoMob {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.feePicoMob {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.receipt.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.ledgerBlockTimestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.ledgerBlockIndex {
            os.write_uint64(6, v)?;
        }
        for v in &self.spentKeyImages {
            os.write_bytes(7, &v)?;
        };
        for v in &self.outputPublicKeys {
            os.write_bytes(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncMessage_OutgoingPayment_MobileCoin {
        SyncMessage_OutgoingPayment_MobileCoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "recipientAddress",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.recipientAddress },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.recipientAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amountPicoMob",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.amountPicoMob },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.amountPicoMob },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "feePicoMob",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.feePicoMob },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.feePicoMob },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "receipt",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.receipt },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.receipt },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ledgerBlockTimestamp",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.ledgerBlockTimestamp },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.ledgerBlockTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ledgerBlockIndex",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.ledgerBlockIndex },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.ledgerBlockIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spentKeyImages",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.spentKeyImages },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.spentKeyImages },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "outputPublicKeys",
                |m: &SyncMessage_OutgoingPayment_MobileCoin| { &m.outputPublicKeys },
                |m: &mut SyncMessage_OutgoingPayment_MobileCoin| { &mut m.outputPublicKeys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncMessage_OutgoingPayment_MobileCoin>(
                "SyncMessage.OutgoingPayment.MobileCoin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncMessage_OutgoingPayment_MobileCoin {
        static instance: ::protobuf::rt::LazyV2<SyncMessage_OutgoingPayment_MobileCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncMessage_OutgoingPayment_MobileCoin::new)
    }
}

impl ::protobuf::Clear for SyncMessage_OutgoingPayment_MobileCoin {
    fn clear(&mut self) {
        self.recipientAddress.clear();
        self.amountPicoMob = ::std::option::Option::None;
        self.feePicoMob = ::std::option::Option::None;
        self.receipt.clear();
        self.ledgerBlockTimestamp = ::std::option::Option::None;
        self.ledgerBlockIndex = ::std::option::Option::None;
        self.spentKeyImages.clear();
        self.outputPublicKeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncMessage_OutgoingPayment_MobileCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncMessage_OutgoingPayment_MobileCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AttachmentPointer {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    size: ::std::option::Option<u32>,
    thumbnail: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    digest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fileName: ::protobuf::SingularField<::std::string::String>,
    flags: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    caption: ::protobuf::SingularField<::std::string::String>,
    blurHash: ::protobuf::SingularField<::std::string::String>,
    uploadTimestamp: ::std::option::Option<u64>,
    cdnNumber: ::std::option::Option<u32>,
    // message oneof groups
    pub attachment_identifier: ::std::option::Option<AttachmentPointer_oneof_attachment_identifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachmentPointer {
    fn default() -> &'a AttachmentPointer {
        <AttachmentPointer as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AttachmentPointer_oneof_attachment_identifier {
    cdnId(u64),
    cdnKey(::std::string::String),
}

impl AttachmentPointer {
    pub fn new() -> AttachmentPointer {
        ::std::default::Default::default()
    }

    // optional fixed64 cdnId = 1;


    pub fn get_cdnId(&self) -> u64 {
        match self.attachment_identifier {
            ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnId(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cdnId(&mut self) {
        self.attachment_identifier = ::std::option::Option::None;
    }

    pub fn has_cdnId(&self) -> bool {
        match self.attachment_identifier {
            ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cdnId(&mut self, v: u64) {
        self.attachment_identifier = ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnId(v))
    }

    // optional string cdnKey = 15;


    pub fn get_cdnKey(&self) -> &str {
        match self.attachment_identifier {
            ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cdnKey(&mut self) {
        self.attachment_identifier = ::std::option::Option::None;
    }

    pub fn has_cdnKey(&self) -> bool {
        match self.attachment_identifier {
            ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cdnKey(&mut self, v: ::std::string::String) {
        self.attachment_identifier = ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cdnKey(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(_)) = self.attachment_identifier {
        } else {
            self.attachment_identifier = ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(::std::string::String::new()));
        }
        match self.attachment_identifier {
            ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cdnKey(&mut self) -> ::std::string::String {
        if self.has_cdnKey() {
            match self.attachment_identifier.take() {
                ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string contentType = 2;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 size = 4;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional bytes thumbnail = 5;


    pub fn get_thumbnail(&self) -> &[u8] {
        match self.thumbnail.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_thumbnail(&mut self) {
        self.thumbnail.clear();
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail.is_none() {
            self.thumbnail.set_default();
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes digest = 6;


    pub fn get_digest(&self) -> &[u8] {
        match self.digest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    pub fn has_digest(&self) -> bool {
        self.digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.digest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.digest.is_none() {
            self.digest.set_default();
        }
        self.digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::vec::Vec<u8> {
        self.digest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string fileName = 7;


    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fileName(&mut self) {
        self.fileName.clear();
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName.set_default();
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flags = 8;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 9;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 10;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional string caption = 11;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string blurHash = 12;


    pub fn get_blurHash(&self) -> &str {
        match self.blurHash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blurHash(&mut self) {
        self.blurHash.clear();
    }

    pub fn has_blurHash(&self) -> bool {
        self.blurHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blurHash(&mut self, v: ::std::string::String) {
        self.blurHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blurHash(&mut self) -> &mut ::std::string::String {
        if self.blurHash.is_none() {
            self.blurHash.set_default();
        }
        self.blurHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_blurHash(&mut self) -> ::std::string::String {
        self.blurHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 uploadTimestamp = 13;


    pub fn get_uploadTimestamp(&self) -> u64 {
        self.uploadTimestamp.unwrap_or(0)
    }
    pub fn clear_uploadTimestamp(&mut self) {
        self.uploadTimestamp = ::std::option::Option::None;
    }

    pub fn has_uploadTimestamp(&self) -> bool {
        self.uploadTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uploadTimestamp(&mut self, v: u64) {
        self.uploadTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 cdnNumber = 14;


    pub fn get_cdnNumber(&self) -> u32 {
        self.cdnNumber.unwrap_or(0)
    }
    pub fn clear_cdnNumber(&mut self) {
        self.cdnNumber = ::std::option::Option::None;
    }

    pub fn has_cdnNumber(&self) -> bool {
        self.cdnNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cdnNumber(&mut self, v: u32) {
        self.cdnNumber = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AttachmentPointer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.attachment_identifier = ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnId(is.read_fixed64()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.attachment_identifier = ::std::option::Option::Some(AttachmentPointer_oneof_attachment_identifier::cdnKey(is.read_string()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.thumbnail)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.digest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blurHash)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uploadTimestamp = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cdnNumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.blurHash.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.uploadTimestamp {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cdnNumber {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.attachment_identifier {
            match v {
                &AttachmentPointer_oneof_attachment_identifier::cdnId(v) => {
                    my_size += 9;
                },
                &AttachmentPointer_oneof_attachment_identifier::cdnKey(ref v) => {
                    my_size += ::protobuf::rt::string_size(15, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.thumbnail.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.digest.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.fileName.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.blurHash.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.uploadTimestamp {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.cdnNumber {
            os.write_uint32(14, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.attachment_identifier {
            match v {
                &AttachmentPointer_oneof_attachment_identifier::cdnId(v) => {
                    os.write_fixed64(1, v)?;
                },
                &AttachmentPointer_oneof_attachment_identifier::cdnKey(ref v) => {
                    os.write_string(15, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachmentPointer {
        AttachmentPointer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "cdnId",
                AttachmentPointer::has_cdnId,
                AttachmentPointer::get_cdnId,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cdnKey",
                AttachmentPointer::has_cdnKey,
                AttachmentPointer::get_cdnKey,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &AttachmentPointer| { &m.contentType },
                |m: &mut AttachmentPointer| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &AttachmentPointer| { &m.key },
                |m: &mut AttachmentPointer| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &AttachmentPointer| { &m.size },
                |m: &mut AttachmentPointer| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "thumbnail",
                |m: &AttachmentPointer| { &m.thumbnail },
                |m: &mut AttachmentPointer| { &mut m.thumbnail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "digest",
                |m: &AttachmentPointer| { &m.digest },
                |m: &mut AttachmentPointer| { &mut m.digest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fileName",
                |m: &AttachmentPointer| { &m.fileName },
                |m: &mut AttachmentPointer| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &AttachmentPointer| { &m.flags },
                |m: &mut AttachmentPointer| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &AttachmentPointer| { &m.width },
                |m: &mut AttachmentPointer| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &AttachmentPointer| { &m.height },
                |m: &mut AttachmentPointer| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &AttachmentPointer| { &m.caption },
                |m: &mut AttachmentPointer| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blurHash",
                |m: &AttachmentPointer| { &m.blurHash },
                |m: &mut AttachmentPointer| { &mut m.blurHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "uploadTimestamp",
                |m: &AttachmentPointer| { &m.uploadTimestamp },
                |m: &mut AttachmentPointer| { &mut m.uploadTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cdnNumber",
                |m: &AttachmentPointer| { &m.cdnNumber },
                |m: &mut AttachmentPointer| { &mut m.cdnNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachmentPointer>(
                "AttachmentPointer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachmentPointer {
        static instance: ::protobuf::rt::LazyV2<AttachmentPointer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachmentPointer::new)
    }
}

impl ::protobuf::Clear for AttachmentPointer {
    fn clear(&mut self) {
        self.attachment_identifier = ::std::option::Option::None;
        self.attachment_identifier = ::std::option::Option::None;
        self.contentType.clear();
        self.key.clear();
        self.size = ::std::option::Option::None;
        self.thumbnail.clear();
        self.digest.clear();
        self.fileName.clear();
        self.flags = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.caption.clear();
        self.blurHash.clear();
        self.uploadTimestamp = ::std::option::Option::None;
        self.cdnNumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachmentPointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachmentPointer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AttachmentPointer_Flags {
    VOICE_MESSAGE = 1,
    BORDERLESS = 2,
    GIF = 4,
}

impl ::protobuf::ProtobufEnum for AttachmentPointer_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttachmentPointer_Flags> {
        match value {
            1 => ::std::option::Option::Some(AttachmentPointer_Flags::VOICE_MESSAGE),
            2 => ::std::option::Option::Some(AttachmentPointer_Flags::BORDERLESS),
            4 => ::std::option::Option::Some(AttachmentPointer_Flags::GIF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttachmentPointer_Flags] = &[
            AttachmentPointer_Flags::VOICE_MESSAGE,
            AttachmentPointer_Flags::BORDERLESS,
            AttachmentPointer_Flags::GIF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AttachmentPointer_Flags>("AttachmentPointer.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AttachmentPointer_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AttachmentPointer_Flags {
    fn default() -> Self {
        AttachmentPointer_Flags::VOICE_MESSAGE
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachmentPointer_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupContext {
    // message fields
    id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<GroupContext_Type>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub membersE164: ::protobuf::RepeatedField<::std::string::String>,
    pub members: ::protobuf::RepeatedField<GroupContext_Member>,
    pub avatar: ::protobuf::SingularPtrField<AttachmentPointer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupContext {
    fn default() -> &'a GroupContext {
        <GroupContext as ::protobuf::Message>::default_instance()
    }
}

impl GroupContext {
    pub fn new() -> GroupContext {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .signalservice.GroupContext.Type type = 2;


    pub fn get_field_type(&self) -> GroupContext_Type {
        self.field_type.unwrap_or(GroupContext_Type::UNKNOWN)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: GroupContext_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string membersE164 = 4;


    pub fn get_membersE164(&self) -> &[::std::string::String] {
        &self.membersE164
    }
    pub fn clear_membersE164(&mut self) {
        self.membersE164.clear();
    }

    // Param is passed by value, moved
    pub fn set_membersE164(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.membersE164 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_membersE164(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.membersE164
    }

    // Take field
    pub fn take_membersE164(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.membersE164, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupContext.Member members = 6;


    pub fn get_members(&self) -> &[GroupContext_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<GroupContext_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<GroupContext_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<GroupContext_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.AttachmentPointer avatar = 5;


    pub fn get_avatar(&self) -> &AttachmentPointer {
        self.avatar.as_ref().unwrap_or_else(|| <AttachmentPointer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: AttachmentPointer) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut AttachmentPointer {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> AttachmentPointer {
        self.avatar.take().unwrap_or_else(|| AttachmentPointer::new())
    }
}

impl ::protobuf::Message for GroupContext {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.membersE164)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.membersE164 {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.membersE164 {
            os.write_string(4, &v)?;
        };
        for v in &self.members {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupContext {
        GroupContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &GroupContext| { &m.id },
                |m: &mut GroupContext| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GroupContext_Type>>(
                "type",
                |m: &GroupContext| { &m.field_type },
                |m: &mut GroupContext| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GroupContext| { &m.name },
                |m: &mut GroupContext| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "membersE164",
                |m: &GroupContext| { &m.membersE164 },
                |m: &mut GroupContext| { &mut m.membersE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupContext_Member>>(
                "members",
                |m: &GroupContext| { &m.members },
                |m: &mut GroupContext| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachmentPointer>>(
                "avatar",
                |m: &GroupContext| { &m.avatar },
                |m: &mut GroupContext| { &mut m.avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupContext>(
                "GroupContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupContext {
        static instance: ::protobuf::rt::LazyV2<GroupContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupContext::new)
    }
}

impl ::protobuf::Clear for GroupContext {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = ::std::option::Option::None;
        self.name.clear();
        self.membersE164.clear();
        self.members.clear();
        self.avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupContext_Member {
    // message fields
    e164: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupContext_Member {
    fn default() -> &'a GroupContext_Member {
        <GroupContext_Member as ::protobuf::Message>::default_instance()
    }
}

impl GroupContext_Member {
    pub fn new() -> GroupContext_Member {
        ::std::default::Default::default()
    }

    // optional string e164 = 2;


    pub fn get_e164(&self) -> &str {
        match self.e164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_e164(&mut self) {
        self.e164.clear();
    }

    pub fn has_e164(&self) -> bool {
        self.e164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e164(&mut self, v: ::std::string::String) {
        self.e164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e164(&mut self) -> &mut ::std::string::String {
        if self.e164.is_none() {
            self.e164.set_default();
        }
        self.e164.as_mut().unwrap()
    }

    // Take field
    pub fn take_e164(&mut self) -> ::std::string::String {
        self.e164.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupContext_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.e164)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.e164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.e164.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupContext_Member {
        GroupContext_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "e164",
                |m: &GroupContext_Member| { &m.e164 },
                |m: &mut GroupContext_Member| { &mut m.e164 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupContext_Member>(
                "GroupContext.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupContext_Member {
        static instance: ::protobuf::rt::LazyV2<GroupContext_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupContext_Member::new)
    }
}

impl ::protobuf::Clear for GroupContext_Member {
    fn clear(&mut self) {
        self.e164.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupContext_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum GroupContext_Type {
    UNKNOWN = 0,
    UPDATE = 1,
    DELIVER = 2,
    QUIT = 3,
    REQUEST_INFO = 4,
}

impl ::protobuf::ProtobufEnum for GroupContext_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupContext_Type> {
        match value {
            0 => ::std::option::Option::Some(GroupContext_Type::UNKNOWN),
            1 => ::std::option::Option::Some(GroupContext_Type::UPDATE),
            2 => ::std::option::Option::Some(GroupContext_Type::DELIVER),
            3 => ::std::option::Option::Some(GroupContext_Type::QUIT),
            4 => ::std::option::Option::Some(GroupContext_Type::REQUEST_INFO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupContext_Type] = &[
            GroupContext_Type::UNKNOWN,
            GroupContext_Type::UPDATE,
            GroupContext_Type::DELIVER,
            GroupContext_Type::QUIT,
            GroupContext_Type::REQUEST_INFO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GroupContext_Type>("GroupContext.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GroupContext_Type {
}

impl ::std::default::Default for GroupContext_Type {
    fn default() -> Self {
        GroupContext_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContext_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupContextV2 {
    // message fields
    masterKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    revision: ::std::option::Option<u32>,
    groupChange: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupContextV2 {
    fn default() -> &'a GroupContextV2 {
        <GroupContextV2 as ::protobuf::Message>::default_instance()
    }
}

impl GroupContextV2 {
    pub fn new() -> GroupContextV2 {
        ::std::default::Default::default()
    }

    // optional bytes masterKey = 1;


    pub fn get_masterKey(&self) -> &[u8] {
        match self.masterKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_masterKey(&mut self) {
        self.masterKey.clear();
    }

    pub fn has_masterKey(&self) -> bool {
        self.masterKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masterKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.masterKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masterKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.masterKey.is_none() {
            self.masterKey.set_default();
        }
        self.masterKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_masterKey(&mut self) -> ::std::vec::Vec<u8> {
        self.masterKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 revision = 2;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional bytes groupChange = 3;


    pub fn get_groupChange(&self) -> &[u8] {
        match self.groupChange.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_groupChange(&mut self) {
        self.groupChange.clear();
    }

    pub fn has_groupChange(&self) -> bool {
        self.groupChange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupChange(&mut self, v: ::std::vec::Vec<u8>) {
        self.groupChange = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupChange(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.groupChange.is_none() {
            self.groupChange.set_default();
        }
        self.groupChange.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupChange(&mut self) -> ::std::vec::Vec<u8> {
        self.groupChange.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupContextV2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.masterKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.groupChange)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.masterKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.groupChange.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.masterKey.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.groupChange.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupContextV2 {
        GroupContextV2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "masterKey",
                |m: &GroupContextV2| { &m.masterKey },
                |m: &mut GroupContextV2| { &mut m.masterKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &GroupContextV2| { &m.revision },
                |m: &mut GroupContextV2| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupChange",
                |m: &GroupContextV2| { &m.groupChange },
                |m: &mut GroupContextV2| { &mut m.groupChange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupContextV2>(
                "GroupContextV2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupContextV2 {
        static instance: ::protobuf::rt::LazyV2<GroupContextV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupContextV2::new)
    }
}

impl ::protobuf::Clear for GroupContextV2 {
    fn clear(&mut self) {
        self.masterKey.clear();
        self.revision = ::std::option::Option::None;
        self.groupChange.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupContextV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupContextV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContactDetails {
    // message fields
    number: ::protobuf::SingularField<::std::string::String>,
    uuid: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub avatar: ::protobuf::SingularPtrField<ContactDetails_Avatar>,
    color: ::protobuf::SingularField<::std::string::String>,
    pub verified: ::protobuf::SingularPtrField<Verified>,
    profileKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blocked: ::std::option::Option<bool>,
    expireTimer: ::std::option::Option<u32>,
    inboxPosition: ::std::option::Option<u32>,
    archived: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactDetails {
    fn default() -> &'a ContactDetails {
        <ContactDetails as ::protobuf::Message>::default_instance()
    }
}

impl ContactDetails {
    pub fn new() -> ContactDetails {
        ::std::default::Default::default()
    }

    // optional string number = 1;


    pub fn get_number(&self) -> &str {
        match self.number.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::std::string::String) {
        self.number = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_number(&mut self) -> &mut ::std::string::String {
        if self.number.is_none() {
            self.number.set_default();
        }
        self.number.as_mut().unwrap()
    }

    // Take field
    pub fn take_number(&mut self) -> ::std::string::String {
        self.number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uuid = 9;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.ContactDetails.Avatar avatar = 3;


    pub fn get_avatar(&self) -> &ContactDetails_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <ContactDetails_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ContactDetails_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ContactDetails_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> ContactDetails_Avatar {
        self.avatar.take().unwrap_or_else(|| ContactDetails_Avatar::new())
    }

    // optional string color = 4;


    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        self.color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .signalservice.Verified verified = 5;


    pub fn get_verified(&self) -> &Verified {
        self.verified.as_ref().unwrap_or_else(|| <Verified as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verified(&mut self) {
        self.verified.clear();
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: Verified) {
        self.verified = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verified(&mut self) -> &mut Verified {
        if self.verified.is_none() {
            self.verified.set_default();
        }
        self.verified.as_mut().unwrap()
    }

    // Take field
    pub fn take_verified(&mut self) -> Verified {
        self.verified.take().unwrap_or_else(|| Verified::new())
    }

    // optional bytes profileKey = 6;


    pub fn get_profileKey(&self) -> &[u8] {
        match self.profileKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    pub fn has_profileKey(&self) -> bool {
        self.profileKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.profileKey.is_none() {
            self.profileKey.set_default();
        }
        self.profileKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        self.profileKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool blocked = 7;


    pub fn get_blocked(&self) -> bool {
        self.blocked.unwrap_or(false)
    }
    pub fn clear_blocked(&mut self) {
        self.blocked = ::std::option::Option::None;
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: bool) {
        self.blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 8;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }

    // optional uint32 inboxPosition = 10;


    pub fn get_inboxPosition(&self) -> u32 {
        self.inboxPosition.unwrap_or(0)
    }
    pub fn clear_inboxPosition(&mut self) {
        self.inboxPosition = ::std::option::Option::None;
    }

    pub fn has_inboxPosition(&self) -> bool {
        self.inboxPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inboxPosition(&mut self, v: u32) {
        self.inboxPosition = ::std::option::Option::Some(v);
    }

    // optional bool archived = 11;


    pub fn get_archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }
    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContactDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verified {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.number)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verified)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocked = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inboxPosition = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.archived = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.number.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.verified.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.blocked {
            my_size += 2;
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inboxPosition {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.archived {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.number.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.verified.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profileKey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.blocked {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.inboxPosition {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.archived {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactDetails {
        ContactDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "number",
                |m: &ContactDetails| { &m.number },
                |m: &mut ContactDetails| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &ContactDetails| { &m.uuid },
                |m: &mut ContactDetails| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ContactDetails| { &m.name },
                |m: &mut ContactDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContactDetails_Avatar>>(
                "avatar",
                |m: &ContactDetails| { &m.avatar },
                |m: &mut ContactDetails| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &ContactDetails| { &m.color },
                |m: &mut ContactDetails| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Verified>>(
                "verified",
                |m: &ContactDetails| { &m.verified },
                |m: &mut ContactDetails| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &ContactDetails| { &m.profileKey },
                |m: &mut ContactDetails| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blocked",
                |m: &ContactDetails| { &m.blocked },
                |m: &mut ContactDetails| { &mut m.blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &ContactDetails| { &m.expireTimer },
                |m: &mut ContactDetails| { &mut m.expireTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inboxPosition",
                |m: &ContactDetails| { &m.inboxPosition },
                |m: &mut ContactDetails| { &mut m.inboxPosition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "archived",
                |m: &ContactDetails| { &m.archived },
                |m: &mut ContactDetails| { &mut m.archived },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContactDetails>(
                "ContactDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContactDetails {
        static instance: ::protobuf::rt::LazyV2<ContactDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContactDetails::new)
    }
}

impl ::protobuf::Clear for ContactDetails {
    fn clear(&mut self) {
        self.number.clear();
        self.uuid.clear();
        self.name.clear();
        self.avatar.clear();
        self.color.clear();
        self.verified.clear();
        self.profileKey.clear();
        self.blocked = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.inboxPosition = ::std::option::Option::None;
        self.archived = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContactDetails_Avatar {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    length: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactDetails_Avatar {
    fn default() -> &'a ContactDetails_Avatar {
        <ContactDetails_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl ContactDetails_Avatar {
    pub fn new() -> ContactDetails_Avatar {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 length = 2;


    pub fn get_length(&self) -> u32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContactDetails_Avatar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactDetails_Avatar {
        ContactDetails_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &ContactDetails_Avatar| { &m.contentType },
                |m: &mut ContactDetails_Avatar| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length",
                |m: &ContactDetails_Avatar| { &m.length },
                |m: &mut ContactDetails_Avatar| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContactDetails_Avatar>(
                "ContactDetails.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContactDetails_Avatar {
        static instance: ::protobuf::rt::LazyV2<ContactDetails_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContactDetails_Avatar::new)
    }
}

impl ::protobuf::Clear for ContactDetails_Avatar {
    fn clear(&mut self) {
        self.contentType.clear();
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactDetails_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactDetails_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails {
    // message fields
    id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub membersE164: ::protobuf::RepeatedField<::std::string::String>,
    pub members: ::protobuf::RepeatedField<GroupDetails_Member>,
    pub avatar: ::protobuf::SingularPtrField<GroupDetails_Avatar>,
    active: ::std::option::Option<bool>,
    expireTimer: ::std::option::Option<u32>,
    color: ::protobuf::SingularField<::std::string::String>,
    blocked: ::std::option::Option<bool>,
    inboxPosition: ::std::option::Option<u32>,
    archived: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails {
    fn default() -> &'a GroupDetails {
        <GroupDetails as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails {
    pub fn new() -> GroupDetails {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string membersE164 = 3;


    pub fn get_membersE164(&self) -> &[::std::string::String] {
        &self.membersE164
    }
    pub fn clear_membersE164(&mut self) {
        self.membersE164.clear();
    }

    // Param is passed by value, moved
    pub fn set_membersE164(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.membersE164 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_membersE164(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.membersE164
    }

    // Take field
    pub fn take_membersE164(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.membersE164, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupDetails.Member members = 9;


    pub fn get_members(&self) -> &[GroupDetails_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<GroupDetails_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<GroupDetails_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<GroupDetails_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional .signalservice.GroupDetails.Avatar avatar = 4;


    pub fn get_avatar(&self) -> &GroupDetails_Avatar {
        self.avatar.as_ref().unwrap_or_else(|| <GroupDetails_Avatar as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: GroupDetails_Avatar) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut GroupDetails_Avatar {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> GroupDetails_Avatar {
        self.avatar.take().unwrap_or_else(|| GroupDetails_Avatar::new())
    }

    // optional bool active = 5;


    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(true)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional uint32 expireTimer = 6;


    pub fn get_expireTimer(&self) -> u32 {
        self.expireTimer.unwrap_or(0)
    }
    pub fn clear_expireTimer(&mut self) {
        self.expireTimer = ::std::option::Option::None;
    }

    pub fn has_expireTimer(&self) -> bool {
        self.expireTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTimer(&mut self, v: u32) {
        self.expireTimer = ::std::option::Option::Some(v);
    }

    // optional string color = 7;


    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        self.color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blocked = 8;


    pub fn get_blocked(&self) -> bool {
        self.blocked.unwrap_or(false)
    }
    pub fn clear_blocked(&mut self) {
        self.blocked = ::std::option::Option::None;
    }

    pub fn has_blocked(&self) -> bool {
        self.blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: bool) {
        self.blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 inboxPosition = 10;


    pub fn get_inboxPosition(&self) -> u32 {
        self.inboxPosition.unwrap_or(0)
    }
    pub fn clear_inboxPosition(&mut self) {
        self.inboxPosition = ::std::option::Option::None;
    }

    pub fn has_inboxPosition(&self) -> bool {
        self.inboxPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inboxPosition(&mut self, v: u32) {
        self.inboxPosition = ::std::option::Option::Some(v);
    }

    // optional bool archived = 11;


    pub fn get_archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }
    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GroupDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.membersE164)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expireTimer = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocked = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inboxPosition = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.archived = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.membersE164 {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.active {
            my_size += 2;
        }
        if let Some(v) = self.expireTimer {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.blocked {
            my_size += 2;
        }
        if let Some(v) = self.inboxPosition {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.archived {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.membersE164 {
            os.write_string(3, &v)?;
        };
        for v in &self.members {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.active {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.expireTimer {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.blocked {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.inboxPosition {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.archived {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails {
        GroupDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &GroupDetails| { &m.id },
                |m: &mut GroupDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GroupDetails| { &m.name },
                |m: &mut GroupDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "membersE164",
                |m: &GroupDetails| { &m.membersE164 },
                |m: &mut GroupDetails| { &mut m.membersE164 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupDetails_Member>>(
                "members",
                |m: &GroupDetails| { &m.members },
                |m: &mut GroupDetails| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupDetails_Avatar>>(
                "avatar",
                |m: &GroupDetails| { &m.avatar },
                |m: &mut GroupDetails| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &GroupDetails| { &m.active },
                |m: &mut GroupDetails| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expireTimer",
                |m: &GroupDetails| { &m.expireTimer },
                |m: &mut GroupDetails| { &mut m.expireTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &GroupDetails| { &m.color },
                |m: &mut GroupDetails| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blocked",
                |m: &GroupDetails| { &m.blocked },
                |m: &mut GroupDetails| { &mut m.blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inboxPosition",
                |m: &GroupDetails| { &m.inboxPosition },
                |m: &mut GroupDetails| { &mut m.inboxPosition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "archived",
                |m: &GroupDetails| { &m.archived },
                |m: &mut GroupDetails| { &mut m.archived },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails>(
                "GroupDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails {
        static instance: ::protobuf::rt::LazyV2<GroupDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails::new)
    }
}

impl ::protobuf::Clear for GroupDetails {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.membersE164.clear();
        self.members.clear();
        self.avatar.clear();
        self.active = ::std::option::Option::None;
        self.expireTimer = ::std::option::Option::None;
        self.color.clear();
        self.blocked = ::std::option::Option::None;
        self.inboxPosition = ::std::option::Option::None;
        self.archived = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails_Avatar {
    // message fields
    contentType: ::protobuf::SingularField<::std::string::String>,
    length: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails_Avatar {
    fn default() -> &'a GroupDetails_Avatar {
        <GroupDetails_Avatar as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails_Avatar {
    pub fn new() -> GroupDetails_Avatar {
        ::std::default::Default::default()
    }

    // optional string contentType = 1;


    pub fn get_contentType(&self) -> &str {
        match self.contentType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_contentType(&mut self) {
        self.contentType.clear();
    }

    pub fn has_contentType(&self) -> bool {
        self.contentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentType(&mut self, v: ::std::string::String) {
        self.contentType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentType(&mut self) -> &mut ::std::string::String {
        if self.contentType.is_none() {
            self.contentType.set_default();
        }
        self.contentType.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentType(&mut self) -> ::std::string::String {
        self.contentType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 length = 2;


    pub fn get_length(&self) -> u32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GroupDetails_Avatar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentType)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails_Avatar {
        GroupDetails_Avatar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentType",
                |m: &GroupDetails_Avatar| { &m.contentType },
                |m: &mut GroupDetails_Avatar| { &mut m.contentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length",
                |m: &GroupDetails_Avatar| { &m.length },
                |m: &mut GroupDetails_Avatar| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails_Avatar>(
                "GroupDetails.Avatar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails_Avatar {
        static instance: ::protobuf::rt::LazyV2<GroupDetails_Avatar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails_Avatar::new)
    }
}

impl ::protobuf::Clear for GroupDetails_Avatar {
    fn clear(&mut self) {
        self.contentType.clear();
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails_Avatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails_Avatar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupDetails_Member {
    // message fields
    e164: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupDetails_Member {
    fn default() -> &'a GroupDetails_Member {
        <GroupDetails_Member as ::protobuf::Message>::default_instance()
    }
}

impl GroupDetails_Member {
    pub fn new() -> GroupDetails_Member {
        ::std::default::Default::default()
    }

    // optional string e164 = 2;


    pub fn get_e164(&self) -> &str {
        match self.e164.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_e164(&mut self) {
        self.e164.clear();
    }

    pub fn has_e164(&self) -> bool {
        self.e164.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e164(&mut self, v: ::std::string::String) {
        self.e164 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e164(&mut self) -> &mut ::std::string::String {
        if self.e164.is_none() {
            self.e164.set_default();
        }
        self.e164.as_mut().unwrap()
    }

    // Take field
    pub fn take_e164(&mut self) -> ::std::string::String {
        self.e164.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupDetails_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.e164)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.e164.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.e164.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupDetails_Member {
        GroupDetails_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "e164",
                |m: &GroupDetails_Member| { &m.e164 },
                |m: &mut GroupDetails_Member| { &mut m.e164 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupDetails_Member>(
                "GroupDetails.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupDetails_Member {
        static instance: ::protobuf::rt::LazyV2<GroupDetails_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupDetails_Member::new)
    }
}

impl ::protobuf::Clear for GroupDetails_Member {
    fn clear(&mut self) {
        self.e164.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupDetails_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupDetails_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaymentAddress {
    // message oneof groups
    pub Address: ::std::option::Option<PaymentAddress_oneof_Address>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAddress {
    fn default() -> &'a PaymentAddress {
        <PaymentAddress as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum PaymentAddress_oneof_Address {
    mobileCoinAddress(PaymentAddress_MobileCoinAddress),
}

impl PaymentAddress {
    pub fn new() -> PaymentAddress {
        ::std::default::Default::default()
    }

    // optional .signalservice.PaymentAddress.MobileCoinAddress mobileCoinAddress = 1;


    pub fn get_mobileCoinAddress(&self) -> &PaymentAddress_MobileCoinAddress {
        match self.Address {
            ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(ref v)) => v,
            _ => <PaymentAddress_MobileCoinAddress as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mobileCoinAddress(&mut self) {
        self.Address = ::std::option::Option::None;
    }

    pub fn has_mobileCoinAddress(&self) -> bool {
        match self.Address {
            ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mobileCoinAddress(&mut self, v: PaymentAddress_MobileCoinAddress) {
        self.Address = ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mobileCoinAddress(&mut self) -> &mut PaymentAddress_MobileCoinAddress {
        if let ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(_)) = self.Address {
        } else {
            self.Address = ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(PaymentAddress_MobileCoinAddress::new()));
        }
        match self.Address {
            ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mobileCoinAddress(&mut self) -> PaymentAddress_MobileCoinAddress {
        if self.has_mobileCoinAddress() {
            match self.Address.take() {
                ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(v)) => v,
                _ => panic!(),
            }
        } else {
            PaymentAddress_MobileCoinAddress::new()
        }
    }
}

impl ::protobuf::Message for PaymentAddress {
    fn is_initialized(&self) -> bool {
        if let Some(PaymentAddress_oneof_Address::mobileCoinAddress(ref v)) = self.Address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Address = ::std::option::Option::Some(PaymentAddress_oneof_Address::mobileCoinAddress(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Address {
            match v {
                &PaymentAddress_oneof_Address::mobileCoinAddress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Address {
            match v {
                &PaymentAddress_oneof_Address::mobileCoinAddress(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAddress {
        PaymentAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PaymentAddress_MobileCoinAddress>(
                "mobileCoinAddress",
                PaymentAddress::has_mobileCoinAddress,
                PaymentAddress::get_mobileCoinAddress,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaymentAddress>(
                "PaymentAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaymentAddress {
        static instance: ::protobuf::rt::LazyV2<PaymentAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaymentAddress::new)
    }
}

impl ::protobuf::Clear for PaymentAddress {
    fn clear(&mut self) {
        self.Address = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaymentAddress_MobileCoinAddress {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAddress_MobileCoinAddress {
    fn default() -> &'a PaymentAddress_MobileCoinAddress {
        <PaymentAddress_MobileCoinAddress as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAddress_MobileCoinAddress {
    pub fn new() -> PaymentAddress_MobileCoinAddress {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PaymentAddress_MobileCoinAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAddress_MobileCoinAddress {
        PaymentAddress_MobileCoinAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &PaymentAddress_MobileCoinAddress| { &m.address },
                |m: &mut PaymentAddress_MobileCoinAddress| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &PaymentAddress_MobileCoinAddress| { &m.signature },
                |m: &mut PaymentAddress_MobileCoinAddress| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaymentAddress_MobileCoinAddress>(
                "PaymentAddress.MobileCoinAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaymentAddress_MobileCoinAddress {
        static instance: ::protobuf::rt::LazyV2<PaymentAddress_MobileCoinAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaymentAddress_MobileCoinAddress::new)
    }
}

impl ::protobuf::Clear for PaymentAddress_MobileCoinAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAddress_MobileCoinAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAddress_MobileCoinAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DecryptionErrorMessage {
    // message fields
    ratchetKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timestamp: ::std::option::Option<u64>,
    deviceId: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptionErrorMessage {
    fn default() -> &'a DecryptionErrorMessage {
        <DecryptionErrorMessage as ::protobuf::Message>::default_instance()
    }
}

impl DecryptionErrorMessage {
    pub fn new() -> DecryptionErrorMessage {
        ::std::default::Default::default()
    }

    // optional bytes ratchetKey = 1;


    pub fn get_ratchetKey(&self) -> &[u8] {
        match self.ratchetKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ratchetKey(&mut self) {
        self.ratchetKey.clear();
    }

    pub fn has_ratchetKey(&self) -> bool {
        self.ratchetKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratchetKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.ratchetKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ratchetKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ratchetKey.is_none() {
            self.ratchetKey.set_default();
        }
        self.ratchetKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_ratchetKey(&mut self) -> ::std::vec::Vec<u8> {
        self.ratchetKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 timestamp = 2;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 deviceId = 3;


    pub fn get_deviceId(&self) -> u32 {
        self.deviceId.unwrap_or(0)
    }
    pub fn clear_deviceId(&mut self) {
        self.deviceId = ::std::option::Option::None;
    }

    pub fn has_deviceId(&self) -> bool {
        self.deviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceId(&mut self, v: u32) {
        self.deviceId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DecryptionErrorMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ratchetKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deviceId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ratchetKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deviceId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ratchetKey.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.deviceId {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptionErrorMessage {
        DecryptionErrorMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ratchetKey",
                |m: &DecryptionErrorMessage| { &m.ratchetKey },
                |m: &mut DecryptionErrorMessage| { &mut m.ratchetKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &DecryptionErrorMessage| { &m.timestamp },
                |m: &mut DecryptionErrorMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deviceId",
                |m: &DecryptionErrorMessage| { &m.deviceId },
                |m: &mut DecryptionErrorMessage| { &mut m.deviceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptionErrorMessage>(
                "DecryptionErrorMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptionErrorMessage {
        static instance: ::protobuf::rt::LazyV2<DecryptionErrorMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptionErrorMessage::new)
    }
}

impl ::protobuf::Clear for DecryptionErrorMessage {
    fn clear(&mut self) {
        self.ratchetKey.clear();
        self.timestamp = ::std::option::Option::None;
        self.deviceId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptionErrorMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptionErrorMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13signalservice.proto\x12\rsignalservice\"\xfe\x03\n\x08Envelope\x12\
    2\n\x04type\x18\x01\x20\x01(\x0e2\x1c.signalservice.Envelope.TypeR\x04ty\
    peB\0\x12\x20\n\nsourceE164\x18\x02\x20\x01(\tR\nsourceE164B\0\x12\x20\n\
    \nsourceUuid\x18\x0b\x20\x01(\tR\nsourceUuidB\0\x12$\n\x0csourceDevice\
    \x18\x07\x20\x01(\rR\x0csourceDeviceB\0\x12\x16\n\x05relay\x18\x03\x20\
    \x01(\tR\x05relayB\0\x12\x1e\n\ttimestamp\x18\x05\x20\x01(\x04R\ttimesta\
    mpB\0\x12&\n\rlegacyMessage\x18\x06\x20\x01(\x0cR\rlegacyMessageB\0\x12\
    \x1a\n\x07content\x18\x08\x20\x01(\x0cR\x07contentB\0\x12\x20\n\nserverG\
    uid\x18\t\x20\x01(\tR\nserverGuidB\0\x12*\n\x0fserverTimestamp\x18\n\x20\
    \x01(\x04R\x0fserverTimestampB\0\"\x87\x01\n\x04Type\x12\x0b\n\x07UNKNOW\
    N\x10\0\x12\x0e\n\nCIPHERTEXT\x10\x01\x12\x10\n\x0cKEY_EXCHANGE\x10\x02\
    \x12\x11\n\rPREKEY_BUNDLE\x10\x03\x12\x0b\n\x07RECEIPT\x10\x05\x12\x17\n\
    \x13UNIDENTIFIED_SENDER\x10\x06\x12\x15\n\x11PLAINTEXT_CONTENT\x10\x08\
    \x1a\0:\0\"\x9a\x04\n\x07Content\x12>\n\x0bdataMessage\x18\x01\x20\x01(\
    \x0b2\x1a.signalservice.DataMessageR\x0bdataMessageB\0\x12>\n\x0bsyncMes\
    sage\x18\x02\x20\x01(\x0b2\x1a.signalservice.SyncMessageR\x0bsyncMessage\
    B\0\x12>\n\x0bcallMessage\x18\x03\x20\x01(\x0b2\x1a.signalservice.CallMe\
    ssageR\x0bcallMessageB\0\x12>\n\x0bnullMessage\x18\x04\x20\x01(\x0b2\x1a\
    .signalservice.NullMessageR\x0bnullMessageB\0\x12G\n\x0ereceiptMessage\
    \x18\x05\x20\x01(\x0b2\x1d.signalservice.ReceiptMessageR\x0ereceiptMessa\
    geB\0\x12D\n\rtypingMessage\x18\x06\x20\x01(\x0b2\x1c.signalservice.Typi\
    ngMessageR\rtypingMessageB\0\x12D\n\x1csenderKeyDistributionMessage\x18\
    \x07\x20\x01(\x0cR\x1csenderKeyDistributionMessageB\0\x128\n\x16decrypti\
    onErrorMessage\x18\x08\x20\x01(\x0cR\x16decryptionErrorMessageB\0:\0\"\
    \xcb\t\n\x0bCallMessage\x128\n\x05offer\x18\x01\x20\x01(\x0b2\x20.signal\
    service.CallMessage.OfferR\x05offerB\0\x12;\n\x06answer\x18\x02\x20\x01(\
    \x0b2!.signalservice.CallMessage.AnswerR\x06answerB\0\x12D\n\ticeUpdate\
    \x18\x03\x20\x03(\x0b2$.signalservice.CallMessage.IceUpdateR\ticeUpdateB\
    \0\x12G\n\x0clegacyHangup\x18\x04\x20\x01(\x0b2!.signalservice.CallMessa\
    ge.HangupR\x0clegacyHangupB\0\x125\n\x04busy\x18\x05\x20\x01(\x0b2\x1f.s\
    ignalservice.CallMessage.BusyR\x04busyB\0\x12;\n\x06hangup\x18\x07\x20\
    \x01(\x0b2!.signalservice.CallMessage.HangupR\x06hangupB\0\x12\x1e\n\tmu\
    ltiRing\x18\x08\x20\x01(\x08R\tmultiRingB\0\x122\n\x13destinationDeviceI\
    d\x18\t\x20\x01(\rR\x13destinationDeviceIdB\0\x12;\n\x06opaque\x18\n\x20\
    \x01(\x0b2!.signalservice.CallMessage.OpaqueR\x06opaqueB\0\x1a\xbc\x01\n\
    \x05Offer\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\x12\x12\n\x03sd\
    p\x18\x02\x20\x01(\tR\x03sdpB\0\x12;\n\x04type\x18\x03\x20\x01(\x0e2%.si\
    gnalservice.CallMessage.Offer.TypeR\x04typeB\0\x12\x18\n\x06opaque\x18\
    \x04\x20\x01(\x0cR\x06opaqueB\0\"4\n\x04Type\x12\x14\n\x10OFFER_AUDIO_CA\
    LL\x10\0\x12\x14\n\x10OFFER_VIDEO_CALL\x10\x01\x1a\0:\0\x1aJ\n\x06Answer\
    \x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\x12\x12\n\x03sdp\x18\x02\
    \x20\x01(\tR\x03sdpB\0\x12\x18\n\x06opaque\x18\x03\x20\x01(\x0cR\x06opaq\
    ueB\0:\0\x1aw\n\tIceUpdate\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\
    \0\x12\x12\n\x03mid\x18\x02\x20\x01(\tR\x03midB\0\x12\x14\n\x04line\x18\
    \x03\x20\x01(\rR\x04lineB\0\x12\x12\n\x03sdp\x18\x04\x20\x01(\tR\x03sdpB\
    \0\x12\x18\n\x06opaque\x18\x05\x20\x01(\x0cR\x06opaqueB\0:\0\x1a\x1a\n\
    \x04Busy\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0:\0\x1a\xec\x01\n\
    \x06Hangup\x12\x10\n\x02id\x18\x01\x20\x01(\x04R\x02idB\0\x12<\n\x04type\
    \x18\x02\x20\x01(\x0e2&.signalservice.CallMessage.Hangup.TypeR\x04typeB\
    \0\x12\x1c\n\x08deviceId\x18\x03\x20\x01(\rR\x08deviceIdB\0\"r\n\x04Type\
    \x12\x11\n\rHANGUP_NORMAL\x10\0\x12\x13\n\x0fHANGUP_ACCEPTED\x10\x01\x12\
    \x13\n\x0fHANGUP_DECLINED\x10\x02\x12\x0f\n\x0bHANGUP_BUSY\x10\x03\x12\
    \x1a\n\x16HANGUP_NEED_PERMISSION\x10\x04\x1a\0:\0\x1a\x20\n\x06Opaque\
    \x12\x14\n\x04data\x18\x01\x20\x01(\x0cR\x04dataB\0:\0:\0\"\xb1#\n\x0bDa\
    taMessage\x12\x14\n\x04body\x18\x01\x20\x01(\tR\x04bodyB\0\x12D\n\x0batt\
    achments\x18\x02\x20\x03(\x0b2\x20.signalservice.AttachmentPointerR\x0ba\
    ttachmentsB\0\x123\n\x05group\x18\x03\x20\x01(\x0b2\x1b.signalservice.Gr\
    oupContextR\x05groupB\0\x129\n\x07groupV2\x18\x0f\x20\x01(\x0b2\x1d.sign\
    alservice.GroupContextV2R\x07groupV2B\0\x12\x16\n\x05flags\x18\x04\x20\
    \x01(\rR\x05flagsB\0\x12\"\n\x0bexpireTimer\x18\x05\x20\x01(\rR\x0bexpir\
    eTimerB\0\x12\x20\n\nprofileKey\x18\x06\x20\x01(\x0cR\nprofileKeyB\0\x12\
    \x1e\n\ttimestamp\x18\x07\x20\x01(\x04R\ttimestampB\0\x128\n\x05quote\
    \x18\x08\x20\x01(\x0b2\x20.signalservice.DataMessage.QuoteR\x05quoteB\0\
    \x12>\n\x07contact\x18\t\x20\x03(\x0b2\".signalservice.DataMessage.Conta\
    ctR\x07contactB\0\x12>\n\x07preview\x18\n\x20\x03(\x0b2\".signalservice.\
    DataMessage.PreviewR\x07previewB\0\x12>\n\x07sticker\x18\x0b\x20\x01(\
    \x0b2\".signalservice.DataMessage.StickerR\x07stickerB\0\x12:\n\x17requi\
    redProtocolVersion\x18\x0c\x20\x01(\rR\x17requiredProtocolVersionB\0\x12\
    \x20\n\nisViewOnce\x18\x0e\x20\x01(\x08R\nisViewOnceB\0\x12A\n\x08reacti\
    on\x18\x10\x20\x01(\x0b2#.signalservice.DataMessage.ReactionR\x08reactio\
    nB\0\x12;\n\x06delete\x18\x11\x20\x01(\x0b2!.signalservice.DataMessage.D\
    eleteR\x06deleteB\0\x12F\n\nbodyRanges\x18\x12\x20\x03(\x0b2$.signalserv\
    ice.DataMessage.BodyRangeR\nbodyRangesB\0\x12V\n\x0fgroupCallUpdate\x18\
    \x13\x20\x01(\x0b2*.signalservice.DataMessage.GroupCallUpdateR\x0fgroupC\
    allUpdateB\0\x12>\n\x07payment\x18\x14\x20\x01(\x0b2\".signalservice.Dat\
    aMessage.PaymentR\x07paymentB\0\x1ax\n\tBodyRange\x12\x16\n\x05start\x18\
    \x01\x20\x01(\x05R\x05startB\0\x12\x18\n\x06length\x18\x02\x20\x01(\x05R\
    \x06lengthB\0\x12$\n\x0bmentionUuid\x18\x03\x20\x01(\tH\0R\x0bmentionUui\
    dB\0B\x11\n\x0fassociatedValue:\0\x1a\xaf\x03\n\x05Quote\x12\x10\n\x02id\
    \x18\x01\x20\x01(\x04R\x02idB\0\x12\x20\n\nauthorE164\x18\x02\x20\x01(\t\
    R\nauthorE164B\0\x12\x20\n\nauthorUuid\x18\x05\x20\x01(\tR\nauthorUuidB\
    \0\x12\x14\n\x04text\x18\x03\x20\x01(\tR\x04textB\0\x12U\n\x0battachment\
    s\x18\x04\x20\x03(\x0b21.signalservice.DataMessage.Quote.QuotedAttachmen\
    tR\x0battachmentsB\0\x12F\n\nbodyRanges\x18\x06\x20\x03(\x0b2$.signalser\
    vice.DataMessage.BodyRangeR\nbodyRangesB\0\x1a\x98\x01\n\x10QuotedAttach\
    ment\x12\"\n\x0bcontentType\x18\x01\x20\x01(\tR\x0bcontentTypeB\0\x12\
    \x1c\n\x08fileName\x18\x02\x20\x01(\tR\x08fileNameB\0\x12@\n\tthumbnail\
    \x18\x03\x20\x01(\x0b2\x20.signalservice.AttachmentPointerR\tthumbnailB\
    \0:\0:\0\x1a\x8b\x0b\n\x07Contact\x12=\n\x04name\x18\x01\x20\x01(\x0b2'.\
    signalservice.DataMessage.Contact.NameR\x04nameB\0\x12B\n\x06number\x18\
    \x03\x20\x03(\x0b2(.signalservice.DataMessage.Contact.PhoneR\x06numberB\
    \0\x12@\n\x05email\x18\x04\x20\x03(\x0b2(.signalservice.DataMessage.Cont\
    act.EmailR\x05emailB\0\x12L\n\x07address\x18\x05\x20\x03(\x0b20.signalse\
    rvice.DataMessage.Contact.PostalAddressR\x07addressB\0\x12C\n\x06avatar\
    \x18\x06\x20\x01(\x0b2).signalservice.DataMessage.Contact.AvatarR\x06ava\
    tarB\0\x12$\n\x0corganization\x18\x07\x20\x01(\tR\x0corganizationB\0\x1a\
    \xc4\x01\n\x04Name\x12\x1e\n\tgivenName\x18\x01\x20\x01(\tR\tgivenNameB\
    \0\x12\x20\n\nfamilyName\x18\x02\x20\x01(\tR\nfamilyNameB\0\x12\x18\n\
    \x06prefix\x18\x03\x20\x01(\tR\x06prefixB\0\x12\x18\n\x06suffix\x18\x04\
    \x20\x01(\tR\x06suffixB\0\x12\x20\n\nmiddleName\x18\x05\x20\x01(\tR\nmid\
    dleNameB\0\x12\"\n\x0bdisplayName\x18\x06\x20\x01(\tR\x0bdisplayNameB\0:\
    \0\x1a\xb4\x01\n\x05Phone\x12\x16\n\x05value\x18\x01\x20\x01(\tR\x05valu\
    eB\0\x12C\n\x04type\x18\x02\x20\x01(\x0e2-.signalservice.DataMessage.Con\
    tact.Phone.TypeR\x04typeB\0\x12\x16\n\x05label\x18\x03\x20\x01(\tR\x05la\
    belB\0\"4\n\x04Type\x12\x08\n\x04HOME\x10\x01\x12\n\n\x06MOBILE\x10\x02\
    \x12\x08\n\x04WORK\x10\x03\x12\n\n\x06CUSTOM\x10\x04\x1a\0:\0\x1a\xb4\
    \x01\n\x05Email\x12\x16\n\x05value\x18\x01\x20\x01(\tR\x05valueB\0\x12C\
    \n\x04type\x18\x02\x20\x01(\x0e2-.signalservice.DataMessage.Contact.Emai\
    l.TypeR\x04typeB\0\x12\x16\n\x05label\x18\x03\x20\x01(\tR\x05labelB\0\"4\
    \n\x04Type\x12\x08\n\x04HOME\x10\x01\x12\n\n\x06MOBILE\x10\x02\x12\x08\n\
    \x04WORK\x10\x03\x12\n\n\x06CUSTOM\x10\x04\x1a\0:\0\x1a\xe2\x02\n\rPosta\
    lAddress\x12K\n\x04type\x18\x01\x20\x01(\x0e25.signalservice.DataMessage\
    .Contact.PostalAddress.TypeR\x04typeB\0\x12\x16\n\x05label\x18\x02\x20\
    \x01(\tR\x05labelB\0\x12\x18\n\x06street\x18\x03\x20\x01(\tR\x06streetB\
    \0\x12\x16\n\x05pobox\x18\x04\x20\x01(\tR\x05poboxB\0\x12$\n\x0cneighbor\
    hood\x18\x05\x20\x01(\tR\x0cneighborhoodB\0\x12\x14\n\x04city\x18\x06\
    \x20\x01(\tR\x04cityB\0\x12\x18\n\x06region\x18\x07\x20\x01(\tR\x06regio\
    nB\0\x12\x1c\n\x08postcode\x18\x08\x20\x01(\tR\x08postcodeB\0\x12\x1a\n\
    \x07country\x18\t\x20\x01(\tR\x07countryB\0\"(\n\x04Type\x12\x08\n\x04HO\
    ME\x10\x01\x12\x08\n\x04WORK\x10\x02\x12\n\n\x06CUSTOM\x10\x03\x1a\0:\0\
    \x1af\n\x06Avatar\x12:\n\x06avatar\x18\x01\x20\x01(\x0b2\x20.signalservi\
    ce.AttachmentPointerR\x06avatarB\0\x12\x1e\n\tisProfile\x18\x02\x20\x01(\
    \x08R\tisProfileB\0:\0:\0\x1a\xab\x01\n\x07Preview\x12\x12\n\x03url\x18\
    \x01\x20\x01(\tR\x03urlB\0\x12\x16\n\x05title\x18\x02\x20\x01(\tR\x05tit\
    leB\0\x128\n\x05image\x18\x03\x20\x01(\x0b2\x20.signalservice.Attachment\
    PointerR\x05imageB\0\x12\"\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescr\
    iptionB\0\x12\x14\n\x04date\x18\x05\x20\x01(\x04R\x04dateB\0:\0\x1a\xb1\
    \x01\n\x07Sticker\x12\x18\n\x06packId\x18\x01\x20\x01(\x0cR\x06packIdB\0\
    \x12\x1a\n\x07packKey\x18\x02\x20\x01(\x0cR\x07packKeyB\0\x12\x1e\n\tsti\
    ckerId\x18\x03\x20\x01(\rR\tstickerIdB\0\x126\n\x04data\x18\x04\x20\x01(\
    \x0b2\x20.signalservice.AttachmentPointerR\x04dataB\0\x12\x16\n\x05emoji\
    \x18\x05\x20\x01(\tR\x05emojiB\0:\0\x1a\xa0\x01\n\x08Reaction\x12\x16\n\
    \x05emoji\x18\x01\x20\x01(\tR\x05emojiB\0\x12\x18\n\x06remove\x18\x02\
    \x20\x01(\x08R\x06removeB\0\x12,\n\x10targetAuthorUuid\x18\x04\x20\x01(\
    \tR\x10targetAuthorUuidB\0\x122\n\x13targetSentTimestamp\x18\x05\x20\x01\
    (\x04R\x13targetSentTimestampB\0:\0\x1a>\n\x06Delete\x122\n\x13targetSen\
    tTimestamp\x18\x01\x20\x01(\x04R\x13targetSentTimestampB\0:\0\x1a+\n\x0f\
    GroupCallUpdate\x12\x16\n\x05eraId\x18\x01\x20\x01(\tR\x05eraIdB\0:\0\
    \x1a\xed\x04\n\x07Payment\x12W\n\x0cnotification\x18\x01\x20\x01(\x0b2/.\
    signalservice.DataMessage.Payment.NotificationH\0R\x0cnotificationB\0\
    \x1a\x9d\x01\n\x07Address\x12Y\n\nmobileCoin\x18\x01\x20\x01(\x0b25.sign\
    alservice.DataMessage.Payment.Address.MobileCoinH\0R\nmobileCoinB\0\x1a*\
    \n\nMobileCoin\x12\x1a\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB\0:\
    \0B\t\n\x07Address:\0\x1a\x9a\x01\n\x06Amount\x12X\n\nmobileCoin\x18\x01\
    \x20\x01(\x0b24.signalservice.DataMessage.Payment.Amount.MobileCoinH\0R\
    \nmobileCoinB\0\x1a*\n\nMobileCoin\x12\x1a\n\x07picoMob\x18\x01\x20\x01(\
    \x04R\x07picoMobB\0:\0B\x08\n\x06Amount:\0\x1a\xc1\x01\n\x0cNotification\
    \x12^\n\nmobileCoin\x18\x01\x20\x01(\x0b2:.signalservice.DataMessage.Pay\
    ment.Notification.MobileCoinH\0R\nmobileCoinB\0\x12\x14\n\x04note\x18\
    \x02\x20\x01(\tR\x04noteB\0\x1a*\n\nMobileCoin\x12\x1a\n\x07receipt\x18\
    \x01\x20\x01(\x0cR\x07receiptB\0:\0B\r\n\x0bTransaction:\0B\x06\n\x04Ite\
    m:\0\"O\n\x05Flags\x12\x0f\n\x0bEND_SESSION\x10\x01\x12\x1b\n\x17EXPIRAT\
    ION_TIMER_UPDATE\x10\x02\x12\x16\n\x12PROFILE_KEY_UPDATE\x10\x04\x1a\0\"\
    \xb0\x01\n\x0fProtocolVersion\x12\x0b\n\x07INITIAL\x10\0\x12\x12\n\x0eME\
    SSAGE_TIMERS\x10\x01\x12\r\n\tVIEW_ONCE\x10\x02\x12\x13\n\x0fVIEW_ONCE_V\
    IDEO\x10\x03\x12\r\n\tREACTIONS\x10\x04\x12\x1c\n\x18CDN_SELECTOR_ATTACH\
    MENTS\x10\x05\x12\x0c\n\x08MENTIONS\x10\x06\x12\x0c\n\x08PAYMENTS\x10\
    \x07\x12\x0b\n\x07CURRENT\x10\x07\x1a\x02\x10\x01:\0\"+\n\x0bNullMessage\
    \x12\x1a\n\x07padding\x18\x01\x20\x01(\x0cR\x07paddingB\0:\0\"\x9a\x01\n\
    \x0eReceiptMessage\x128\n\x04type\x18\x01\x20\x01(\x0e2\".signalservice.\
    ReceiptMessage.TypeR\x04typeB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x03(\
    \x04R\ttimestampB\0\",\n\x04Type\x12\x0c\n\x08DELIVERY\x10\0\x12\x08\n\
    \x04READ\x10\x01\x12\n\n\x06VIEWED\x10\x02\x1a\0:\0\"\xb2\x01\n\rTypingM\
    essage\x12\x1e\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestampB\0\x12=\n\
    \x06action\x18\x02\x20\x01(\x0e2#.signalservice.TypingMessage.ActionR\
    \x06actionB\0\x12\x1a\n\x07groupId\x18\x03\x20\x01(\x0cR\x07groupIdB\0\"\
    $\n\x06Action\x12\x0b\n\x07STARTED\x10\0\x12\x0b\n\x07STOPPED\x10\x01\
    \x1a\0:\0\"\x99\x02\n\x08Verified\x12*\n\x0fdestinationE164\x18\x01\x20\
    \x01(\tR\x0fdestinationE164B\0\x12*\n\x0fdestinationUuid\x18\x05\x20\x01\
    (\tR\x0fdestinationUuidB\0\x12\"\n\x0bidentityKey\x18\x02\x20\x01(\x0cR\
    \x0bidentityKeyB\0\x125\n\x05state\x18\x03\x20\x01(\x0e2\x1d.signalservi\
    ce.Verified.StateR\x05stateB\0\x12\"\n\x0bnullMessage\x18\x04\x20\x01(\
    \x0cR\x0bnullMessageB\0\"4\n\x05State\x12\x0b\n\x07DEFAULT\x10\0\x12\x0c\
    \n\x08VERIFIED\x10\x01\x12\x0e\n\nUNVERIFIED\x10\x02\x1a\0:\0\"\xf5\x1e\
    \n\x0bSyncMessage\x125\n\x04sent\x18\x01\x20\x01(\x0b2\x1f.signalservice\
    .SyncMessage.SentR\x04sentB\0\x12A\n\x08contacts\x18\x02\x20\x01(\x0b2#.\
    signalservice.SyncMessage.ContactsR\x08contactsB\0\x12;\n\x06groups\x18\
    \x03\x20\x01(\x0b2!.signalservice.SyncMessage.GroupsR\x06groupsB\0\x12>\
    \n\x07request\x18\x04\x20\x01(\x0b2\".signalservice.SyncMessage.RequestR\
    \x07requestB\0\x125\n\x04read\x18\x05\x20\x03(\x0b2\x1f.signalservice.Sy\
    ncMessage.ReadR\x04readB\0\x12>\n\x07blocked\x18\x06\x20\x01(\x0b2\".sig\
    nalservice.SyncMessage.BlockedR\x07blockedB\0\x125\n\x08verified\x18\x07\
    \x20\x01(\x0b2\x17.signalservice.VerifiedR\x08verifiedB\0\x12P\n\rconfig\
    uration\x18\t\x20\x01(\x0b2(.signalservice.SyncMessage.ConfigurationR\rc\
    onfigurationB\0\x12\x1a\n\x07padding\x18\x08\x20\x01(\x0cR\x07paddingB\0\
    \x12e\n\x14stickerPackOperation\x18\n\x20\x03(\x0b2/.signalservice.SyncM\
    essage.StickerPackOperationR\x14stickerPackOperationB\0\x12M\n\x0cviewOn\
    ceOpen\x18\x0b\x20\x01(\x0b2'.signalservice.SyncMessage.ViewOnceOpenR\
    \x0cviewOnceOpenB\0\x12J\n\x0bfetchLatest\x18\x0c\x20\x01(\x0b2&.signals\
    ervice.SyncMessage.FetchLatestR\x0bfetchLatestB\0\x125\n\x04keys\x18\r\
    \x20\x01(\x0b2\x1f.signalservice.SyncMessage.KeysR\x04keysB\0\x12k\n\x16\
    messageRequestResponse\x18\x0e\x20\x01(\x0b21.signalservice.SyncMessage.\
    MessageRequestResponseR\x16messageRequestResponseB\0\x12V\n\x0foutgoingP\
    ayment\x18\x0f\x20\x01(\x0b2*.signalservice.SyncMessage.OutgoingPaymentR\
    \x0foutgoingPaymentB\0\x12;\n\x06viewed\x18\x10\x20\x03(\x0b2!.signalser\
    vice.SyncMessage.ViewedR\x06viewedB\0\x1a\xba\x04\n\x04Sent\x12*\n\x0fde\
    stinationE164\x18\x01\x20\x01(\tR\x0fdestinationE164B\0\x12*\n\x0fdestin\
    ationUuid\x18\x07\x20\x01(\tR\x0fdestinationUuidB\0\x12\x1e\n\ttimestamp\
    \x18\x02\x20\x01(\x04R\ttimestampB\0\x126\n\x07message\x18\x03\x20\x01(\
    \x0b2\x1a.signalservice.DataMessageR\x07messageB\0\x12<\n\x18expirationS\
    tartTimestamp\x18\x04\x20\x01(\x04R\x18expirationStartTimestampB\0\x12l\
    \n\x12unidentifiedStatus\x18\x05\x20\x03(\x0b2:.signalservice.SyncMessag\
    e.Sent.UnidentifiedDeliveryStatusR\x12unidentifiedStatusB\0\x125\n\x11is\
    RecipientUpdate\x18\x06\x20\x01(\x08:\x05falseR\x11isRecipientUpdateB\0\
    \x1a\x9c\x01\n\x1aUnidentifiedDeliveryStatus\x12*\n\x0fdestinationE164\
    \x18\x01\x20\x01(\tR\x0fdestinationE164B\0\x12*\n\x0fdestinationUuid\x18\
    \x03\x20\x01(\tR\x0fdestinationUuidB\0\x12$\n\x0cunidentified\x18\x02\
    \x20\x01(\x08R\x0cunidentifiedB\0:\0:\0\x1ai\n\x08Contacts\x126\n\x04blo\
    b\x18\x01\x20\x01(\x0b2\x20.signalservice.AttachmentPointerR\x04blobB\0\
    \x12#\n\x08complete\x18\x02\x20\x01(\x08:\x05falseR\x08completeB\0:\0\
    \x1aB\n\x06Groups\x126\n\x04blob\x18\x01\x20\x01(\x0b2\x20.signalservice\
    .AttachmentPointerR\x04blobB\0:\0\x1a]\n\x07Blocked\x12\x1a\n\x07numbers\
    \x18\x01\x20\x03(\tR\x07numbersB\0\x12\x16\n\x05uuids\x18\x03\x20\x03(\t\
    R\x05uuidsB\0\x12\x1c\n\x08groupIds\x18\x02\x20\x03(\x0cR\x08groupIdsB\0\
    :\0\x1a\xa5\x01\n\x07Request\x12=\n\x04type\x18\x01\x20\x01(\x0e2'.signa\
    lservice.SyncMessage.Request.TypeR\x04typeB\0\"Y\n\x04Type\x12\x0b\n\x07\
    UNKNOWN\x10\0\x12\x0c\n\x08CONTACTS\x10\x01\x12\n\n\x06GROUPS\x10\x02\
    \x12\x0b\n\x07BLOCKED\x10\x03\x12\x11\n\rCONFIGURATION\x10\x04\x12\x08\n\
    \x04KEYS\x10\x05\x1a\0:\0\x1al\n\x04Read\x12\x20\n\nsenderE164\x18\x01\
    \x20\x01(\tR\nsenderE164B\0\x12\x20\n\nsenderUuid\x18\x03\x20\x01(\tR\ns\
    enderUuidB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0:\0\
    \x1an\n\x06Viewed\x12\x20\n\nsenderE164\x18\x01\x20\x01(\tR\nsenderE164B\
    \0\x12\x20\n\nsenderUuid\x18\x03\x20\x01(\tR\nsenderUuidB\0\x12\x1e\n\tt\
    imestamp\x18\x02\x20\x01(\x04R\ttimestampB\0:\0\x1a\x89\x02\n\rConfigura\
    tion\x12$\n\x0creadReceipts\x18\x01\x20\x01(\x08R\x0creadReceiptsB\0\x12\
    H\n\x1eunidentifiedDeliveryIndicators\x18\x02\x20\x01(\x08R\x1eunidentif\
    iedDeliveryIndicatorsB\0\x12,\n\x10typingIndicators\x18\x03\x20\x01(\x08\
    R\x10typingIndicatorsB\0\x122\n\x13provisioningVersion\x18\x05\x20\x01(\
    \rR\x13provisioningVersionB\0\x12$\n\x0clinkPreviews\x18\x06\x20\x01(\
    \x08R\x0clinkPreviewsB\0:\0\x1a\xbd\x01\n\x14StickerPackOperation\x12\
    \x18\n\x06packId\x18\x01\x20\x01(\x0cR\x06packIdB\0\x12\x1a\n\x07packKey\
    \x18\x02\x20\x01(\x0cR\x07packKeyB\0\x12J\n\x04type\x18\x03\x20\x01(\x0e\
    24.signalservice.SyncMessage.StickerPackOperation.TypeR\x04typeB\0\"!\n\
    \x04Type\x12\x0b\n\x07INSTALL\x10\0\x12\n\n\x06REMOVE\x10\x01\x1a\0:\0\
    \x1at\n\x0cViewOnceOpen\x12\x20\n\nsenderE164\x18\x01\x20\x01(\tR\nsende\
    rE164B\0\x12\x20\n\nsenderUuid\x18\x03\x20\x01(\tR\nsenderUuidB\0\x12\
    \x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0:\0\x1a\x92\x01\n\
    \x0bFetchLatest\x12A\n\x04type\x18\x01\x20\x01(\x0e2+.signalservice.Sync\
    Message.FetchLatest.TypeR\x04typeB\0\">\n\x04Type\x12\x0b\n\x07UNKNOWN\
    \x10\0\x12\x11\n\rLOCAL_PROFILE\x10\x01\x12\x14\n\x10STORAGE_MANIFEST\
    \x10\x02\x1a\0:\0\x1a2\n\x04Keys\x12(\n\x0estorageService\x18\x01\x20\
    \x01(\x0cR\x0estorageServiceB\0:\0\x1a\x98\x02\n\x16MessageRequestRespon\
    se\x12\x20\n\nthreadE164\x18\x01\x20\x01(\tR\nthreadE164B\0\x12\x20\n\nt\
    hreadUuid\x18\x02\x20\x01(\tR\nthreadUuidB\0\x12\x1a\n\x07groupId\x18\
    \x03\x20\x01(\x0cR\x07groupIdB\0\x12L\n\x04type\x18\x04\x20\x01(\x0e26.s\
    ignalservice.SyncMessage.MessageRequestResponse.TypeR\x04typeB\0\"N\n\
    \x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06ACCEPT\x10\x01\x12\n\n\
    \x06DELETE\x10\x02\x12\t\n\x05BLOCK\x10\x03\x12\x14\n\x10BLOCK_AND_DELET\
    E\x10\x04\x1a\0:\0\x1a\x9e\x04\n\x0fOutgoingPayment\x12&\n\rrecipientUui\
    d\x18\x01\x20\x01(\tR\rrecipientUuidB\0\x12\x14\n\x04note\x18\x02\x20\
    \x01(\tR\x04noteB\0\x12Y\n\nmobileCoin\x18\x03\x20\x01(\x0b25.signalserv\
    ice.SyncMessage.OutgoingPayment.MobileCoinH\0R\nmobileCoinB\0\x1a\xde\
    \x02\n\nMobileCoin\x12,\n\x10recipientAddress\x18\x01\x20\x01(\x0cR\x10r\
    ecipientAddressB\0\x12&\n\ramountPicoMob\x18\x02\x20\x01(\x04R\ramountPi\
    coMobB\0\x12\x20\n\nfeePicoMob\x18\x03\x20\x01(\x04R\nfeePicoMobB\0\x12\
    \x1a\n\x07receipt\x18\x04\x20\x01(\x0cR\x07receiptB\0\x124\n\x14ledgerBl\
    ockTimestamp\x18\x05\x20\x01(\x04R\x14ledgerBlockTimestampB\0\x12,\n\x10\
    ledgerBlockIndex\x18\x06\x20\x01(\x04R\x10ledgerBlockIndexB\0\x12(\n\x0e\
    spentKeyImages\x18\x07\x20\x03(\x0cR\x0espentKeyImagesB\0\x12,\n\x10outp\
    utPublicKeys\x18\x08\x20\x03(\x0cR\x10outputPublicKeysB\0:\0B\x0f\n\rpay\
    mentDetail:\0:\0\"\x91\x04\n\x11AttachmentPointer\x12\x18\n\x05cdnId\x18\
    \x01\x20\x01(\x06H\0R\x05cdnIdB\0\x12\x1a\n\x06cdnKey\x18\x0f\x20\x01(\t\
    H\0R\x06cdnKeyB\0\x12\"\n\x0bcontentType\x18\x02\x20\x01(\tR\x0bcontentT\
    ypeB\0\x12\x12\n\x03key\x18\x03\x20\x01(\x0cR\x03keyB\0\x12\x14\n\x04siz\
    e\x18\x04\x20\x01(\rR\x04sizeB\0\x12\x1e\n\tthumbnail\x18\x05\x20\x01(\
    \x0cR\tthumbnailB\0\x12\x18\n\x06digest\x18\x06\x20\x01(\x0cR\x06digestB\
    \0\x12\x1c\n\x08fileName\x18\x07\x20\x01(\tR\x08fileNameB\0\x12\x16\n\
    \x05flags\x18\x08\x20\x01(\rR\x05flagsB\0\x12\x16\n\x05width\x18\t\x20\
    \x01(\rR\x05widthB\0\x12\x18\n\x06height\x18\n\x20\x01(\rR\x06heightB\0\
    \x12\x1a\n\x07caption\x18\x0b\x20\x01(\tR\x07captionB\0\x12\x1c\n\x08blu\
    rHash\x18\x0c\x20\x01(\tR\x08blurHashB\0\x12*\n\x0fuploadTimestamp\x18\r\
    \x20\x01(\x04R\x0fuploadTimestampB\0\x12\x1e\n\tcdnNumber\x18\x0e\x20\
    \x01(\rR\tcdnNumberB\0\"5\n\x05Flags\x12\x11\n\rVOICE_MESSAGE\x10\x01\
    \x12\x0e\n\nBORDERLESS\x10\x02\x12\x07\n\x03GIF\x10\x04\x1a\0B\x17\n\x15\
    attachment_identifier:\0\"\xfe\x02\n\x0cGroupContext\x12\x10\n\x02id\x18\
    \x01\x20\x01(\x0cR\x02idB\0\x126\n\x04type\x18\x02\x20\x01(\x0e2\x20.sig\
    nalservice.GroupContext.TypeR\x04typeB\0\x12\x14\n\x04name\x18\x03\x20\
    \x01(\tR\x04nameB\0\x12\"\n\x0bmembersE164\x18\x04\x20\x03(\tR\x0bmember\
    sE164B\0\x12>\n\x07members\x18\x06\x20\x03(\x0b2\".signalservice.GroupCo\
    ntext.MemberR\x07membersB\0\x12:\n\x06avatar\x18\x05\x20\x01(\x0b2\x20.s\
    ignalservice.AttachmentPointerR\x06avatarB\0\x1a\x20\n\x06Member\x12\x14\
    \n\x04e164\x18\x02\x20\x01(\tR\x04e164B\0:\0\"J\n\x04Type\x12\x0b\n\x07U\
    NKNOWN\x10\0\x12\n\n\x06UPDATE\x10\x01\x12\x0b\n\x07DELIVER\x10\x02\x12\
    \x08\n\x04QUIT\x10\x03\x12\x10\n\x0cREQUEST_INFO\x10\x04\x1a\0:\0\"t\n\
    \x0eGroupContextV2\x12\x1e\n\tmasterKey\x18\x01\x20\x01(\x0cR\tmasterKey\
    B\0\x12\x1c\n\x08revision\x18\x02\x20\x01(\rR\x08revisionB\0\x12\"\n\x0b\
    groupChange\x18\x03\x20\x01(\x0cR\x0bgroupChangeB\0:\0\"\xd9\x03\n\x0eCo\
    ntactDetails\x12\x18\n\x06number\x18\x01\x20\x01(\tR\x06numberB\0\x12\
    \x14\n\x04uuid\x18\t\x20\x01(\tR\x04uuidB\0\x12\x14\n\x04name\x18\x02\
    \x20\x01(\tR\x04nameB\0\x12>\n\x06avatar\x18\x03\x20\x01(\x0b2$.signalse\
    rvice.ContactDetails.AvatarR\x06avatarB\0\x12\x16\n\x05color\x18\x04\x20\
    \x01(\tR\x05colorB\0\x125\n\x08verified\x18\x05\x20\x01(\x0b2\x17.signal\
    service.VerifiedR\x08verifiedB\0\x12\x20\n\nprofileKey\x18\x06\x20\x01(\
    \x0cR\nprofileKeyB\0\x12\x1a\n\x07blocked\x18\x07\x20\x01(\x08R\x07block\
    edB\0\x12\"\n\x0bexpireTimer\x18\x08\x20\x01(\rR\x0bexpireTimerB\0\x12&\
    \n\rinboxPosition\x18\n\x20\x01(\rR\rinboxPositionB\0\x12\x1c\n\x08archi\
    ved\x18\x0b\x20\x01(\x08R\x08archivedB\0\x1aH\n\x06Avatar\x12\"\n\x0bcon\
    tentType\x18\x01\x20\x01(\tR\x0bcontentTypeB\0\x12\x18\n\x06length\x18\
    \x02\x20\x01(\rR\x06lengthB\0:\0:\0\"\x84\x04\n\x0cGroupDetails\x12\x10\
    \n\x02id\x18\x01\x20\x01(\x0cR\x02idB\0\x12\x14\n\x04name\x18\x02\x20\
    \x01(\tR\x04nameB\0\x12\"\n\x0bmembersE164\x18\x03\x20\x03(\tR\x0bmember\
    sE164B\0\x12>\n\x07members\x18\t\x20\x03(\x0b2\".signalservice.GroupDeta\
    ils.MemberR\x07membersB\0\x12<\n\x06avatar\x18\x04\x20\x01(\x0b2\".signa\
    lservice.GroupDetails.AvatarR\x06avatarB\0\x12\x1e\n\x06active\x18\x05\
    \x20\x01(\x08:\x04trueR\x06activeB\0\x12\"\n\x0bexpireTimer\x18\x06\x20\
    \x01(\rR\x0bexpireTimerB\0\x12\x16\n\x05color\x18\x07\x20\x01(\tR\x05col\
    orB\0\x12\x1a\n\x07blocked\x18\x08\x20\x01(\x08R\x07blockedB\0\x12&\n\ri\
    nboxPosition\x18\n\x20\x01(\rR\rinboxPositionB\0\x12\x1c\n\x08archived\
    \x18\x0b\x20\x01(\x08R\x08archivedB\0\x1aH\n\x06Avatar\x12\"\n\x0bconten\
    tType\x18\x01\x20\x01(\tR\x0bcontentTypeB\0\x12\x18\n\x06length\x18\x02\
    \x20\x01(\rR\x06lengthB\0:\0\x1a\x20\n\x06Member\x12\x14\n\x04e164\x18\
    \x02\x20\x01(\tR\x04e164B\0:\0:\0\"\xd3\x01\n\x0ePaymentAddress\x12a\n\
    \x11mobileCoinAddress\x18\x01\x20\x01(\x0b2/.signalservice.PaymentAddres\
    s.MobileCoinAddressH\0R\x11mobileCoinAddressB\0\x1aQ\n\x11MobileCoinAddr\
    ess\x12\x1a\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB\0\x12\x1e\n\t\
    signature\x18\x02\x20\x01(\x0cR\tsignatureB\0:\0B\t\n\x07Address:\0\"z\n\
    \x16DecryptionErrorMessage\x12\x20\n\nratchetKey\x18\x01\x20\x01(\x0cR\n\
    ratchetKeyB\0\x12\x1e\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestampB\0\
    \x12\x1c\n\x08deviceId\x18\x03\x20\x01(\rR\x08deviceIdB\0:\0B\0b\x06prot\
    o2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
