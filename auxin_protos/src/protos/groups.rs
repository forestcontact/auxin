// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `groups.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AvatarUploadAttributes {
    // message fields
    pub key: ::std::string::String,
    pub credential: ::std::string::String,
    pub acl: ::std::string::String,
    pub algorithm: ::std::string::String,
    pub date: ::std::string::String,
    pub policy: ::std::string::String,
    pub signature: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AvatarUploadAttributes {
    fn default() -> &'a AvatarUploadAttributes {
        <AvatarUploadAttributes as ::protobuf::Message>::default_instance()
    }
}

impl AvatarUploadAttributes {
    pub fn new() -> AvatarUploadAttributes {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string credential = 2;


    pub fn get_credential(&self) -> &str {
        &self.credential
    }
    pub fn clear_credential(&mut self) {
        self.credential.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential(&mut self, v: ::std::string::String) {
        self.credential = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential(&mut self) -> &mut ::std::string::String {
        &mut self.credential
    }

    // Take field
    pub fn take_credential(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.credential, ::std::string::String::new())
    }

    // string acl = 3;


    pub fn get_acl(&self) -> &str {
        &self.acl
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: ::std::string::String) {
        self.acl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acl(&mut self) -> &mut ::std::string::String {
        &mut self.acl
    }

    // Take field
    pub fn take_acl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acl, ::std::string::String::new())
    }

    // string algorithm = 4;


    pub fn get_algorithm(&self) -> &str {
        &self.algorithm
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ::std::string::String) {
        self.algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.algorithm
    }

    // Take field
    pub fn take_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.algorithm, ::std::string::String::new())
    }

    // string date = 5;


    pub fn get_date(&self) -> &str {
        &self.date
    }
    pub fn clear_date(&mut self) {
        self.date.clear();
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: ::std::string::String) {
        self.date = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date(&mut self) -> &mut ::std::string::String {
        &mut self.date
    }

    // Take field
    pub fn take_date(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.date, ::std::string::String::new())
    }

    // string policy = 6;


    pub fn get_policy(&self) -> &str {
        &self.policy
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: ::std::string::String) {
        self.policy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut ::std::string::String {
        &mut self.policy
    }

    // Take field
    pub fn take_policy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.policy, ::std::string::String::new())
    }

    // string signature = 7;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AvatarUploadAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.credential)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.algorithm)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.date)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.policy)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.credential.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.credential);
        }
        if !self.acl.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.acl);
        }
        if !self.algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.algorithm);
        }
        if !self.date.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.date);
        }
        if !self.policy.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.policy);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.credential.is_empty() {
            os.write_string(2, &self.credential)?;
        }
        if !self.acl.is_empty() {
            os.write_string(3, &self.acl)?;
        }
        if !self.algorithm.is_empty() {
            os.write_string(4, &self.algorithm)?;
        }
        if !self.date.is_empty() {
            os.write_string(5, &self.date)?;
        }
        if !self.policy.is_empty() {
            os.write_string(6, &self.policy)?;
        }
        if !self.signature.is_empty() {
            os.write_string(7, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvatarUploadAttributes {
        AvatarUploadAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &AvatarUploadAttributes| { &m.key },
                |m: &mut AvatarUploadAttributes| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential",
                |m: &AvatarUploadAttributes| { &m.credential },
                |m: &mut AvatarUploadAttributes| { &mut m.credential },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acl",
                |m: &AvatarUploadAttributes| { &m.acl },
                |m: &mut AvatarUploadAttributes| { &mut m.acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "algorithm",
                |m: &AvatarUploadAttributes| { &m.algorithm },
                |m: &mut AvatarUploadAttributes| { &mut m.algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "date",
                |m: &AvatarUploadAttributes| { &m.date },
                |m: &mut AvatarUploadAttributes| { &mut m.date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "policy",
                |m: &AvatarUploadAttributes| { &m.policy },
                |m: &mut AvatarUploadAttributes| { &mut m.policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &AvatarUploadAttributes| { &m.signature },
                |m: &mut AvatarUploadAttributes| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AvatarUploadAttributes>(
                "AvatarUploadAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvatarUploadAttributes {
        static instance: ::protobuf::rt::LazyV2<AvatarUploadAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AvatarUploadAttributes::new)
    }
}

impl ::protobuf::Clear for AvatarUploadAttributes {
    fn clear(&mut self) {
        self.key.clear();
        self.credential.clear();
        self.acl.clear();
        self.algorithm.clear();
        self.date.clear();
        self.policy.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvatarUploadAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarUploadAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Member {
    // message fields
    pub userId: ::std::vec::Vec<u8>,
    pub role: Member_Role,
    pub profileKey: ::std::vec::Vec<u8>,
    pub presentation: ::std::vec::Vec<u8>,
    pub joinedAtRevision: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Member {
    fn default() -> &'a Member {
        <Member as ::protobuf::Message>::default_instance()
    }
}

impl Member {
    pub fn new() -> Member {
        ::std::default::Default::default()
    }

    // bytes userId = 1;


    pub fn get_userId(&self) -> &[u8] {
        &self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId.clear();
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: ::std::vec::Vec<u8>) {
        self.userId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userId
    }

    // Take field
    pub fn take_userId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userId, ::std::vec::Vec::new())
    }

    // .signalservice.Member.Role role = 2;


    pub fn get_role(&self) -> Member_Role {
        self.role
    }
    pub fn clear_role(&mut self) {
        self.role = Member_Role::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Member_Role) {
        self.role = v;
    }

    // bytes profileKey = 3;


    pub fn get_profileKey(&self) -> &[u8] {
        &self.profileKey
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.profileKey
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.profileKey, ::std::vec::Vec::new())
    }

    // bytes presentation = 4;


    pub fn get_presentation(&self) -> &[u8] {
        &self.presentation
    }
    pub fn clear_presentation(&mut self) {
        self.presentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_presentation(&mut self, v: ::std::vec::Vec<u8>) {
        self.presentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presentation(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.presentation
    }

    // Take field
    pub fn take_presentation(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.presentation, ::std::vec::Vec::new())
    }

    // uint32 joinedAtRevision = 5;


    pub fn get_joinedAtRevision(&self) -> u32 {
        self.joinedAtRevision
    }
    pub fn clear_joinedAtRevision(&mut self) {
        self.joinedAtRevision = 0;
    }

    // Param is passed by value, moved
    pub fn set_joinedAtRevision(&mut self, v: u32) {
        self.joinedAtRevision = v;
    }
}

impl ::protobuf::Message for Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userId)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.role, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.presentation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.joinedAtRevision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userId);
        }
        if self.role != Member_Role::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.role);
        }
        if !self.profileKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.profileKey);
        }
        if !self.presentation.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.presentation);
        }
        if self.joinedAtRevision != 0 {
            my_size += ::protobuf::rt::value_size(5, self.joinedAtRevision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userId.is_empty() {
            os.write_bytes(1, &self.userId)?;
        }
        if self.role != Member_Role::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.role))?;
        }
        if !self.profileKey.is_empty() {
            os.write_bytes(3, &self.profileKey)?;
        }
        if !self.presentation.is_empty() {
            os.write_bytes(4, &self.presentation)?;
        }
        if self.joinedAtRevision != 0 {
            os.write_uint32(5, self.joinedAtRevision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Member {
        Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "userId",
                |m: &Member| { &m.userId },
                |m: &mut Member| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Member_Role>>(
                "role",
                |m: &Member| { &m.role },
                |m: &mut Member| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &Member| { &m.profileKey },
                |m: &mut Member| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "presentation",
                |m: &Member| { &m.presentation },
                |m: &mut Member| { &mut m.presentation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "joinedAtRevision",
                |m: &Member| { &m.joinedAtRevision },
                |m: &mut Member| { &mut m.joinedAtRevision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Member>(
                "Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Member {
        static instance: ::protobuf::rt::LazyV2<Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Member::new)
    }
}

impl ::protobuf::Clear for Member {
    fn clear(&mut self) {
        self.userId.clear();
        self.role = Member_Role::UNKNOWN;
        self.profileKey.clear();
        self.presentation.clear();
        self.joinedAtRevision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Member_Role {
    UNKNOWN = 0,
    DEFAULT = 1,
    ADMINISTRATOR = 2,
}

impl ::protobuf::ProtobufEnum for Member_Role {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Member_Role> {
        match value {
            0 => ::std::option::Option::Some(Member_Role::UNKNOWN),
            1 => ::std::option::Option::Some(Member_Role::DEFAULT),
            2 => ::std::option::Option::Some(Member_Role::ADMINISTRATOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Member_Role] = &[
            Member_Role::UNKNOWN,
            Member_Role::DEFAULT,
            Member_Role::ADMINISTRATOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Member_Role>("Member.Role", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Member_Role {
}

impl ::std::default::Default for Member_Role {
    fn default() -> Self {
        Member_Role::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Member_Role {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingMember {
    // message fields
    pub member: ::protobuf::SingularPtrField<Member>,
    pub addedByUserId: ::std::vec::Vec<u8>,
    pub timestamp: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingMember {
    fn default() -> &'a PendingMember {
        <PendingMember as ::protobuf::Message>::default_instance()
    }
}

impl PendingMember {
    pub fn new() -> PendingMember {
        ::std::default::Default::default()
    }

    // .signalservice.Member member = 1;


    pub fn get_member(&self) -> &Member {
        self.member.as_ref().unwrap_or_else(|| <Member as ::protobuf::Message>::default_instance())
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.member = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut Member {
        if self.member.is_none() {
            self.member.set_default();
        }
        self.member.as_mut().unwrap()
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        self.member.take().unwrap_or_else(|| Member::new())
    }

    // bytes addedByUserId = 2;


    pub fn get_addedByUserId(&self) -> &[u8] {
        &self.addedByUserId
    }
    pub fn clear_addedByUserId(&mut self) {
        self.addedByUserId.clear();
    }

    // Param is passed by value, moved
    pub fn set_addedByUserId(&mut self, v: ::std::vec::Vec<u8>) {
        self.addedByUserId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addedByUserId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.addedByUserId
    }

    // Take field
    pub fn take_addedByUserId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.addedByUserId, ::std::vec::Vec::new())
    }

    // uint64 timestamp = 3;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PendingMember {
    fn is_initialized(&self) -> bool {
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.addedByUserId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.addedByUserId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.addedByUserId);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.member.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.addedByUserId.is_empty() {
            os.write_bytes(2, &self.addedByUserId)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingMember {
        PendingMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "member",
                |m: &PendingMember| { &m.member },
                |m: &mut PendingMember| { &mut m.member },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "addedByUserId",
                |m: &PendingMember| { &m.addedByUserId },
                |m: &mut PendingMember| { &mut m.addedByUserId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &PendingMember| { &m.timestamp },
                |m: &mut PendingMember| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingMember>(
                "PendingMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingMember {
        static instance: ::protobuf::rt::LazyV2<PendingMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingMember::new)
    }
}

impl ::protobuf::Clear for PendingMember {
    fn clear(&mut self) {
        self.member.clear();
        self.addedByUserId.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RequestingMember {
    // message fields
    pub userId: ::std::vec::Vec<u8>,
    pub profileKey: ::std::vec::Vec<u8>,
    pub presentation: ::std::vec::Vec<u8>,
    pub timestamp: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestingMember {
    fn default() -> &'a RequestingMember {
        <RequestingMember as ::protobuf::Message>::default_instance()
    }
}

impl RequestingMember {
    pub fn new() -> RequestingMember {
        ::std::default::Default::default()
    }

    // bytes userId = 1;


    pub fn get_userId(&self) -> &[u8] {
        &self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId.clear();
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: ::std::vec::Vec<u8>) {
        self.userId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userId
    }

    // Take field
    pub fn take_userId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userId, ::std::vec::Vec::new())
    }

    // bytes profileKey = 2;


    pub fn get_profileKey(&self) -> &[u8] {
        &self.profileKey
    }
    pub fn clear_profileKey(&mut self) {
        self.profileKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_profileKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.profileKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profileKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.profileKey
    }

    // Take field
    pub fn take_profileKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.profileKey, ::std::vec::Vec::new())
    }

    // bytes presentation = 3;


    pub fn get_presentation(&self) -> &[u8] {
        &self.presentation
    }
    pub fn clear_presentation(&mut self) {
        self.presentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_presentation(&mut self, v: ::std::vec::Vec<u8>) {
        self.presentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presentation(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.presentation
    }

    // Take field
    pub fn take_presentation(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.presentation, ::std::vec::Vec::new())
    }

    // uint64 timestamp = 4;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for RequestingMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.profileKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.presentation)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userId);
        }
        if !self.profileKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.profileKey);
        }
        if !self.presentation.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.presentation);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userId.is_empty() {
            os.write_bytes(1, &self.userId)?;
        }
        if !self.profileKey.is_empty() {
            os.write_bytes(2, &self.profileKey)?;
        }
        if !self.presentation.is_empty() {
            os.write_bytes(3, &self.presentation)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestingMember {
        RequestingMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "userId",
                |m: &RequestingMember| { &m.userId },
                |m: &mut RequestingMember| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "profileKey",
                |m: &RequestingMember| { &m.profileKey },
                |m: &mut RequestingMember| { &mut m.profileKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "presentation",
                |m: &RequestingMember| { &m.presentation },
                |m: &mut RequestingMember| { &mut m.presentation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &RequestingMember| { &m.timestamp },
                |m: &mut RequestingMember| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestingMember>(
                "RequestingMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestingMember {
        static instance: ::protobuf::rt::LazyV2<RequestingMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestingMember::new)
    }
}

impl ::protobuf::Clear for RequestingMember {
    fn clear(&mut self) {
        self.userId.clear();
        self.profileKey.clear();
        self.presentation.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestingMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestingMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AccessControl {
    // message fields
    pub attributes: AccessControl_AccessRequired,
    pub members: AccessControl_AccessRequired,
    pub addFromInviteLink: AccessControl_AccessRequired,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccessControl {
    fn default() -> &'a AccessControl {
        <AccessControl as ::protobuf::Message>::default_instance()
    }
}

impl AccessControl {
    pub fn new() -> AccessControl {
        ::std::default::Default::default()
    }

    // .signalservice.AccessControl.AccessRequired attributes = 1;


    pub fn get_attributes(&self) -> AccessControl_AccessRequired {
        self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: AccessControl_AccessRequired) {
        self.attributes = v;
    }

    // .signalservice.AccessControl.AccessRequired members = 2;


    pub fn get_members(&self) -> AccessControl_AccessRequired {
        self.members
    }
    pub fn clear_members(&mut self) {
        self.members = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: AccessControl_AccessRequired) {
        self.members = v;
    }

    // .signalservice.AccessControl.AccessRequired addFromInviteLink = 3;


    pub fn get_addFromInviteLink(&self) -> AccessControl_AccessRequired {
        self.addFromInviteLink
    }
    pub fn clear_addFromInviteLink(&mut self) {
        self.addFromInviteLink = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_addFromInviteLink(&mut self, v: AccessControl_AccessRequired) {
        self.addFromInviteLink = v;
    }
}

impl ::protobuf::Message for AccessControl {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attributes, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.members, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.addFromInviteLink, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attributes != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.attributes);
        }
        if self.members != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.members);
        }
        if self.addFromInviteLink != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.addFromInviteLink);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attributes != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.attributes))?;
        }
        if self.members != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.members))?;
        }
        if self.addFromInviteLink != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.addFromInviteLink))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccessControl {
        AccessControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "attributes",
                |m: &AccessControl| { &m.attributes },
                |m: &mut AccessControl| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "members",
                |m: &AccessControl| { &m.members },
                |m: &mut AccessControl| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "addFromInviteLink",
                |m: &AccessControl| { &m.addFromInviteLink },
                |m: &mut AccessControl| { &mut m.addFromInviteLink },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccessControl>(
                "AccessControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccessControl {
        static instance: ::protobuf::rt::LazyV2<AccessControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccessControl::new)
    }
}

impl ::protobuf::Clear for AccessControl {
    fn clear(&mut self) {
        self.attributes = AccessControl_AccessRequired::UNKNOWN;
        self.members = AccessControl_AccessRequired::UNKNOWN;
        self.addFromInviteLink = AccessControl_AccessRequired::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccessControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AccessControl_AccessRequired {
    UNKNOWN = 0,
    ANY = 1,
    MEMBER = 2,
    ADMINISTRATOR = 3,
    UNSATISFIABLE = 4,
}

impl ::protobuf::ProtobufEnum for AccessControl_AccessRequired {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessControl_AccessRequired> {
        match value {
            0 => ::std::option::Option::Some(AccessControl_AccessRequired::UNKNOWN),
            1 => ::std::option::Option::Some(AccessControl_AccessRequired::ANY),
            2 => ::std::option::Option::Some(AccessControl_AccessRequired::MEMBER),
            3 => ::std::option::Option::Some(AccessControl_AccessRequired::ADMINISTRATOR),
            4 => ::std::option::Option::Some(AccessControl_AccessRequired::UNSATISFIABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccessControl_AccessRequired] = &[
            AccessControl_AccessRequired::UNKNOWN,
            AccessControl_AccessRequired::ANY,
            AccessControl_AccessRequired::MEMBER,
            AccessControl_AccessRequired::ADMINISTRATOR,
            AccessControl_AccessRequired::UNSATISFIABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AccessControl_AccessRequired>("AccessControl.AccessRequired", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AccessControl_AccessRequired {
}

impl ::std::default::Default for AccessControl_AccessRequired {
    fn default() -> Self {
        AccessControl_AccessRequired::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessControl_AccessRequired {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Group {
    // message fields
    pub publicKey: ::std::vec::Vec<u8>,
    pub title: ::std::vec::Vec<u8>,
    pub avatar: ::std::string::String,
    pub disappearingMessagesTimer: ::std::vec::Vec<u8>,
    pub accessControl: ::protobuf::SingularPtrField<AccessControl>,
    pub revision: u32,
    pub members: ::protobuf::RepeatedField<Member>,
    pub pendingMembers: ::protobuf::RepeatedField<PendingMember>,
    pub requestingMembers: ::protobuf::RepeatedField<RequestingMember>,
    pub inviteLinkPassword: ::std::vec::Vec<u8>,
    pub description: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Group {
    fn default() -> &'a Group {
        <Group as ::protobuf::Message>::default_instance()
    }
}

impl Group {
    pub fn new() -> Group {
        ::std::default::Default::default()
    }

    // bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        &self.publicKey
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.publicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.publicKey
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.publicKey, ::std::vec::Vec::new())
    }

    // bytes title = 2;


    pub fn get_title(&self) -> &[u8] {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::vec::Vec<u8>) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.title, ::std::vec::Vec::new())
    }

    // string avatar = 3;


    pub fn get_avatar(&self) -> &str {
        &self.avatar
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ::std::string::String) {
        self.avatar = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ::std::string::String {
        &mut self.avatar
    }

    // Take field
    pub fn take_avatar(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar, ::std::string::String::new())
    }

    // bytes disappearingMessagesTimer = 4;


    pub fn get_disappearingMessagesTimer(&self) -> &[u8] {
        &self.disappearingMessagesTimer
    }
    pub fn clear_disappearingMessagesTimer(&mut self) {
        self.disappearingMessagesTimer.clear();
    }

    // Param is passed by value, moved
    pub fn set_disappearingMessagesTimer(&mut self, v: ::std::vec::Vec<u8>) {
        self.disappearingMessagesTimer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disappearingMessagesTimer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.disappearingMessagesTimer
    }

    // Take field
    pub fn take_disappearingMessagesTimer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.disappearingMessagesTimer, ::std::vec::Vec::new())
    }

    // .signalservice.AccessControl accessControl = 5;


    pub fn get_accessControl(&self) -> &AccessControl {
        self.accessControl.as_ref().unwrap_or_else(|| <AccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_accessControl(&mut self) {
        self.accessControl.clear();
    }

    pub fn has_accessControl(&self) -> bool {
        self.accessControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessControl(&mut self, v: AccessControl) {
        self.accessControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessControl(&mut self) -> &mut AccessControl {
        if self.accessControl.is_none() {
            self.accessControl.set_default();
        }
        self.accessControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessControl(&mut self) -> AccessControl {
        self.accessControl.take().unwrap_or_else(|| AccessControl::new())
    }

    // uint32 revision = 6;


    pub fn get_revision(&self) -> u32 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = v;
    }

    // repeated .signalservice.Member members = 7;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.PendingMember pendingMembers = 8;


    pub fn get_pendingMembers(&self) -> &[PendingMember] {
        &self.pendingMembers
    }
    pub fn clear_pendingMembers(&mut self) {
        self.pendingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_pendingMembers(&mut self, v: ::protobuf::RepeatedField<PendingMember>) {
        self.pendingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pendingMembers(&mut self) -> &mut ::protobuf::RepeatedField<PendingMember> {
        &mut self.pendingMembers
    }

    // Take field
    pub fn take_pendingMembers(&mut self) -> ::protobuf::RepeatedField<PendingMember> {
        ::std::mem::replace(&mut self.pendingMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.RequestingMember requestingMembers = 9;


    pub fn get_requestingMembers(&self) -> &[RequestingMember] {
        &self.requestingMembers
    }
    pub fn clear_requestingMembers(&mut self) {
        self.requestingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_requestingMembers(&mut self, v: ::protobuf::RepeatedField<RequestingMember>) {
        self.requestingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requestingMembers(&mut self) -> &mut ::protobuf::RepeatedField<RequestingMember> {
        &mut self.requestingMembers
    }

    // Take field
    pub fn take_requestingMembers(&mut self) -> ::protobuf::RepeatedField<RequestingMember> {
        ::std::mem::replace(&mut self.requestingMembers, ::protobuf::RepeatedField::new())
    }

    // bytes inviteLinkPassword = 10;


    pub fn get_inviteLinkPassword(&self) -> &[u8] {
        &self.inviteLinkPassword
    }
    pub fn clear_inviteLinkPassword(&mut self) {
        self.inviteLinkPassword.clear();
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkPassword(&mut self, v: ::std::vec::Vec<u8>) {
        self.inviteLinkPassword = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteLinkPassword(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.inviteLinkPassword
    }

    // Take field
    pub fn take_inviteLinkPassword(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.inviteLinkPassword, ::std::vec::Vec::new())
    }

    // bytes description = 11;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Group {
    fn is_initialized(&self) -> bool {
        for v in &self.accessControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pendingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requestingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.disappearingMessagesTimer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.accessControl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pendingMembers)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requestingMembers)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.inviteLinkPassword)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.publicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.publicKey);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.title);
        }
        if !self.avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.avatar);
        }
        if !self.disappearingMessagesTimer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.disappearingMessagesTimer);
        }
        if let Some(ref v) = self.accessControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(6, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pendingMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.requestingMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.inviteLinkPassword.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.inviteLinkPassword);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.publicKey.is_empty() {
            os.write_bytes(1, &self.publicKey)?;
        }
        if !self.title.is_empty() {
            os.write_bytes(2, &self.title)?;
        }
        if !self.avatar.is_empty() {
            os.write_string(3, &self.avatar)?;
        }
        if !self.disappearingMessagesTimer.is_empty() {
            os.write_bytes(4, &self.disappearingMessagesTimer)?;
        }
        if let Some(ref v) = self.accessControl.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.revision != 0 {
            os.write_uint32(6, self.revision)?;
        }
        for v in &self.members {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pendingMembers {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.requestingMembers {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.inviteLinkPassword.is_empty() {
            os.write_bytes(10, &self.inviteLinkPassword)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(11, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Group {
        Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "publicKey",
                |m: &Group| { &m.publicKey },
                |m: &mut Group| { &mut m.publicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "title",
                |m: &Group| { &m.title },
                |m: &mut Group| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar",
                |m: &Group| { &m.avatar },
                |m: &mut Group| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "disappearingMessagesTimer",
                |m: &Group| { &m.disappearingMessagesTimer },
                |m: &mut Group| { &mut m.disappearingMessagesTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccessControl>>(
                "accessControl",
                |m: &Group| { &m.accessControl },
                |m: &mut Group| { &mut m.accessControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &Group| { &m.revision },
                |m: &mut Group| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "members",
                |m: &Group| { &m.members },
                |m: &mut Group| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingMember>>(
                "pendingMembers",
                |m: &Group| { &m.pendingMembers },
                |m: &mut Group| { &mut m.pendingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestingMember>>(
                "requestingMembers",
                |m: &Group| { &m.requestingMembers },
                |m: &mut Group| { &mut m.requestingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inviteLinkPassword",
                |m: &Group| { &m.inviteLinkPassword },
                |m: &mut Group| { &mut m.inviteLinkPassword },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description",
                |m: &Group| { &m.description },
                |m: &mut Group| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Group>(
                "Group",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Group {
        static instance: ::protobuf::rt::LazyV2<Group> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Group::new)
    }
}

impl ::protobuf::Clear for Group {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.title.clear();
        self.avatar.clear();
        self.disappearingMessagesTimer.clear();
        self.accessControl.clear();
        self.revision = 0;
        self.members.clear();
        self.pendingMembers.clear();
        self.requestingMembers.clear();
        self.inviteLinkPassword.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange {
    // message fields
    pub actions: ::std::vec::Vec<u8>,
    pub serverSignature: ::std::vec::Vec<u8>,
    pub changeEpoch: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange {
    fn default() -> &'a GroupChange {
        <GroupChange as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange {
    pub fn new() -> GroupChange {
        ::std::default::Default::default()
    }

    // bytes actions = 1;


    pub fn get_actions(&self) -> &[u8] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::std::vec::Vec<u8>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actions, ::std::vec::Vec::new())
    }

    // bytes serverSignature = 2;


    pub fn get_serverSignature(&self) -> &[u8] {
        &self.serverSignature
    }
    pub fn clear_serverSignature(&mut self) {
        self.serverSignature.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverSignature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serverSignature
    }

    // Take field
    pub fn take_serverSignature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serverSignature, ::std::vec::Vec::new())
    }

    // uint32 changeEpoch = 3;


    pub fn get_changeEpoch(&self) -> u32 {
        self.changeEpoch
    }
    pub fn clear_changeEpoch(&mut self) {
        self.changeEpoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_changeEpoch(&mut self, v: u32) {
        self.changeEpoch = v;
    }
}

impl ::protobuf::Message for GroupChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serverSignature)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.changeEpoch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actions.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.actions);
        }
        if !self.serverSignature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.serverSignature);
        }
        if self.changeEpoch != 0 {
            my_size += ::protobuf::rt::value_size(3, self.changeEpoch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actions.is_empty() {
            os.write_bytes(1, &self.actions)?;
        }
        if !self.serverSignature.is_empty() {
            os.write_bytes(2, &self.serverSignature)?;
        }
        if self.changeEpoch != 0 {
            os.write_uint32(3, self.changeEpoch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange {
        GroupChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actions",
                |m: &GroupChange| { &m.actions },
                |m: &mut GroupChange| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverSignature",
                |m: &GroupChange| { &m.serverSignature },
                |m: &mut GroupChange| { &mut m.serverSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "changeEpoch",
                |m: &GroupChange| { &m.changeEpoch },
                |m: &mut GroupChange| { &mut m.changeEpoch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange>(
                "GroupChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange {
        static instance: ::protobuf::rt::LazyV2<GroupChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange::new)
    }
}

impl ::protobuf::Clear for GroupChange {
    fn clear(&mut self) {
        self.actions.clear();
        self.serverSignature.clear();
        self.changeEpoch = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions {
    // message fields
    pub sourceUuid: ::std::vec::Vec<u8>,
    pub revision: u32,
    pub addMembers: ::protobuf::RepeatedField<GroupChange_Actions_AddMemberAction>,
    pub deleteMembers: ::protobuf::RepeatedField<GroupChange_Actions_DeleteMemberAction>,
    pub modifyMemberRoles: ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberRoleAction>,
    pub modifyMemberProfileKeys: ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberProfileKeyAction>,
    pub addPendingMembers: ::protobuf::RepeatedField<GroupChange_Actions_AddPendingMemberAction>,
    pub deletePendingMembers: ::protobuf::RepeatedField<GroupChange_Actions_DeletePendingMemberAction>,
    pub promotePendingMembers: ::protobuf::RepeatedField<GroupChange_Actions_PromotePendingMemberAction>,
    pub modifyTitle: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyTitleAction>,
    pub modifyAvatar: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyAvatarAction>,
    pub modifyDisappearingMessagesTimer: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyDisappearingMessagesTimerAction>,
    pub modifyAttributesAccess: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyAttributesAccessControlAction>,
    pub modifyMemberAccess: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyMembersAccessControlAction>,
    pub modifyAddFromInviteLinkAccess: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction>,
    pub addRequestingMembers: ::protobuf::RepeatedField<GroupChange_Actions_AddRequestingMemberAction>,
    pub deleteRequestingMembers: ::protobuf::RepeatedField<GroupChange_Actions_DeleteRequestingMemberAction>,
    pub promoteRequestingMembers: ::protobuf::RepeatedField<GroupChange_Actions_PromoteRequestingMemberAction>,
    pub modifyInviteLinkPassword: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyInviteLinkPasswordAction>,
    pub modifyDescription: ::protobuf::SingularPtrField<GroupChange_Actions_ModifyDescriptionAction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions {
    fn default() -> &'a GroupChange_Actions {
        <GroupChange_Actions as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions {
    pub fn new() -> GroupChange_Actions {
        ::std::default::Default::default()
    }

    // bytes sourceUuid = 1;


    pub fn get_sourceUuid(&self) -> &[u8] {
        &self.sourceUuid
    }
    pub fn clear_sourceUuid(&mut self) {
        self.sourceUuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_sourceUuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.sourceUuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceUuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sourceUuid
    }

    // Take field
    pub fn take_sourceUuid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sourceUuid, ::std::vec::Vec::new())
    }

    // uint32 revision = 2;


    pub fn get_revision(&self) -> u32 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = v;
    }

    // repeated .signalservice.GroupChange.Actions.AddMemberAction addMembers = 3;


    pub fn get_addMembers(&self) -> &[GroupChange_Actions_AddMemberAction] {
        &self.addMembers
    }
    pub fn clear_addMembers(&mut self) {
        self.addMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_addMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_AddMemberAction>) {
        self.addMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_AddMemberAction> {
        &mut self.addMembers
    }

    // Take field
    pub fn take_addMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_AddMemberAction> {
        ::std::mem::replace(&mut self.addMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.DeleteMemberAction deleteMembers = 4;


    pub fn get_deleteMembers(&self) -> &[GroupChange_Actions_DeleteMemberAction] {
        &self.deleteMembers
    }
    pub fn clear_deleteMembers(&mut self) {
        self.deleteMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_deleteMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_DeleteMemberAction>) {
        self.deleteMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deleteMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_DeleteMemberAction> {
        &mut self.deleteMembers
    }

    // Take field
    pub fn take_deleteMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_DeleteMemberAction> {
        ::std::mem::replace(&mut self.deleteMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.ModifyMemberRoleAction modifyMemberRoles = 5;


    pub fn get_modifyMemberRoles(&self) -> &[GroupChange_Actions_ModifyMemberRoleAction] {
        &self.modifyMemberRoles
    }
    pub fn clear_modifyMemberRoles(&mut self) {
        self.modifyMemberRoles.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifyMemberRoles(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberRoleAction>) {
        self.modifyMemberRoles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifyMemberRoles(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberRoleAction> {
        &mut self.modifyMemberRoles
    }

    // Take field
    pub fn take_modifyMemberRoles(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberRoleAction> {
        ::std::mem::replace(&mut self.modifyMemberRoles, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.ModifyMemberProfileKeyAction modifyMemberProfileKeys = 6;


    pub fn get_modifyMemberProfileKeys(&self) -> &[GroupChange_Actions_ModifyMemberProfileKeyAction] {
        &self.modifyMemberProfileKeys
    }
    pub fn clear_modifyMemberProfileKeys(&mut self) {
        self.modifyMemberProfileKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifyMemberProfileKeys(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberProfileKeyAction>) {
        self.modifyMemberProfileKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifyMemberProfileKeys(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberProfileKeyAction> {
        &mut self.modifyMemberProfileKeys
    }

    // Take field
    pub fn take_modifyMemberProfileKeys(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_ModifyMemberProfileKeyAction> {
        ::std::mem::replace(&mut self.modifyMemberProfileKeys, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.AddPendingMemberAction addPendingMembers = 7;


    pub fn get_addPendingMembers(&self) -> &[GroupChange_Actions_AddPendingMemberAction] {
        &self.addPendingMembers
    }
    pub fn clear_addPendingMembers(&mut self) {
        self.addPendingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_addPendingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_AddPendingMemberAction>) {
        self.addPendingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addPendingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_AddPendingMemberAction> {
        &mut self.addPendingMembers
    }

    // Take field
    pub fn take_addPendingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_AddPendingMemberAction> {
        ::std::mem::replace(&mut self.addPendingMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.DeletePendingMemberAction deletePendingMembers = 8;


    pub fn get_deletePendingMembers(&self) -> &[GroupChange_Actions_DeletePendingMemberAction] {
        &self.deletePendingMembers
    }
    pub fn clear_deletePendingMembers(&mut self) {
        self.deletePendingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletePendingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_DeletePendingMemberAction>) {
        self.deletePendingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deletePendingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_DeletePendingMemberAction> {
        &mut self.deletePendingMembers
    }

    // Take field
    pub fn take_deletePendingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_DeletePendingMemberAction> {
        ::std::mem::replace(&mut self.deletePendingMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.PromotePendingMemberAction promotePendingMembers = 9;


    pub fn get_promotePendingMembers(&self) -> &[GroupChange_Actions_PromotePendingMemberAction] {
        &self.promotePendingMembers
    }
    pub fn clear_promotePendingMembers(&mut self) {
        self.promotePendingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_promotePendingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_PromotePendingMemberAction>) {
        self.promotePendingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_promotePendingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_PromotePendingMemberAction> {
        &mut self.promotePendingMembers
    }

    // Take field
    pub fn take_promotePendingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_PromotePendingMemberAction> {
        ::std::mem::replace(&mut self.promotePendingMembers, ::protobuf::RepeatedField::new())
    }

    // .signalservice.GroupChange.Actions.ModifyTitleAction modifyTitle = 10;


    pub fn get_modifyTitle(&self) -> &GroupChange_Actions_ModifyTitleAction {
        self.modifyTitle.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyTitleAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyTitle(&mut self) {
        self.modifyTitle.clear();
    }

    pub fn has_modifyTitle(&self) -> bool {
        self.modifyTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyTitle(&mut self, v: GroupChange_Actions_ModifyTitleAction) {
        self.modifyTitle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyTitle(&mut self) -> &mut GroupChange_Actions_ModifyTitleAction {
        if self.modifyTitle.is_none() {
            self.modifyTitle.set_default();
        }
        self.modifyTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyTitle(&mut self) -> GroupChange_Actions_ModifyTitleAction {
        self.modifyTitle.take().unwrap_or_else(|| GroupChange_Actions_ModifyTitleAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyAvatarAction modifyAvatar = 11;


    pub fn get_modifyAvatar(&self) -> &GroupChange_Actions_ModifyAvatarAction {
        self.modifyAvatar.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyAvatarAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyAvatar(&mut self) {
        self.modifyAvatar.clear();
    }

    pub fn has_modifyAvatar(&self) -> bool {
        self.modifyAvatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyAvatar(&mut self, v: GroupChange_Actions_ModifyAvatarAction) {
        self.modifyAvatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyAvatar(&mut self) -> &mut GroupChange_Actions_ModifyAvatarAction {
        if self.modifyAvatar.is_none() {
            self.modifyAvatar.set_default();
        }
        self.modifyAvatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyAvatar(&mut self) -> GroupChange_Actions_ModifyAvatarAction {
        self.modifyAvatar.take().unwrap_or_else(|| GroupChange_Actions_ModifyAvatarAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyDisappearingMessagesTimerAction modifyDisappearingMessagesTimer = 12;


    pub fn get_modifyDisappearingMessagesTimer(&self) -> &GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        self.modifyDisappearingMessagesTimer.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyDisappearingMessagesTimerAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyDisappearingMessagesTimer(&mut self) {
        self.modifyDisappearingMessagesTimer.clear();
    }

    pub fn has_modifyDisappearingMessagesTimer(&self) -> bool {
        self.modifyDisappearingMessagesTimer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyDisappearingMessagesTimer(&mut self, v: GroupChange_Actions_ModifyDisappearingMessagesTimerAction) {
        self.modifyDisappearingMessagesTimer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyDisappearingMessagesTimer(&mut self) -> &mut GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        if self.modifyDisappearingMessagesTimer.is_none() {
            self.modifyDisappearingMessagesTimer.set_default();
        }
        self.modifyDisappearingMessagesTimer.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyDisappearingMessagesTimer(&mut self) -> GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        self.modifyDisappearingMessagesTimer.take().unwrap_or_else(|| GroupChange_Actions_ModifyDisappearingMessagesTimerAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyAttributesAccessControlAction modifyAttributesAccess = 13;


    pub fn get_modifyAttributesAccess(&self) -> &GroupChange_Actions_ModifyAttributesAccessControlAction {
        self.modifyAttributesAccess.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyAttributesAccessControlAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyAttributesAccess(&mut self) {
        self.modifyAttributesAccess.clear();
    }

    pub fn has_modifyAttributesAccess(&self) -> bool {
        self.modifyAttributesAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyAttributesAccess(&mut self, v: GroupChange_Actions_ModifyAttributesAccessControlAction) {
        self.modifyAttributesAccess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyAttributesAccess(&mut self) -> &mut GroupChange_Actions_ModifyAttributesAccessControlAction {
        if self.modifyAttributesAccess.is_none() {
            self.modifyAttributesAccess.set_default();
        }
        self.modifyAttributesAccess.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyAttributesAccess(&mut self) -> GroupChange_Actions_ModifyAttributesAccessControlAction {
        self.modifyAttributesAccess.take().unwrap_or_else(|| GroupChange_Actions_ModifyAttributesAccessControlAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyMembersAccessControlAction modifyMemberAccess = 14;


    pub fn get_modifyMemberAccess(&self) -> &GroupChange_Actions_ModifyMembersAccessControlAction {
        self.modifyMemberAccess.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyMembersAccessControlAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyMemberAccess(&mut self) {
        self.modifyMemberAccess.clear();
    }

    pub fn has_modifyMemberAccess(&self) -> bool {
        self.modifyMemberAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyMemberAccess(&mut self, v: GroupChange_Actions_ModifyMembersAccessControlAction) {
        self.modifyMemberAccess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyMemberAccess(&mut self) -> &mut GroupChange_Actions_ModifyMembersAccessControlAction {
        if self.modifyMemberAccess.is_none() {
            self.modifyMemberAccess.set_default();
        }
        self.modifyMemberAccess.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyMemberAccess(&mut self) -> GroupChange_Actions_ModifyMembersAccessControlAction {
        self.modifyMemberAccess.take().unwrap_or_else(|| GroupChange_Actions_ModifyMembersAccessControlAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction modifyAddFromInviteLinkAccess = 15;


    pub fn get_modifyAddFromInviteLinkAccess(&self) -> &GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        self.modifyAddFromInviteLinkAccess.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyAddFromInviteLinkAccess(&mut self) {
        self.modifyAddFromInviteLinkAccess.clear();
    }

    pub fn has_modifyAddFromInviteLinkAccess(&self) -> bool {
        self.modifyAddFromInviteLinkAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyAddFromInviteLinkAccess(&mut self, v: GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction) {
        self.modifyAddFromInviteLinkAccess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyAddFromInviteLinkAccess(&mut self) -> &mut GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        if self.modifyAddFromInviteLinkAccess.is_none() {
            self.modifyAddFromInviteLinkAccess.set_default();
        }
        self.modifyAddFromInviteLinkAccess.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyAddFromInviteLinkAccess(&mut self) -> GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        self.modifyAddFromInviteLinkAccess.take().unwrap_or_else(|| GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction::new())
    }

    // repeated .signalservice.GroupChange.Actions.AddRequestingMemberAction addRequestingMembers = 16;


    pub fn get_addRequestingMembers(&self) -> &[GroupChange_Actions_AddRequestingMemberAction] {
        &self.addRequestingMembers
    }
    pub fn clear_addRequestingMembers(&mut self) {
        self.addRequestingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_addRequestingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_AddRequestingMemberAction>) {
        self.addRequestingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addRequestingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_AddRequestingMemberAction> {
        &mut self.addRequestingMembers
    }

    // Take field
    pub fn take_addRequestingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_AddRequestingMemberAction> {
        ::std::mem::replace(&mut self.addRequestingMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.DeleteRequestingMemberAction deleteRequestingMembers = 17;


    pub fn get_deleteRequestingMembers(&self) -> &[GroupChange_Actions_DeleteRequestingMemberAction] {
        &self.deleteRequestingMembers
    }
    pub fn clear_deleteRequestingMembers(&mut self) {
        self.deleteRequestingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_deleteRequestingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_DeleteRequestingMemberAction>) {
        self.deleteRequestingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deleteRequestingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_DeleteRequestingMemberAction> {
        &mut self.deleteRequestingMembers
    }

    // Take field
    pub fn take_deleteRequestingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_DeleteRequestingMemberAction> {
        ::std::mem::replace(&mut self.deleteRequestingMembers, ::protobuf::RepeatedField::new())
    }

    // repeated .signalservice.GroupChange.Actions.PromoteRequestingMemberAction promoteRequestingMembers = 18;


    pub fn get_promoteRequestingMembers(&self) -> &[GroupChange_Actions_PromoteRequestingMemberAction] {
        &self.promoteRequestingMembers
    }
    pub fn clear_promoteRequestingMembers(&mut self) {
        self.promoteRequestingMembers.clear();
    }

    // Param is passed by value, moved
    pub fn set_promoteRequestingMembers(&mut self, v: ::protobuf::RepeatedField<GroupChange_Actions_PromoteRequestingMemberAction>) {
        self.promoteRequestingMembers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_promoteRequestingMembers(&mut self) -> &mut ::protobuf::RepeatedField<GroupChange_Actions_PromoteRequestingMemberAction> {
        &mut self.promoteRequestingMembers
    }

    // Take field
    pub fn take_promoteRequestingMembers(&mut self) -> ::protobuf::RepeatedField<GroupChange_Actions_PromoteRequestingMemberAction> {
        ::std::mem::replace(&mut self.promoteRequestingMembers, ::protobuf::RepeatedField::new())
    }

    // .signalservice.GroupChange.Actions.ModifyInviteLinkPasswordAction modifyInviteLinkPassword = 19;


    pub fn get_modifyInviteLinkPassword(&self) -> &GroupChange_Actions_ModifyInviteLinkPasswordAction {
        self.modifyInviteLinkPassword.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyInviteLinkPasswordAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyInviteLinkPassword(&mut self) {
        self.modifyInviteLinkPassword.clear();
    }

    pub fn has_modifyInviteLinkPassword(&self) -> bool {
        self.modifyInviteLinkPassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyInviteLinkPassword(&mut self, v: GroupChange_Actions_ModifyInviteLinkPasswordAction) {
        self.modifyInviteLinkPassword = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyInviteLinkPassword(&mut self) -> &mut GroupChange_Actions_ModifyInviteLinkPasswordAction {
        if self.modifyInviteLinkPassword.is_none() {
            self.modifyInviteLinkPassword.set_default();
        }
        self.modifyInviteLinkPassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyInviteLinkPassword(&mut self) -> GroupChange_Actions_ModifyInviteLinkPasswordAction {
        self.modifyInviteLinkPassword.take().unwrap_or_else(|| GroupChange_Actions_ModifyInviteLinkPasswordAction::new())
    }

    // .signalservice.GroupChange.Actions.ModifyDescriptionAction modifyDescription = 20;


    pub fn get_modifyDescription(&self) -> &GroupChange_Actions_ModifyDescriptionAction {
        self.modifyDescription.as_ref().unwrap_or_else(|| <GroupChange_Actions_ModifyDescriptionAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyDescription(&mut self) {
        self.modifyDescription.clear();
    }

    pub fn has_modifyDescription(&self) -> bool {
        self.modifyDescription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyDescription(&mut self, v: GroupChange_Actions_ModifyDescriptionAction) {
        self.modifyDescription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyDescription(&mut self) -> &mut GroupChange_Actions_ModifyDescriptionAction {
        if self.modifyDescription.is_none() {
            self.modifyDescription.set_default();
        }
        self.modifyDescription.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyDescription(&mut self) -> GroupChange_Actions_ModifyDescriptionAction {
        self.modifyDescription.take().unwrap_or_else(|| GroupChange_Actions_ModifyDescriptionAction::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions {
    fn is_initialized(&self) -> bool {
        for v in &self.addMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deleteMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyMemberRoles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyMemberProfileKeys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addPendingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deletePendingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.promotePendingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyTitle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyAvatar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyDisappearingMessagesTimer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyAttributesAccess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyMemberAccess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyAddFromInviteLinkAccess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addRequestingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deleteRequestingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.promoteRequestingMembers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyInviteLinkPassword {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyDescription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sourceUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addMembers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deleteMembers)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifyMemberRoles)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifyMemberProfileKeys)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addPendingMembers)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deletePendingMembers)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.promotePendingMembers)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyTitle)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyAvatar)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyDisappearingMessagesTimer)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyAttributesAccess)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyMemberAccess)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyAddFromInviteLinkAccess)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addRequestingMembers)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deleteRequestingMembers)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.promoteRequestingMembers)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyInviteLinkPassword)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sourceUuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sourceUuid);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(2, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.addMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deleteMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.modifyMemberRoles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.modifyMemberProfileKeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.addPendingMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deletePendingMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.promotePendingMembers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.modifyTitle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyAvatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyDisappearingMessagesTimer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyAttributesAccess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyMemberAccess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyAddFromInviteLinkAccess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.addRequestingMembers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deleteRequestingMembers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.promoteRequestingMembers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.modifyInviteLinkPassword.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyDescription.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sourceUuid.is_empty() {
            os.write_bytes(1, &self.sourceUuid)?;
        }
        if self.revision != 0 {
            os.write_uint32(2, self.revision)?;
        }
        for v in &self.addMembers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deleteMembers {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.modifyMemberRoles {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.modifyMemberProfileKeys {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.addPendingMembers {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deletePendingMembers {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.promotePendingMembers {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.modifyTitle.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyAvatar.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyDisappearingMessagesTimer.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyAttributesAccess.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyMemberAccess.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyAddFromInviteLinkAccess.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.addRequestingMembers {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deleteRequestingMembers {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.promoteRequestingMembers {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.modifyInviteLinkPassword.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyDescription.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions {
        GroupChange_Actions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sourceUuid",
                |m: &GroupChange_Actions| { &m.sourceUuid },
                |m: &mut GroupChange_Actions| { &mut m.sourceUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &GroupChange_Actions| { &m.revision },
                |m: &mut GroupChange_Actions| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_AddMemberAction>>(
                "addMembers",
                |m: &GroupChange_Actions| { &m.addMembers },
                |m: &mut GroupChange_Actions| { &mut m.addMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_DeleteMemberAction>>(
                "deleteMembers",
                |m: &GroupChange_Actions| { &m.deleteMembers },
                |m: &mut GroupChange_Actions| { &mut m.deleteMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyMemberRoleAction>>(
                "modifyMemberRoles",
                |m: &GroupChange_Actions| { &m.modifyMemberRoles },
                |m: &mut GroupChange_Actions| { &mut m.modifyMemberRoles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyMemberProfileKeyAction>>(
                "modifyMemberProfileKeys",
                |m: &GroupChange_Actions| { &m.modifyMemberProfileKeys },
                |m: &mut GroupChange_Actions| { &mut m.modifyMemberProfileKeys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_AddPendingMemberAction>>(
                "addPendingMembers",
                |m: &GroupChange_Actions| { &m.addPendingMembers },
                |m: &mut GroupChange_Actions| { &mut m.addPendingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_DeletePendingMemberAction>>(
                "deletePendingMembers",
                |m: &GroupChange_Actions| { &m.deletePendingMembers },
                |m: &mut GroupChange_Actions| { &mut m.deletePendingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_PromotePendingMemberAction>>(
                "promotePendingMembers",
                |m: &GroupChange_Actions| { &m.promotePendingMembers },
                |m: &mut GroupChange_Actions| { &mut m.promotePendingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyTitleAction>>(
                "modifyTitle",
                |m: &GroupChange_Actions| { &m.modifyTitle },
                |m: &mut GroupChange_Actions| { &mut m.modifyTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyAvatarAction>>(
                "modifyAvatar",
                |m: &GroupChange_Actions| { &m.modifyAvatar },
                |m: &mut GroupChange_Actions| { &mut m.modifyAvatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyDisappearingMessagesTimerAction>>(
                "modifyDisappearingMessagesTimer",
                |m: &GroupChange_Actions| { &m.modifyDisappearingMessagesTimer },
                |m: &mut GroupChange_Actions| { &mut m.modifyDisappearingMessagesTimer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyAttributesAccessControlAction>>(
                "modifyAttributesAccess",
                |m: &GroupChange_Actions| { &m.modifyAttributesAccess },
                |m: &mut GroupChange_Actions| { &mut m.modifyAttributesAccess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyMembersAccessControlAction>>(
                "modifyMemberAccess",
                |m: &GroupChange_Actions| { &m.modifyMemberAccess },
                |m: &mut GroupChange_Actions| { &mut m.modifyMemberAccess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction>>(
                "modifyAddFromInviteLinkAccess",
                |m: &GroupChange_Actions| { &m.modifyAddFromInviteLinkAccess },
                |m: &mut GroupChange_Actions| { &mut m.modifyAddFromInviteLinkAccess },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_AddRequestingMemberAction>>(
                "addRequestingMembers",
                |m: &GroupChange_Actions| { &m.addRequestingMembers },
                |m: &mut GroupChange_Actions| { &mut m.addRequestingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_DeleteRequestingMemberAction>>(
                "deleteRequestingMembers",
                |m: &GroupChange_Actions| { &m.deleteRequestingMembers },
                |m: &mut GroupChange_Actions| { &mut m.deleteRequestingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_PromoteRequestingMemberAction>>(
                "promoteRequestingMembers",
                |m: &GroupChange_Actions| { &m.promoteRequestingMembers },
                |m: &mut GroupChange_Actions| { &mut m.promoteRequestingMembers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyInviteLinkPasswordAction>>(
                "modifyInviteLinkPassword",
                |m: &GroupChange_Actions| { &m.modifyInviteLinkPassword },
                |m: &mut GroupChange_Actions| { &mut m.modifyInviteLinkPassword },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange_Actions_ModifyDescriptionAction>>(
                "modifyDescription",
                |m: &GroupChange_Actions| { &m.modifyDescription },
                |m: &mut GroupChange_Actions| { &mut m.modifyDescription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions>(
                "GroupChange.Actions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions {
    fn clear(&mut self) {
        self.sourceUuid.clear();
        self.revision = 0;
        self.addMembers.clear();
        self.deleteMembers.clear();
        self.modifyMemberRoles.clear();
        self.modifyMemberProfileKeys.clear();
        self.addPendingMembers.clear();
        self.deletePendingMembers.clear();
        self.promotePendingMembers.clear();
        self.modifyTitle.clear();
        self.modifyAvatar.clear();
        self.modifyDisappearingMessagesTimer.clear();
        self.modifyAttributesAccess.clear();
        self.modifyMemberAccess.clear();
        self.modifyAddFromInviteLinkAccess.clear();
        self.addRequestingMembers.clear();
        self.deleteRequestingMembers.clear();
        self.promoteRequestingMembers.clear();
        self.modifyInviteLinkPassword.clear();
        self.modifyDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_AddMemberAction {
    // message fields
    pub added: ::protobuf::SingularPtrField<Member>,
    pub joinFromInviteLink: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_AddMemberAction {
    fn default() -> &'a GroupChange_Actions_AddMemberAction {
        <GroupChange_Actions_AddMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_AddMemberAction {
    pub fn new() -> GroupChange_Actions_AddMemberAction {
        ::std::default::Default::default()
    }

    // .signalservice.Member added = 1;


    pub fn get_added(&self) -> &Member {
        self.added.as_ref().unwrap_or_else(|| <Member as ::protobuf::Message>::default_instance())
    }
    pub fn clear_added(&mut self) {
        self.added.clear();
    }

    pub fn has_added(&self) -> bool {
        self.added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_added(&mut self, v: Member) {
        self.added = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_added(&mut self) -> &mut Member {
        if self.added.is_none() {
            self.added.set_default();
        }
        self.added.as_mut().unwrap()
    }

    // Take field
    pub fn take_added(&mut self) -> Member {
        self.added.take().unwrap_or_else(|| Member::new())
    }

    // bool joinFromInviteLink = 2;


    pub fn get_joinFromInviteLink(&self) -> bool {
        self.joinFromInviteLink
    }
    pub fn clear_joinFromInviteLink(&mut self) {
        self.joinFromInviteLink = false;
    }

    // Param is passed by value, moved
    pub fn set_joinFromInviteLink(&mut self, v: bool) {
        self.joinFromInviteLink = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_AddMemberAction {
    fn is_initialized(&self) -> bool {
        for v in &self.added {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.added)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.joinFromInviteLink = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.added.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.joinFromInviteLink != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.added.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.joinFromInviteLink != false {
            os.write_bool(2, self.joinFromInviteLink)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_AddMemberAction {
        GroupChange_Actions_AddMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "added",
                |m: &GroupChange_Actions_AddMemberAction| { &m.added },
                |m: &mut GroupChange_Actions_AddMemberAction| { &mut m.added },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "joinFromInviteLink",
                |m: &GroupChange_Actions_AddMemberAction| { &m.joinFromInviteLink },
                |m: &mut GroupChange_Actions_AddMemberAction| { &mut m.joinFromInviteLink },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_AddMemberAction>(
                "GroupChange.Actions.AddMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_AddMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_AddMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_AddMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_AddMemberAction {
    fn clear(&mut self) {
        self.added.clear();
        self.joinFromInviteLink = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_AddMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_AddMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_DeleteMemberAction {
    // message fields
    pub deletedUserId: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_DeleteMemberAction {
    fn default() -> &'a GroupChange_Actions_DeleteMemberAction {
        <GroupChange_Actions_DeleteMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_DeleteMemberAction {
    pub fn new() -> GroupChange_Actions_DeleteMemberAction {
        ::std::default::Default::default()
    }

    // bytes deletedUserId = 1;


    pub fn get_deletedUserId(&self) -> &[u8] {
        &self.deletedUserId
    }
    pub fn clear_deletedUserId(&mut self) {
        self.deletedUserId.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedUserId(&mut self, v: ::std::vec::Vec<u8>) {
        self.deletedUserId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletedUserId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deletedUserId
    }

    // Take field
    pub fn take_deletedUserId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deletedUserId, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_DeleteMemberAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.deletedUserId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.deletedUserId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.deletedUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.deletedUserId.is_empty() {
            os.write_bytes(1, &self.deletedUserId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_DeleteMemberAction {
        GroupChange_Actions_DeleteMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "deletedUserId",
                |m: &GroupChange_Actions_DeleteMemberAction| { &m.deletedUserId },
                |m: &mut GroupChange_Actions_DeleteMemberAction| { &mut m.deletedUserId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_DeleteMemberAction>(
                "GroupChange.Actions.DeleteMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_DeleteMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_DeleteMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_DeleteMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_DeleteMemberAction {
    fn clear(&mut self) {
        self.deletedUserId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_DeleteMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_DeleteMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyMemberRoleAction {
    // message fields
    pub userId: ::std::vec::Vec<u8>,
    pub role: Member_Role,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyMemberRoleAction {
    fn default() -> &'a GroupChange_Actions_ModifyMemberRoleAction {
        <GroupChange_Actions_ModifyMemberRoleAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyMemberRoleAction {
    pub fn new() -> GroupChange_Actions_ModifyMemberRoleAction {
        ::std::default::Default::default()
    }

    // bytes userId = 1;


    pub fn get_userId(&self) -> &[u8] {
        &self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId.clear();
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: ::std::vec::Vec<u8>) {
        self.userId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userId
    }

    // Take field
    pub fn take_userId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userId, ::std::vec::Vec::new())
    }

    // .signalservice.Member.Role role = 2;


    pub fn get_role(&self) -> Member_Role {
        self.role
    }
    pub fn clear_role(&mut self) {
        self.role = Member_Role::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Member_Role) {
        self.role = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyMemberRoleAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userId)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.role, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userId);
        }
        if self.role != Member_Role::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userId.is_empty() {
            os.write_bytes(1, &self.userId)?;
        }
        if self.role != Member_Role::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.role))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyMemberRoleAction {
        GroupChange_Actions_ModifyMemberRoleAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "userId",
                |m: &GroupChange_Actions_ModifyMemberRoleAction| { &m.userId },
                |m: &mut GroupChange_Actions_ModifyMemberRoleAction| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Member_Role>>(
                "role",
                |m: &GroupChange_Actions_ModifyMemberRoleAction| { &m.role },
                |m: &mut GroupChange_Actions_ModifyMemberRoleAction| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyMemberRoleAction>(
                "GroupChange.Actions.ModifyMemberRoleAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyMemberRoleAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyMemberRoleAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyMemberRoleAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyMemberRoleAction {
    fn clear(&mut self) {
        self.userId.clear();
        self.role = Member_Role::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyMemberRoleAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyMemberRoleAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyMemberProfileKeyAction {
    // message fields
    pub presentation: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyMemberProfileKeyAction {
    fn default() -> &'a GroupChange_Actions_ModifyMemberProfileKeyAction {
        <GroupChange_Actions_ModifyMemberProfileKeyAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyMemberProfileKeyAction {
    pub fn new() -> GroupChange_Actions_ModifyMemberProfileKeyAction {
        ::std::default::Default::default()
    }

    // bytes presentation = 1;


    pub fn get_presentation(&self) -> &[u8] {
        &self.presentation
    }
    pub fn clear_presentation(&mut self) {
        self.presentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_presentation(&mut self, v: ::std::vec::Vec<u8>) {
        self.presentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presentation(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.presentation
    }

    // Take field
    pub fn take_presentation(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.presentation, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyMemberProfileKeyAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.presentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.presentation.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.presentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.presentation.is_empty() {
            os.write_bytes(1, &self.presentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyMemberProfileKeyAction {
        GroupChange_Actions_ModifyMemberProfileKeyAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "presentation",
                |m: &GroupChange_Actions_ModifyMemberProfileKeyAction| { &m.presentation },
                |m: &mut GroupChange_Actions_ModifyMemberProfileKeyAction| { &mut m.presentation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyMemberProfileKeyAction>(
                "GroupChange.Actions.ModifyMemberProfileKeyAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyMemberProfileKeyAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyMemberProfileKeyAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyMemberProfileKeyAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyMemberProfileKeyAction {
    fn clear(&mut self) {
        self.presentation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyMemberProfileKeyAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyMemberProfileKeyAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_AddPendingMemberAction {
    // message fields
    pub added: ::protobuf::SingularPtrField<PendingMember>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_AddPendingMemberAction {
    fn default() -> &'a GroupChange_Actions_AddPendingMemberAction {
        <GroupChange_Actions_AddPendingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_AddPendingMemberAction {
    pub fn new() -> GroupChange_Actions_AddPendingMemberAction {
        ::std::default::Default::default()
    }

    // .signalservice.PendingMember added = 1;


    pub fn get_added(&self) -> &PendingMember {
        self.added.as_ref().unwrap_or_else(|| <PendingMember as ::protobuf::Message>::default_instance())
    }
    pub fn clear_added(&mut self) {
        self.added.clear();
    }

    pub fn has_added(&self) -> bool {
        self.added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_added(&mut self, v: PendingMember) {
        self.added = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_added(&mut self) -> &mut PendingMember {
        if self.added.is_none() {
            self.added.set_default();
        }
        self.added.as_mut().unwrap()
    }

    // Take field
    pub fn take_added(&mut self) -> PendingMember {
        self.added.take().unwrap_or_else(|| PendingMember::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_AddPendingMemberAction {
    fn is_initialized(&self) -> bool {
        for v in &self.added {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.added)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.added.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.added.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_AddPendingMemberAction {
        GroupChange_Actions_AddPendingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingMember>>(
                "added",
                |m: &GroupChange_Actions_AddPendingMemberAction| { &m.added },
                |m: &mut GroupChange_Actions_AddPendingMemberAction| { &mut m.added },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_AddPendingMemberAction>(
                "GroupChange.Actions.AddPendingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_AddPendingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_AddPendingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_AddPendingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_AddPendingMemberAction {
    fn clear(&mut self) {
        self.added.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_AddPendingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_AddPendingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_DeletePendingMemberAction {
    // message fields
    pub deletedUserId: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_DeletePendingMemberAction {
    fn default() -> &'a GroupChange_Actions_DeletePendingMemberAction {
        <GroupChange_Actions_DeletePendingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_DeletePendingMemberAction {
    pub fn new() -> GroupChange_Actions_DeletePendingMemberAction {
        ::std::default::Default::default()
    }

    // bytes deletedUserId = 1;


    pub fn get_deletedUserId(&self) -> &[u8] {
        &self.deletedUserId
    }
    pub fn clear_deletedUserId(&mut self) {
        self.deletedUserId.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedUserId(&mut self, v: ::std::vec::Vec<u8>) {
        self.deletedUserId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletedUserId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deletedUserId
    }

    // Take field
    pub fn take_deletedUserId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deletedUserId, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_DeletePendingMemberAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.deletedUserId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.deletedUserId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.deletedUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.deletedUserId.is_empty() {
            os.write_bytes(1, &self.deletedUserId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_DeletePendingMemberAction {
        GroupChange_Actions_DeletePendingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "deletedUserId",
                |m: &GroupChange_Actions_DeletePendingMemberAction| { &m.deletedUserId },
                |m: &mut GroupChange_Actions_DeletePendingMemberAction| { &mut m.deletedUserId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_DeletePendingMemberAction>(
                "GroupChange.Actions.DeletePendingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_DeletePendingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_DeletePendingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_DeletePendingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_DeletePendingMemberAction {
    fn clear(&mut self) {
        self.deletedUserId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_DeletePendingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_DeletePendingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_PromotePendingMemberAction {
    // message fields
    pub presentation: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_PromotePendingMemberAction {
    fn default() -> &'a GroupChange_Actions_PromotePendingMemberAction {
        <GroupChange_Actions_PromotePendingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_PromotePendingMemberAction {
    pub fn new() -> GroupChange_Actions_PromotePendingMemberAction {
        ::std::default::Default::default()
    }

    // bytes presentation = 1;


    pub fn get_presentation(&self) -> &[u8] {
        &self.presentation
    }
    pub fn clear_presentation(&mut self) {
        self.presentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_presentation(&mut self, v: ::std::vec::Vec<u8>) {
        self.presentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presentation(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.presentation
    }

    // Take field
    pub fn take_presentation(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.presentation, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_PromotePendingMemberAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.presentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.presentation.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.presentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.presentation.is_empty() {
            os.write_bytes(1, &self.presentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_PromotePendingMemberAction {
        GroupChange_Actions_PromotePendingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "presentation",
                |m: &GroupChange_Actions_PromotePendingMemberAction| { &m.presentation },
                |m: &mut GroupChange_Actions_PromotePendingMemberAction| { &mut m.presentation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_PromotePendingMemberAction>(
                "GroupChange.Actions.PromotePendingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_PromotePendingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_PromotePendingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_PromotePendingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_PromotePendingMemberAction {
    fn clear(&mut self) {
        self.presentation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_PromotePendingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_PromotePendingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_AddRequestingMemberAction {
    // message fields
    pub added: ::protobuf::SingularPtrField<RequestingMember>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_AddRequestingMemberAction {
    fn default() -> &'a GroupChange_Actions_AddRequestingMemberAction {
        <GroupChange_Actions_AddRequestingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_AddRequestingMemberAction {
    pub fn new() -> GroupChange_Actions_AddRequestingMemberAction {
        ::std::default::Default::default()
    }

    // .signalservice.RequestingMember added = 1;


    pub fn get_added(&self) -> &RequestingMember {
        self.added.as_ref().unwrap_or_else(|| <RequestingMember as ::protobuf::Message>::default_instance())
    }
    pub fn clear_added(&mut self) {
        self.added.clear();
    }

    pub fn has_added(&self) -> bool {
        self.added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_added(&mut self, v: RequestingMember) {
        self.added = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_added(&mut self) -> &mut RequestingMember {
        if self.added.is_none() {
            self.added.set_default();
        }
        self.added.as_mut().unwrap()
    }

    // Take field
    pub fn take_added(&mut self) -> RequestingMember {
        self.added.take().unwrap_or_else(|| RequestingMember::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_AddRequestingMemberAction {
    fn is_initialized(&self) -> bool {
        for v in &self.added {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.added)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.added.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.added.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_AddRequestingMemberAction {
        GroupChange_Actions_AddRequestingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestingMember>>(
                "added",
                |m: &GroupChange_Actions_AddRequestingMemberAction| { &m.added },
                |m: &mut GroupChange_Actions_AddRequestingMemberAction| { &mut m.added },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_AddRequestingMemberAction>(
                "GroupChange.Actions.AddRequestingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_AddRequestingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_AddRequestingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_AddRequestingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_AddRequestingMemberAction {
    fn clear(&mut self) {
        self.added.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_AddRequestingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_AddRequestingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_DeleteRequestingMemberAction {
    // message fields
    pub deletedUserId: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_DeleteRequestingMemberAction {
    fn default() -> &'a GroupChange_Actions_DeleteRequestingMemberAction {
        <GroupChange_Actions_DeleteRequestingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_DeleteRequestingMemberAction {
    pub fn new() -> GroupChange_Actions_DeleteRequestingMemberAction {
        ::std::default::Default::default()
    }

    // bytes deletedUserId = 1;


    pub fn get_deletedUserId(&self) -> &[u8] {
        &self.deletedUserId
    }
    pub fn clear_deletedUserId(&mut self) {
        self.deletedUserId.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedUserId(&mut self, v: ::std::vec::Vec<u8>) {
        self.deletedUserId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletedUserId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.deletedUserId
    }

    // Take field
    pub fn take_deletedUserId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.deletedUserId, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_DeleteRequestingMemberAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.deletedUserId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.deletedUserId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.deletedUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.deletedUserId.is_empty() {
            os.write_bytes(1, &self.deletedUserId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_DeleteRequestingMemberAction {
        GroupChange_Actions_DeleteRequestingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "deletedUserId",
                |m: &GroupChange_Actions_DeleteRequestingMemberAction| { &m.deletedUserId },
                |m: &mut GroupChange_Actions_DeleteRequestingMemberAction| { &mut m.deletedUserId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_DeleteRequestingMemberAction>(
                "GroupChange.Actions.DeleteRequestingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_DeleteRequestingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_DeleteRequestingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_DeleteRequestingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_DeleteRequestingMemberAction {
    fn clear(&mut self) {
        self.deletedUserId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_DeleteRequestingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_DeleteRequestingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_PromoteRequestingMemberAction {
    // message fields
    pub userId: ::std::vec::Vec<u8>,
    pub role: Member_Role,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_PromoteRequestingMemberAction {
    fn default() -> &'a GroupChange_Actions_PromoteRequestingMemberAction {
        <GroupChange_Actions_PromoteRequestingMemberAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_PromoteRequestingMemberAction {
    pub fn new() -> GroupChange_Actions_PromoteRequestingMemberAction {
        ::std::default::Default::default()
    }

    // bytes userId = 1;


    pub fn get_userId(&self) -> &[u8] {
        &self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId.clear();
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: ::std::vec::Vec<u8>) {
        self.userId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userId
    }

    // Take field
    pub fn take_userId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userId, ::std::vec::Vec::new())
    }

    // .signalservice.Member.Role role = 2;


    pub fn get_role(&self) -> Member_Role {
        self.role
    }
    pub fn clear_role(&mut self) {
        self.role = Member_Role::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Member_Role) {
        self.role = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_PromoteRequestingMemberAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userId)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.role, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userId);
        }
        if self.role != Member_Role::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userId.is_empty() {
            os.write_bytes(1, &self.userId)?;
        }
        if self.role != Member_Role::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.role))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_PromoteRequestingMemberAction {
        GroupChange_Actions_PromoteRequestingMemberAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "userId",
                |m: &GroupChange_Actions_PromoteRequestingMemberAction| { &m.userId },
                |m: &mut GroupChange_Actions_PromoteRequestingMemberAction| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Member_Role>>(
                "role",
                |m: &GroupChange_Actions_PromoteRequestingMemberAction| { &m.role },
                |m: &mut GroupChange_Actions_PromoteRequestingMemberAction| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_PromoteRequestingMemberAction>(
                "GroupChange.Actions.PromoteRequestingMemberAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_PromoteRequestingMemberAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_PromoteRequestingMemberAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_PromoteRequestingMemberAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_PromoteRequestingMemberAction {
    fn clear(&mut self) {
        self.userId.clear();
        self.role = Member_Role::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_PromoteRequestingMemberAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_PromoteRequestingMemberAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyTitleAction {
    // message fields
    pub title: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyTitleAction {
    fn default() -> &'a GroupChange_Actions_ModifyTitleAction {
        <GroupChange_Actions_ModifyTitleAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyTitleAction {
    pub fn new() -> GroupChange_Actions_ModifyTitleAction {
        ::std::default::Default::default()
    }

    // bytes title = 1;


    pub fn get_title(&self) -> &[u8] {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::vec::Vec<u8>) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.title, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyTitleAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_bytes(1, &self.title)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyTitleAction {
        GroupChange_Actions_ModifyTitleAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "title",
                |m: &GroupChange_Actions_ModifyTitleAction| { &m.title },
                |m: &mut GroupChange_Actions_ModifyTitleAction| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyTitleAction>(
                "GroupChange.Actions.ModifyTitleAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyTitleAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyTitleAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyTitleAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyTitleAction {
    fn clear(&mut self) {
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyTitleAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyTitleAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyDescriptionAction {
    // message fields
    pub description: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyDescriptionAction {
    fn default() -> &'a GroupChange_Actions_ModifyDescriptionAction {
        <GroupChange_Actions_ModifyDescriptionAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyDescriptionAction {
    pub fn new() -> GroupChange_Actions_ModifyDescriptionAction {
        ::std::default::Default::default()
    }

    // bytes description = 1;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyDescriptionAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.description.is_empty() {
            os.write_bytes(1, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyDescriptionAction {
        GroupChange_Actions_ModifyDescriptionAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description",
                |m: &GroupChange_Actions_ModifyDescriptionAction| { &m.description },
                |m: &mut GroupChange_Actions_ModifyDescriptionAction| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyDescriptionAction>(
                "GroupChange.Actions.ModifyDescriptionAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyDescriptionAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyDescriptionAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyDescriptionAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyDescriptionAction {
    fn clear(&mut self) {
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyDescriptionAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyDescriptionAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyAvatarAction {
    // message fields
    pub avatar: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyAvatarAction {
    fn default() -> &'a GroupChange_Actions_ModifyAvatarAction {
        <GroupChange_Actions_ModifyAvatarAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyAvatarAction {
    pub fn new() -> GroupChange_Actions_ModifyAvatarAction {
        ::std::default::Default::default()
    }

    // string avatar = 1;


    pub fn get_avatar(&self) -> &str {
        &self.avatar
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ::std::string::String) {
        self.avatar = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ::std::string::String {
        &mut self.avatar
    }

    // Take field
    pub fn take_avatar(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyAvatarAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.avatar);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.avatar.is_empty() {
            os.write_string(1, &self.avatar)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyAvatarAction {
        GroupChange_Actions_ModifyAvatarAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar",
                |m: &GroupChange_Actions_ModifyAvatarAction| { &m.avatar },
                |m: &mut GroupChange_Actions_ModifyAvatarAction| { &mut m.avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyAvatarAction>(
                "GroupChange.Actions.ModifyAvatarAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyAvatarAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyAvatarAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyAvatarAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyAvatarAction {
    fn clear(&mut self) {
        self.avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyAvatarAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyAvatarAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    // message fields
    pub timer: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    fn default() -> &'a GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        <GroupChange_Actions_ModifyDisappearingMessagesTimerAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    pub fn new() -> GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        ::std::default::Default::default()
    }

    // bytes timer = 1;


    pub fn get_timer(&self) -> &[u8] {
        &self.timer
    }
    pub fn clear_timer(&mut self) {
        self.timer.clear();
    }

    // Param is passed by value, moved
    pub fn set_timer(&mut self, v: ::std::vec::Vec<u8>) {
        self.timer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.timer
    }

    // Take field
    pub fn take_timer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.timer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.timer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.timer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.timer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.timer.is_empty() {
            os.write_bytes(1, &self.timer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        GroupChange_Actions_ModifyDisappearingMessagesTimerAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "timer",
                |m: &GroupChange_Actions_ModifyDisappearingMessagesTimerAction| { &m.timer },
                |m: &mut GroupChange_Actions_ModifyDisappearingMessagesTimerAction| { &mut m.timer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyDisappearingMessagesTimerAction>(
                "GroupChange.Actions.ModifyDisappearingMessagesTimerAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyDisappearingMessagesTimerAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyDisappearingMessagesTimerAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    fn clear(&mut self) {
        self.timer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyDisappearingMessagesTimerAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyAttributesAccessControlAction {
    // message fields
    pub attributesAccess: AccessControl_AccessRequired,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyAttributesAccessControlAction {
    fn default() -> &'a GroupChange_Actions_ModifyAttributesAccessControlAction {
        <GroupChange_Actions_ModifyAttributesAccessControlAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyAttributesAccessControlAction {
    pub fn new() -> GroupChange_Actions_ModifyAttributesAccessControlAction {
        ::std::default::Default::default()
    }

    // .signalservice.AccessControl.AccessRequired attributesAccess = 1;


    pub fn get_attributesAccess(&self) -> AccessControl_AccessRequired {
        self.attributesAccess
    }
    pub fn clear_attributesAccess(&mut self) {
        self.attributesAccess = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_attributesAccess(&mut self, v: AccessControl_AccessRequired) {
        self.attributesAccess = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyAttributesAccessControlAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attributesAccess, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attributesAccess != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.attributesAccess);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attributesAccess != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.attributesAccess))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyAttributesAccessControlAction {
        GroupChange_Actions_ModifyAttributesAccessControlAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "attributesAccess",
                |m: &GroupChange_Actions_ModifyAttributesAccessControlAction| { &m.attributesAccess },
                |m: &mut GroupChange_Actions_ModifyAttributesAccessControlAction| { &mut m.attributesAccess },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyAttributesAccessControlAction>(
                "GroupChange.Actions.ModifyAttributesAccessControlAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyAttributesAccessControlAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyAttributesAccessControlAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyAttributesAccessControlAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyAttributesAccessControlAction {
    fn clear(&mut self) {
        self.attributesAccess = AccessControl_AccessRequired::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyAttributesAccessControlAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyAttributesAccessControlAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyMembersAccessControlAction {
    // message fields
    pub membersAccess: AccessControl_AccessRequired,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyMembersAccessControlAction {
    fn default() -> &'a GroupChange_Actions_ModifyMembersAccessControlAction {
        <GroupChange_Actions_ModifyMembersAccessControlAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyMembersAccessControlAction {
    pub fn new() -> GroupChange_Actions_ModifyMembersAccessControlAction {
        ::std::default::Default::default()
    }

    // .signalservice.AccessControl.AccessRequired membersAccess = 1;


    pub fn get_membersAccess(&self) -> AccessControl_AccessRequired {
        self.membersAccess
    }
    pub fn clear_membersAccess(&mut self) {
        self.membersAccess = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_membersAccess(&mut self, v: AccessControl_AccessRequired) {
        self.membersAccess = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyMembersAccessControlAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.membersAccess, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.membersAccess != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.membersAccess);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.membersAccess != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.membersAccess))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyMembersAccessControlAction {
        GroupChange_Actions_ModifyMembersAccessControlAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "membersAccess",
                |m: &GroupChange_Actions_ModifyMembersAccessControlAction| { &m.membersAccess },
                |m: &mut GroupChange_Actions_ModifyMembersAccessControlAction| { &mut m.membersAccess },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyMembersAccessControlAction>(
                "GroupChange.Actions.ModifyMembersAccessControlAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyMembersAccessControlAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyMembersAccessControlAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyMembersAccessControlAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyMembersAccessControlAction {
    fn clear(&mut self) {
        self.membersAccess = AccessControl_AccessRequired::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyMembersAccessControlAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyMembersAccessControlAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    // message fields
    pub addFromInviteLinkAccess: AccessControl_AccessRequired,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    fn default() -> &'a GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        <GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    pub fn new() -> GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        ::std::default::Default::default()
    }

    // .signalservice.AccessControl.AccessRequired addFromInviteLinkAccess = 1;


    pub fn get_addFromInviteLinkAccess(&self) -> AccessControl_AccessRequired {
        self.addFromInviteLinkAccess
    }
    pub fn clear_addFromInviteLinkAccess(&mut self) {
        self.addFromInviteLinkAccess = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_addFromInviteLinkAccess(&mut self, v: AccessControl_AccessRequired) {
        self.addFromInviteLinkAccess = v;
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.addFromInviteLinkAccess, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.addFromInviteLinkAccess != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.addFromInviteLinkAccess);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.addFromInviteLinkAccess != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.addFromInviteLinkAccess))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "addFromInviteLinkAccess",
                |m: &GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction| { &m.addFromInviteLinkAccess },
                |m: &mut GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction| { &mut m.addFromInviteLinkAccess },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction>(
                "GroupChange.Actions.ModifyAddFromInviteLinkAccessControlAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    fn clear(&mut self) {
        self.addFromInviteLinkAccess = AccessControl_AccessRequired::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyAddFromInviteLinkAccessControlAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChange_Actions_ModifyInviteLinkPasswordAction {
    // message fields
    pub inviteLinkPassword: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChange_Actions_ModifyInviteLinkPasswordAction {
    fn default() -> &'a GroupChange_Actions_ModifyInviteLinkPasswordAction {
        <GroupChange_Actions_ModifyInviteLinkPasswordAction as ::protobuf::Message>::default_instance()
    }
}

impl GroupChange_Actions_ModifyInviteLinkPasswordAction {
    pub fn new() -> GroupChange_Actions_ModifyInviteLinkPasswordAction {
        ::std::default::Default::default()
    }

    // bytes inviteLinkPassword = 1;


    pub fn get_inviteLinkPassword(&self) -> &[u8] {
        &self.inviteLinkPassword
    }
    pub fn clear_inviteLinkPassword(&mut self) {
        self.inviteLinkPassword.clear();
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkPassword(&mut self, v: ::std::vec::Vec<u8>) {
        self.inviteLinkPassword = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteLinkPassword(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.inviteLinkPassword
    }

    // Take field
    pub fn take_inviteLinkPassword(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.inviteLinkPassword, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupChange_Actions_ModifyInviteLinkPasswordAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.inviteLinkPassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.inviteLinkPassword.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.inviteLinkPassword);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.inviteLinkPassword.is_empty() {
            os.write_bytes(1, &self.inviteLinkPassword)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChange_Actions_ModifyInviteLinkPasswordAction {
        GroupChange_Actions_ModifyInviteLinkPasswordAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inviteLinkPassword",
                |m: &GroupChange_Actions_ModifyInviteLinkPasswordAction| { &m.inviteLinkPassword },
                |m: &mut GroupChange_Actions_ModifyInviteLinkPasswordAction| { &mut m.inviteLinkPassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChange_Actions_ModifyInviteLinkPasswordAction>(
                "GroupChange.Actions.ModifyInviteLinkPasswordAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChange_Actions_ModifyInviteLinkPasswordAction {
        static instance: ::protobuf::rt::LazyV2<GroupChange_Actions_ModifyInviteLinkPasswordAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChange_Actions_ModifyInviteLinkPasswordAction::new)
    }
}

impl ::protobuf::Clear for GroupChange_Actions_ModifyInviteLinkPasswordAction {
    fn clear(&mut self) {
        self.inviteLinkPassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChange_Actions_ModifyInviteLinkPasswordAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChange_Actions_ModifyInviteLinkPasswordAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChanges {
    // message fields
    pub groupChanges: ::protobuf::RepeatedField<GroupChanges_GroupChangeState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChanges {
    fn default() -> &'a GroupChanges {
        <GroupChanges as ::protobuf::Message>::default_instance()
    }
}

impl GroupChanges {
    pub fn new() -> GroupChanges {
        ::std::default::Default::default()
    }

    // repeated .signalservice.GroupChanges.GroupChangeState groupChanges = 1;


    pub fn get_groupChanges(&self) -> &[GroupChanges_GroupChangeState] {
        &self.groupChanges
    }
    pub fn clear_groupChanges(&mut self) {
        self.groupChanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_groupChanges(&mut self, v: ::protobuf::RepeatedField<GroupChanges_GroupChangeState>) {
        self.groupChanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groupChanges(&mut self) -> &mut ::protobuf::RepeatedField<GroupChanges_GroupChangeState> {
        &mut self.groupChanges
    }

    // Take field
    pub fn take_groupChanges(&mut self) -> ::protobuf::RepeatedField<GroupChanges_GroupChangeState> {
        ::std::mem::replace(&mut self.groupChanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GroupChanges {
    fn is_initialized(&self) -> bool {
        for v in &self.groupChanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groupChanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.groupChanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.groupChanges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChanges {
        GroupChanges::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChanges_GroupChangeState>>(
                "groupChanges",
                |m: &GroupChanges| { &m.groupChanges },
                |m: &mut GroupChanges| { &mut m.groupChanges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChanges>(
                "GroupChanges",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChanges {
        static instance: ::protobuf::rt::LazyV2<GroupChanges> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChanges::new)
    }
}

impl ::protobuf::Clear for GroupChanges {
    fn clear(&mut self) {
        self.groupChanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChanges {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupChanges_GroupChangeState {
    // message fields
    pub groupChange: ::protobuf::SingularPtrField<GroupChange>,
    pub groupState: ::protobuf::SingularPtrField<Group>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupChanges_GroupChangeState {
    fn default() -> &'a GroupChanges_GroupChangeState {
        <GroupChanges_GroupChangeState as ::protobuf::Message>::default_instance()
    }
}

impl GroupChanges_GroupChangeState {
    pub fn new() -> GroupChanges_GroupChangeState {
        ::std::default::Default::default()
    }

    // .signalservice.GroupChange groupChange = 1;


    pub fn get_groupChange(&self) -> &GroupChange {
        self.groupChange.as_ref().unwrap_or_else(|| <GroupChange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groupChange(&mut self) {
        self.groupChange.clear();
    }

    pub fn has_groupChange(&self) -> bool {
        self.groupChange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupChange(&mut self, v: GroupChange) {
        self.groupChange = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupChange(&mut self) -> &mut GroupChange {
        if self.groupChange.is_none() {
            self.groupChange.set_default();
        }
        self.groupChange.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupChange(&mut self) -> GroupChange {
        self.groupChange.take().unwrap_or_else(|| GroupChange::new())
    }

    // .signalservice.Group groupState = 2;


    pub fn get_groupState(&self) -> &Group {
        self.groupState.as_ref().unwrap_or_else(|| <Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groupState(&mut self) {
        self.groupState.clear();
    }

    pub fn has_groupState(&self) -> bool {
        self.groupState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupState(&mut self, v: Group) {
        self.groupState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupState(&mut self) -> &mut Group {
        if self.groupState.is_none() {
            self.groupState.set_default();
        }
        self.groupState.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupState(&mut self) -> Group {
        self.groupState.take().unwrap_or_else(|| Group::new())
    }
}

impl ::protobuf::Message for GroupChanges_GroupChangeState {
    fn is_initialized(&self) -> bool {
        for v in &self.groupChange {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupChange)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.groupChange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.groupState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.groupChange.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.groupState.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupChanges_GroupChangeState {
        GroupChanges_GroupChangeState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupChange>>(
                "groupChange",
                |m: &GroupChanges_GroupChangeState| { &m.groupChange },
                |m: &mut GroupChanges_GroupChangeState| { &mut m.groupChange },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Group>>(
                "groupState",
                |m: &GroupChanges_GroupChangeState| { &m.groupState },
                |m: &mut GroupChanges_GroupChangeState| { &mut m.groupState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupChanges_GroupChangeState>(
                "GroupChanges.GroupChangeState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupChanges_GroupChangeState {
        static instance: ::protobuf::rt::LazyV2<GroupChanges_GroupChangeState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupChanges_GroupChangeState::new)
    }
}

impl ::protobuf::Clear for GroupChanges_GroupChangeState {
    fn clear(&mut self) {
        self.groupChange.clear();
        self.groupState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupChanges_GroupChangeState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChanges_GroupChangeState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupAttributeBlob {
    // message oneof groups
    pub content: ::std::option::Option<GroupAttributeBlob_oneof_content>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupAttributeBlob {
    fn default() -> &'a GroupAttributeBlob {
        <GroupAttributeBlob as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum GroupAttributeBlob_oneof_content {
    title(::std::string::String),
    avatar(::std::vec::Vec<u8>),
    disappearingMessagesDuration(u32),
    description(::std::string::String),
}

impl GroupAttributeBlob {
    pub fn new() -> GroupAttributeBlob {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(v))
    }

    // Mutable pointer to the field.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        if self.has_title() {
            match self.content.take() {
                ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes avatar = 2;


    pub fn get_avatar(&self) -> &[u8] {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_avatar(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_avatar(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avatar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(::std::vec::Vec::new()));
        }
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avatar(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_avatar() {
            match self.content.take() {
                ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // uint32 disappearingMessagesDuration = 3;


    pub fn get_disappearingMessagesDuration(&self) -> u32 {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::disappearingMessagesDuration(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_disappearingMessagesDuration(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_disappearingMessagesDuration(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::disappearingMessagesDuration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disappearingMessagesDuration(&mut self, v: u32) {
        self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::disappearingMessagesDuration(v))
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(v))
    }

    // Mutable pointer to the field.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        if self.has_description() {
            match self.content.take() {
                ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for GroupAttributeBlob {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::title(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::avatar(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::disappearingMessagesDuration(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GroupAttributeBlob_oneof_content::description(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &GroupAttributeBlob_oneof_content::title(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &GroupAttributeBlob_oneof_content::avatar(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &GroupAttributeBlob_oneof_content::disappearingMessagesDuration(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &GroupAttributeBlob_oneof_content::description(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &GroupAttributeBlob_oneof_content::title(ref v) => {
                    os.write_string(1, v)?;
                },
                &GroupAttributeBlob_oneof_content::avatar(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &GroupAttributeBlob_oneof_content::disappearingMessagesDuration(v) => {
                    os.write_uint32(3, v)?;
                },
                &GroupAttributeBlob_oneof_content::description(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupAttributeBlob {
        GroupAttributeBlob::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "title",
                GroupAttributeBlob::has_title,
                GroupAttributeBlob::get_title,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "avatar",
                GroupAttributeBlob::has_avatar,
                GroupAttributeBlob::get_avatar,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "disappearingMessagesDuration",
                GroupAttributeBlob::has_disappearingMessagesDuration,
                GroupAttributeBlob::get_disappearingMessagesDuration,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "description",
                GroupAttributeBlob::has_description,
                GroupAttributeBlob::get_description,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupAttributeBlob>(
                "GroupAttributeBlob",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupAttributeBlob {
        static instance: ::protobuf::rt::LazyV2<GroupAttributeBlob> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupAttributeBlob::new)
    }
}

impl ::protobuf::Clear for GroupAttributeBlob {
    fn clear(&mut self) {
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupAttributeBlob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupAttributeBlob {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupInviteLink {
    // message oneof groups
    pub contents: ::std::option::Option<GroupInviteLink_oneof_contents>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupInviteLink {
    fn default() -> &'a GroupInviteLink {
        <GroupInviteLink as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum GroupInviteLink_oneof_contents {
    v1Contents(GroupInviteLink_GroupInviteLinkContentsV1),
}

impl GroupInviteLink {
    pub fn new() -> GroupInviteLink {
        ::std::default::Default::default()
    }

    // .signalservice.GroupInviteLink.GroupInviteLinkContentsV1 v1Contents = 1;


    pub fn get_v1Contents(&self) -> &GroupInviteLink_GroupInviteLinkContentsV1 {
        match self.contents {
            ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(ref v)) => v,
            _ => <GroupInviteLink_GroupInviteLinkContentsV1 as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_v1Contents(&mut self) {
        self.contents = ::std::option::Option::None;
    }

    pub fn has_v1Contents(&self) -> bool {
        match self.contents {
            ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v1Contents(&mut self, v: GroupInviteLink_GroupInviteLinkContentsV1) {
        self.contents = ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(v))
    }

    // Mutable pointer to the field.
    pub fn mut_v1Contents(&mut self) -> &mut GroupInviteLink_GroupInviteLinkContentsV1 {
        if let ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(_)) = self.contents {
        } else {
            self.contents = ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(GroupInviteLink_GroupInviteLinkContentsV1::new()));
        }
        match self.contents {
            ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_v1Contents(&mut self) -> GroupInviteLink_GroupInviteLinkContentsV1 {
        if self.has_v1Contents() {
            match self.contents.take() {
                ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(v)) => v,
                _ => panic!(),
            }
        } else {
            GroupInviteLink_GroupInviteLinkContentsV1::new()
        }
    }
}

impl ::protobuf::Message for GroupInviteLink {
    fn is_initialized(&self) -> bool {
        if let Some(GroupInviteLink_oneof_contents::v1Contents(ref v)) = self.contents {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.contents = ::std::option::Option::Some(GroupInviteLink_oneof_contents::v1Contents(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.contents {
            match v {
                &GroupInviteLink_oneof_contents::v1Contents(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.contents {
            match v {
                &GroupInviteLink_oneof_contents::v1Contents(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupInviteLink {
        GroupInviteLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GroupInviteLink_GroupInviteLinkContentsV1>(
                "v1Contents",
                GroupInviteLink::has_v1Contents,
                GroupInviteLink::get_v1Contents,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupInviteLink>(
                "GroupInviteLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupInviteLink {
        static instance: ::protobuf::rt::LazyV2<GroupInviteLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupInviteLink::new)
    }
}

impl ::protobuf::Clear for GroupInviteLink {
    fn clear(&mut self) {
        self.contents = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupInviteLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupInviteLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupInviteLink_GroupInviteLinkContentsV1 {
    // message fields
    pub groupMasterKey: ::std::vec::Vec<u8>,
    pub inviteLinkPassword: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupInviteLink_GroupInviteLinkContentsV1 {
    fn default() -> &'a GroupInviteLink_GroupInviteLinkContentsV1 {
        <GroupInviteLink_GroupInviteLinkContentsV1 as ::protobuf::Message>::default_instance()
    }
}

impl GroupInviteLink_GroupInviteLinkContentsV1 {
    pub fn new() -> GroupInviteLink_GroupInviteLinkContentsV1 {
        ::std::default::Default::default()
    }

    // bytes groupMasterKey = 1;


    pub fn get_groupMasterKey(&self) -> &[u8] {
        &self.groupMasterKey
    }
    pub fn clear_groupMasterKey(&mut self) {
        self.groupMasterKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_groupMasterKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.groupMasterKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupMasterKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.groupMasterKey
    }

    // Take field
    pub fn take_groupMasterKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.groupMasterKey, ::std::vec::Vec::new())
    }

    // bytes inviteLinkPassword = 2;


    pub fn get_inviteLinkPassword(&self) -> &[u8] {
        &self.inviteLinkPassword
    }
    pub fn clear_inviteLinkPassword(&mut self) {
        self.inviteLinkPassword.clear();
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkPassword(&mut self, v: ::std::vec::Vec<u8>) {
        self.inviteLinkPassword = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteLinkPassword(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.inviteLinkPassword
    }

    // Take field
    pub fn take_inviteLinkPassword(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.inviteLinkPassword, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupInviteLink_GroupInviteLinkContentsV1 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.groupMasterKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.inviteLinkPassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.groupMasterKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.groupMasterKey);
        }
        if !self.inviteLinkPassword.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.inviteLinkPassword);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.groupMasterKey.is_empty() {
            os.write_bytes(1, &self.groupMasterKey)?;
        }
        if !self.inviteLinkPassword.is_empty() {
            os.write_bytes(2, &self.inviteLinkPassword)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupInviteLink_GroupInviteLinkContentsV1 {
        GroupInviteLink_GroupInviteLinkContentsV1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "groupMasterKey",
                |m: &GroupInviteLink_GroupInviteLinkContentsV1| { &m.groupMasterKey },
                |m: &mut GroupInviteLink_GroupInviteLinkContentsV1| { &mut m.groupMasterKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inviteLinkPassword",
                |m: &GroupInviteLink_GroupInviteLinkContentsV1| { &m.inviteLinkPassword },
                |m: &mut GroupInviteLink_GroupInviteLinkContentsV1| { &mut m.inviteLinkPassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupInviteLink_GroupInviteLinkContentsV1>(
                "GroupInviteLink.GroupInviteLinkContentsV1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupInviteLink_GroupInviteLinkContentsV1 {
        static instance: ::protobuf::rt::LazyV2<GroupInviteLink_GroupInviteLinkContentsV1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupInviteLink_GroupInviteLinkContentsV1::new)
    }
}

impl ::protobuf::Clear for GroupInviteLink_GroupInviteLinkContentsV1 {
    fn clear(&mut self) {
        self.groupMasterKey.clear();
        self.inviteLinkPassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupInviteLink_GroupInviteLinkContentsV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupInviteLink_GroupInviteLinkContentsV1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupJoinInfo {
    // message fields
    pub publicKey: ::std::vec::Vec<u8>,
    pub title: ::std::vec::Vec<u8>,
    pub avatar: ::std::string::String,
    pub memberCount: u32,
    pub addFromInviteLink: AccessControl_AccessRequired,
    pub revision: u32,
    pub pendingAdminApproval: bool,
    pub description: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupJoinInfo {
    fn default() -> &'a GroupJoinInfo {
        <GroupJoinInfo as ::protobuf::Message>::default_instance()
    }
}

impl GroupJoinInfo {
    pub fn new() -> GroupJoinInfo {
        ::std::default::Default::default()
    }

    // bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        &self.publicKey
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.publicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.publicKey
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.publicKey, ::std::vec::Vec::new())
    }

    // bytes title = 2;


    pub fn get_title(&self) -> &[u8] {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::vec::Vec<u8>) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.title, ::std::vec::Vec::new())
    }

    // string avatar = 3;


    pub fn get_avatar(&self) -> &str {
        &self.avatar
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ::std::string::String) {
        self.avatar = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ::std::string::String {
        &mut self.avatar
    }

    // Take field
    pub fn take_avatar(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar, ::std::string::String::new())
    }

    // uint32 memberCount = 4;


    pub fn get_memberCount(&self) -> u32 {
        self.memberCount
    }
    pub fn clear_memberCount(&mut self) {
        self.memberCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_memberCount(&mut self, v: u32) {
        self.memberCount = v;
    }

    // .signalservice.AccessControl.AccessRequired addFromInviteLink = 5;


    pub fn get_addFromInviteLink(&self) -> AccessControl_AccessRequired {
        self.addFromInviteLink
    }
    pub fn clear_addFromInviteLink(&mut self) {
        self.addFromInviteLink = AccessControl_AccessRequired::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_addFromInviteLink(&mut self, v: AccessControl_AccessRequired) {
        self.addFromInviteLink = v;
    }

    // uint32 revision = 6;


    pub fn get_revision(&self) -> u32 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = v;
    }

    // bool pendingAdminApproval = 7;


    pub fn get_pendingAdminApproval(&self) -> bool {
        self.pendingAdminApproval
    }
    pub fn clear_pendingAdminApproval(&mut self) {
        self.pendingAdminApproval = false;
    }

    // Param is passed by value, moved
    pub fn set_pendingAdminApproval(&mut self, v: bool) {
        self.pendingAdminApproval = v;
    }

    // bytes description = 8;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GroupJoinInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.memberCount = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.addFromInviteLink, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pendingAdminApproval = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.publicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.publicKey);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.title);
        }
        if !self.avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.avatar);
        }
        if self.memberCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.memberCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.addFromInviteLink != AccessControl_AccessRequired::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.addFromInviteLink);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(6, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pendingAdminApproval != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.publicKey.is_empty() {
            os.write_bytes(1, &self.publicKey)?;
        }
        if !self.title.is_empty() {
            os.write_bytes(2, &self.title)?;
        }
        if !self.avatar.is_empty() {
            os.write_string(3, &self.avatar)?;
        }
        if self.memberCount != 0 {
            os.write_uint32(4, self.memberCount)?;
        }
        if self.addFromInviteLink != AccessControl_AccessRequired::UNKNOWN {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.addFromInviteLink))?;
        }
        if self.revision != 0 {
            os.write_uint32(6, self.revision)?;
        }
        if self.pendingAdminApproval != false {
            os.write_bool(7, self.pendingAdminApproval)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(8, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupJoinInfo {
        GroupJoinInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "publicKey",
                |m: &GroupJoinInfo| { &m.publicKey },
                |m: &mut GroupJoinInfo| { &mut m.publicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "title",
                |m: &GroupJoinInfo| { &m.title },
                |m: &mut GroupJoinInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar",
                |m: &GroupJoinInfo| { &m.avatar },
                |m: &mut GroupJoinInfo| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "memberCount",
                |m: &GroupJoinInfo| { &m.memberCount },
                |m: &mut GroupJoinInfo| { &mut m.memberCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessControl_AccessRequired>>(
                "addFromInviteLink",
                |m: &GroupJoinInfo| { &m.addFromInviteLink },
                |m: &mut GroupJoinInfo| { &mut m.addFromInviteLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &GroupJoinInfo| { &m.revision },
                |m: &mut GroupJoinInfo| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pendingAdminApproval",
                |m: &GroupJoinInfo| { &m.pendingAdminApproval },
                |m: &mut GroupJoinInfo| { &mut m.pendingAdminApproval },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description",
                |m: &GroupJoinInfo| { &m.description },
                |m: &mut GroupJoinInfo| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupJoinInfo>(
                "GroupJoinInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupJoinInfo {
        static instance: ::protobuf::rt::LazyV2<GroupJoinInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupJoinInfo::new)
    }
}

impl ::protobuf::Clear for GroupJoinInfo {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.title.clear();
        self.avatar.clear();
        self.memberCount = 0;
        self.addFromInviteLink = AccessControl_AccessRequired::UNKNOWN;
        self.revision = 0;
        self.pendingAdminApproval = false;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupJoinInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupJoinInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupExternalCredential {
    // message fields
    pub token: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupExternalCredential {
    fn default() -> &'a GroupExternalCredential {
        <GroupExternalCredential as ::protobuf::Message>::default_instance()
    }
}

impl GroupExternalCredential {
    pub fn new() -> GroupExternalCredential {
        ::std::default::Default::default()
    }

    // string token = 1;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupExternalCredential {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupExternalCredential {
        GroupExternalCredential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &GroupExternalCredential| { &m.token },
                |m: &mut GroupExternalCredential| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupExternalCredential>(
                "GroupExternalCredential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupExternalCredential {
        static instance: ::protobuf::rt::LazyV2<GroupExternalCredential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupExternalCredential::new)
    }
}

impl ::protobuf::Clear for GroupExternalCredential {
    fn clear(&mut self) {
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupExternalCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupExternalCredential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cgroups.proto\x12\rsignalservice\"\xd4\x01\n\x16AvatarUploadAttribu\
    tes\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x20\n\ncredential\
    \x18\x02\x20\x01(\tR\ncredentialB\0\x12\x12\n\x03acl\x18\x03\x20\x01(\tR\
    \x03aclB\0\x12\x1e\n\talgorithm\x18\x04\x20\x01(\tR\talgorithmB\0\x12\
    \x14\n\x04date\x18\x05\x20\x01(\tR\x04dateB\0\x12\x18\n\x06policy\x18\
    \x06\x20\x01(\tR\x06policyB\0\x12\x1e\n\tsignature\x18\x07\x20\x01(\tR\t\
    signatureB\0:\0\"\x83\x02\n\x06Member\x12\x18\n\x06userId\x18\x01\x20\
    \x01(\x0cR\x06userIdB\0\x120\n\x04role\x18\x02\x20\x01(\x0e2\x1a.signals\
    ervice.Member.RoleR\x04roleB\0\x12\x20\n\nprofileKey\x18\x03\x20\x01(\
    \x0cR\nprofileKeyB\0\x12$\n\x0cpresentation\x18\x04\x20\x01(\x0cR\x0cpre\
    sentationB\0\x12,\n\x10joinedAtRevision\x18\x05\x20\x01(\rR\x10joinedAtR\
    evisionB\0\"5\n\x04Role\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07DEFAULT\
    \x10\x01\x12\x11\n\rADMINISTRATOR\x10\x02\x1a\0:\0\"\x8a\x01\n\rPendingM\
    ember\x12/\n\x06member\x18\x01\x20\x01(\x0b2\x15.signalservice.MemberR\
    \x06memberB\0\x12&\n\raddedByUserId\x18\x02\x20\x01(\x0cR\raddedByUserId\
    B\0\x12\x1e\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestampB\0:\0\"\x96\
    \x01\n\x10RequestingMember\x12\x18\n\x06userId\x18\x01\x20\x01(\x0cR\x06\
    userIdB\0\x12\x20\n\nprofileKey\x18\x02\x20\x01(\x0cR\nprofileKeyB\0\x12\
    $\n\x0cpresentation\x18\x03\x20\x01(\x0cR\x0cpresentationB\0\x12\x1e\n\t\
    timestamp\x18\x04\x20\x01(\x04R\ttimestampB\0:\0\"\xe2\x02\n\rAccessCont\
    rol\x12M\n\nattributes\x18\x01\x20\x01(\x0e2+.signalservice.AccessContro\
    l.AccessRequiredR\nattributesB\0\x12G\n\x07members\x18\x02\x20\x01(\x0e2\
    +.signalservice.AccessControl.AccessRequiredR\x07membersB\0\x12[\n\x11ad\
    dFromInviteLink\x18\x03\x20\x01(\x0e2+.signalservice.AccessControl.Acces\
    sRequiredR\x11addFromInviteLinkB\0\"Z\n\x0eAccessRequired\x12\x0b\n\x07U\
    NKNOWN\x10\0\x12\x07\n\x03ANY\x10\x01\x12\n\n\x06MEMBER\x10\x02\x12\x11\
    \n\rADMINISTRATOR\x10\x03\x12\x11\n\rUNSATISFIABLE\x10\x04\x1a\0:\0\"\
    \xa1\x04\n\x05Group\x12\x1e\n\tpublicKey\x18\x01\x20\x01(\x0cR\tpublicKe\
    yB\0\x12\x16\n\x05title\x18\x02\x20\x01(\x0cR\x05titleB\0\x12\x18\n\x06a\
    vatar\x18\x03\x20\x01(\tR\x06avatarB\0\x12>\n\x19disappearingMessagesTim\
    er\x18\x04\x20\x01(\x0cR\x19disappearingMessagesTimerB\0\x12D\n\raccessC\
    ontrol\x18\x05\x20\x01(\x0b2\x1c.signalservice.AccessControlR\raccessCon\
    trolB\0\x12\x1c\n\x08revision\x18\x06\x20\x01(\rR\x08revisionB\0\x121\n\
    \x07members\x18\x07\x20\x03(\x0b2\x15.signalservice.MemberR\x07membersB\
    \0\x12F\n\x0ependingMembers\x18\x08\x20\x03(\x0b2\x1c.signalservice.Pend\
    ingMemberR\x0ependingMembersB\0\x12O\n\x11requestingMembers\x18\t\x20\
    \x03(\x0b2\x1f.signalservice.RequestingMemberR\x11requestingMembersB\0\
    \x120\n\x12inviteLinkPassword\x18\n\x20\x01(\x0cR\x12inviteLinkPasswordB\
    \0\x12\"\n\x0bdescription\x18\x0b\x20\x01(\x0cR\x0bdescriptionB\0:\0\"\
    \xa5\x1e\n\x0bGroupChange\x12\x1a\n\x07actions\x18\x01\x20\x01(\x0cR\x07\
    actionsB\0\x12*\n\x0fserverSignature\x18\x02\x20\x01(\x0cR\x0fserverSign\
    atureB\0\x12\"\n\x0bchangeEpoch\x18\x03\x20\x01(\rR\x0bchangeEpochB\0\
    \x1a\xa7\x1d\n\x07Actions\x12\x20\n\nsourceUuid\x18\x01\x20\x01(\x0cR\ns\
    ourceUuidB\0\x12\x1c\n\x08revision\x18\x02\x20\x01(\rR\x08revisionB\0\
    \x12T\n\naddMembers\x18\x03\x20\x03(\x0b22.signalservice.GroupChange.Act\
    ions.AddMemberActionR\naddMembersB\0\x12]\n\rdeleteMembers\x18\x04\x20\
    \x03(\x0b25.signalservice.GroupChange.Actions.DeleteMemberActionR\rdelet\
    eMembersB\0\x12i\n\x11modifyMemberRoles\x18\x05\x20\x03(\x0b29.signalser\
    vice.GroupChange.Actions.ModifyMemberRoleActionR\x11modifyMemberRolesB\0\
    \x12{\n\x17modifyMemberProfileKeys\x18\x06\x20\x03(\x0b2?.signalservice.\
    GroupChange.Actions.ModifyMemberProfileKeyActionR\x17modifyMemberProfile\
    KeysB\0\x12i\n\x11addPendingMembers\x18\x07\x20\x03(\x0b29.signalservice\
    .GroupChange.Actions.AddPendingMemberActionR\x11addPendingMembersB\0\x12\
    r\n\x14deletePendingMembers\x18\x08\x20\x03(\x0b2<.signalservice.GroupCh\
    ange.Actions.DeletePendingMemberActionR\x14deletePendingMembersB\0\x12u\
    \n\x15promotePendingMembers\x18\t\x20\x03(\x0b2=.signalservice.GroupChan\
    ge.Actions.PromotePendingMemberActionR\x15promotePendingMembersB\0\x12X\
    \n\x0bmodifyTitle\x18\n\x20\x01(\x0b24.signalservice.GroupChange.Actions\
    .ModifyTitleActionR\x0bmodifyTitleB\0\x12[\n\x0cmodifyAvatar\x18\x0b\x20\
    \x01(\x0b25.signalservice.GroupChange.Actions.ModifyAvatarActionR\x0cmod\
    ifyAvatarB\0\x12\x94\x01\n\x1fmodifyDisappearingMessagesTimer\x18\x0c\
    \x20\x01(\x0b2H.signalservice.GroupChange.Actions.ModifyDisappearingMess\
    agesTimerActionR\x1fmodifyDisappearingMessagesTimerB\0\x12\x80\x01\n\x16\
    modifyAttributesAccess\x18\r\x20\x01(\x0b2F.signalservice.GroupChange.Ac\
    tions.ModifyAttributesAccessControlActionR\x16modifyAttributesAccessB\0\
    \x12u\n\x12modifyMemberAccess\x18\x0e\x20\x01(\x0b2C.signalservice.Group\
    Change.Actions.ModifyMembersAccessControlActionR\x12modifyMemberAccessB\
    \0\x12\x95\x01\n\x1dmodifyAddFromInviteLinkAccess\x18\x0f\x20\x01(\x0b2M\
    .signalservice.GroupChange.Actions.ModifyAddFromInviteLinkAccessControlA\
    ctionR\x1dmodifyAddFromInviteLinkAccessB\0\x12r\n\x14addRequestingMember\
    s\x18\x10\x20\x03(\x0b2<.signalservice.GroupChange.Actions.AddRequesting\
    MemberActionR\x14addRequestingMembersB\0\x12{\n\x17deleteRequestingMembe\
    rs\x18\x11\x20\x03(\x0b2?.signalservice.GroupChange.Actions.DeleteReques\
    tingMemberActionR\x17deleteRequestingMembersB\0\x12~\n\x18promoteRequest\
    ingMembers\x18\x12\x20\x03(\x0b2@.signalservice.GroupChange.Actions.Prom\
    oteRequestingMemberActionR\x18promoteRequestingMembersB\0\x12\x7f\n\x18m\
    odifyInviteLinkPassword\x18\x13\x20\x01(\x0b2A.signalservice.GroupChange\
    .Actions.ModifyInviteLinkPasswordActionR\x18modifyInviteLinkPasswordB\0\
    \x12j\n\x11modifyDescription\x18\x14\x20\x01(\x0b2:.signalservice.GroupC\
    hange.Actions.ModifyDescriptionActionR\x11modifyDescriptionB\0\x1at\n\
    \x0fAddMemberAction\x12-\n\x05added\x18\x01\x20\x01(\x0b2\x15.signalserv\
    ice.MemberR\x05addedB\0\x120\n\x12joinFromInviteLink\x18\x02\x20\x01(\
    \x08R\x12joinFromInviteLinkB\0:\0\x1a>\n\x12DeleteMemberAction\x12&\n\rd\
    eletedUserId\x18\x01\x20\x01(\x0cR\rdeletedUserIdB\0:\0\x1af\n\x16Modify\
    MemberRoleAction\x12\x18\n\x06userId\x18\x01\x20\x01(\x0cR\x06userIdB\0\
    \x120\n\x04role\x18\x02\x20\x01(\x0e2\x1a.signalservice.Member.RoleR\x04\
    roleB\0:\0\x1aF\n\x1cModifyMemberProfileKeyAction\x12$\n\x0cpresentation\
    \x18\x01\x20\x01(\x0cR\x0cpresentationB\0:\0\x1aP\n\x16AddPendingMemberA\
    ction\x124\n\x05added\x18\x01\x20\x01(\x0b2\x1c.signalservice.PendingMem\
    berR\x05addedB\0:\0\x1aE\n\x19DeletePendingMemberAction\x12&\n\rdeletedU\
    serId\x18\x01\x20\x01(\x0cR\rdeletedUserIdB\0:\0\x1aD\n\x1aPromotePendin\
    gMemberAction\x12$\n\x0cpresentation\x18\x01\x20\x01(\x0cR\x0cpresentati\
    onB\0:\0\x1aV\n\x19AddRequestingMemberAction\x127\n\x05added\x18\x01\x20\
    \x01(\x0b2\x1f.signalservice.RequestingMemberR\x05addedB\0:\0\x1aH\n\x1c\
    DeleteRequestingMemberAction\x12&\n\rdeletedUserId\x18\x01\x20\x01(\x0cR\
    \rdeletedUserIdB\0:\0\x1am\n\x1dPromoteRequestingMemberAction\x12\x18\n\
    \x06userId\x18\x01\x20\x01(\x0cR\x06userIdB\0\x120\n\x04role\x18\x02\x20\
    \x01(\x0e2\x1a.signalservice.Member.RoleR\x04roleB\0:\0\x1a-\n\x11Modify\
    TitleAction\x12\x16\n\x05title\x18\x01\x20\x01(\x0cR\x05titleB\0:\0\x1a?\
    \n\x17ModifyDescriptionAction\x12\"\n\x0bdescription\x18\x01\x20\x01(\
    \x0cR\x0bdescriptionB\0:\0\x1a0\n\x12ModifyAvatarAction\x12\x18\n\x06ava\
    tar\x18\x01\x20\x01(\tR\x06avatarB\0:\0\x1aA\n%ModifyDisappearingMessage\
    sTimerAction\x12\x16\n\x05timer\x18\x01\x20\x01(\x0cR\x05timerB\0:\0\x1a\
    \x82\x01\n#ModifyAttributesAccessControlAction\x12Y\n\x10attributesAcces\
    s\x18\x01\x20\x01(\x0e2+.signalservice.AccessControl.AccessRequiredR\x10\
    attributesAccessB\0:\0\x1ay\n\x20ModifyMembersAccessControlAction\x12S\n\
    \rmembersAccess\x18\x01\x20\x01(\x0e2+.signalservice.AccessControl.Acces\
    sRequiredR\rmembersAccessB\0:\0\x1a\x97\x01\n*ModifyAddFromInviteLinkAcc\
    essControlAction\x12g\n\x17addFromInviteLinkAccess\x18\x01\x20\x01(\x0e2\
    +.signalservice.AccessControl.AccessRequiredR\x17addFromInviteLinkAccess\
    B\0:\0\x1aT\n\x1eModifyInviteLinkPasswordAction\x120\n\x12inviteLinkPass\
    word\x18\x01\x20\x01(\x0cR\x12inviteLinkPasswordB\0:\0:\0:\0\"\xf3\x01\n\
    \x0cGroupChanges\x12R\n\x0cgroupChanges\x18\x01\x20\x03(\x0b2,.signalser\
    vice.GroupChanges.GroupChangeStateR\x0cgroupChangesB\0\x1a\x8c\x01\n\x10\
    GroupChangeState\x12>\n\x0bgroupChange\x18\x01\x20\x01(\x0b2\x1a.signals\
    ervice.GroupChangeR\x0bgroupChangeB\0\x126\n\ngroupState\x18\x02\x20\x01\
    (\x0b2\x14.signalservice.GroupR\ngroupStateB\0:\0:\0\"\xc5\x01\n\x12Grou\
    pAttributeBlob\x12\x18\n\x05title\x18\x01\x20\x01(\tH\0R\x05titleB\0\x12\
    \x1a\n\x06avatar\x18\x02\x20\x01(\x0cH\0R\x06avatarB\0\x12F\n\x1cdisappe\
    aringMessagesDuration\x18\x03\x20\x01(\rH\0R\x1cdisappearingMessagesDura\
    tionB\0\x12$\n\x0bdescription\x18\x04\x20\x01(\tH\0R\x0bdescriptionB\0B\
    \t\n\x07content:\0\"\xf8\x01\n\x0fGroupInviteLink\x12\\\n\nv1Contents\
    \x18\x01\x20\x01(\x0b28.signalservice.GroupInviteLink.GroupInviteLinkCon\
    tentsV1H\0R\nv1ContentsB\0\x1ay\n\x19GroupInviteLinkContentsV1\x12(\n\
    \x0egroupMasterKey\x18\x01\x20\x01(\x0cR\x0egroupMasterKeyB\0\x120\n\x12\
    inviteLinkPassword\x18\x02\x20\x01(\x0cR\x12inviteLinkPasswordB\0:\0B\n\
    \n\x08contents:\0\"\xdc\x02\n\rGroupJoinInfo\x12\x1e\n\tpublicKey\x18\
    \x01\x20\x01(\x0cR\tpublicKeyB\0\x12\x16\n\x05title\x18\x02\x20\x01(\x0c\
    R\x05titleB\0\x12\x18\n\x06avatar\x18\x03\x20\x01(\tR\x06avatarB\0\x12\"\
    \n\x0bmemberCount\x18\x04\x20\x01(\rR\x0bmemberCountB\0\x12[\n\x11addFro\
    mInviteLink\x18\x05\x20\x01(\x0e2+.signalservice.AccessControl.AccessReq\
    uiredR\x11addFromInviteLinkB\0\x12\x1c\n\x08revision\x18\x06\x20\x01(\rR\
    \x08revisionB\0\x124\n\x14pendingAdminApproval\x18\x07\x20\x01(\x08R\x14\
    pendingAdminApprovalB\0\x12\"\n\x0bdescription\x18\x08\x20\x01(\x0cR\x0b\
    descriptionB\0:\0\"3\n\x17GroupExternalCredential\x12\x16\n\x05token\x18\
    \x01\x20\x01(\tR\x05tokenB\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
